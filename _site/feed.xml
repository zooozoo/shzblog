<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-01-18T10:54:07+09:00</updated><id>http://localhost:4000/</id><title type="html">Record|Organize|Make it mine</title><subtitle>My programming study blog and I hope it help someone who struggling with code</subtitle><author><name>-Yoda</name></author><entry><title type="html">UX/UI fontsize customzing at atom editor</title><link href="http://localhost:4000/posts/2018-01-17-atom/" rel="alternate" type="text/html" title="UX/UI fontsize customzing at atom editor" /><published>2018-01-17T00:00:00+09:00</published><updated>2018-01-17T00:00:00+09:00</updated><id>http://localhost:4000/posts/atom</id><content type="html" xml:base="http://localhost:4000/posts/2018-01-17-atom/">&lt;p&gt;블로그 작성을 위해서 아톰 editor를 사용하는데
왼쪽 프로젝트의 파일 목록이 나오는 부분과, 파일명을 보여주는 부분의 글씨가 너무 작아서
불편함을 느끼고 있었다. 운영체제의 디스플레이 세팅을 통해서 글씨를 키워볼까 했는데
다른 부분은 모두 만족하고 사용하고 있었기 때문에 건들이기 싫었고 atom의 글씨 크기만
바꾸고 싶었다.&lt;/p&gt;

&lt;p&gt;그래서 검색!&lt;/p&gt;

&lt;p&gt;그리고 찾았다!! 아래는 해당 링크
 &lt;a href=&quot;https://github.com/atom/atom/issues/2530&quot;&gt;https://github.com/atom/atom/issues/2530&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;좀 더 자세히 설명을 남기자면 메뉴에서 settings를 찾아 들어가면
왼쪽 메뉴 맨 밑에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Open Config Folder&lt;/code&gt;라는 버튼이 있다. 해당 버튼을 누르면 아톰설정을
입맛에 맞게 customizing 할 수 있는 폴더 구성이 나오는데 fontsize를 바꾸기 위해서는 가장
밑에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;styles.less&lt;/code&gt;파일을 열고 아래 코드를 붙여넣기 하면 된다.
(글씨 크기는 본인이 원하는 만큼 알아서 적용하자)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@font-size: 15px;
html, body, .tree-view, .tab-bar .tab {
  font-size: @font-size;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><category term="posts" /><category term="ide" /><category term="atom" /><summary type="html">블로그 작성을 위해서 아톰 editor를 사용하는데 왼쪽 프로젝트의 파일 목록이 나오는 부분과, 파일명을 보여주는 부분의 글씨가 너무 작아서 불편함을 느끼고 있었다. 운영체제의 디스플레이 세팅을 통해서 글씨를 키워볼까 했는데 다른 부분은 모두 만족하고 사용하고 있었기 때문에 건들이기 싫었고 atom의 글씨 크기만 바꾸고 싶었다.</summary></entry><entry><title type="html">1월15일~21일</title><link href="http://localhost:4000/til/2018-01-15-1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC/" rel="alternate" type="text/html" title="1월15일~21일" /><published>2018-01-15T00:00:00+09:00</published><updated>2018-01-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC</id><content type="html" xml:base="http://localhost:4000/til/2018-01-15-1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC/">&lt;h3 id=&quot;1월-15일-월요일&quot;&gt;1월 15일 월요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부 &lt;a href=&quot;http://localhost:4000/records/2018-01-15-Hello_Digital_World/&quot;&gt;(링크)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1월-17일-수요일&quot;&gt;1월 17일 수요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부 &lt;a href=&quot;http://localhost:4000/records/2018-01-15-Hello_Digital_World/&quot;&gt;(링크)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>-Yoda</name></author><category term="til" /><summary type="html">1월 15일 월요일</summary></entry><entry><title type="html">Hello_digital_world</title><link href="http://localhost:4000/records/2018-01-15-Hello_Digital_World/" rel="alternate" type="text/html" title="Hello_digital_world" /><published>2018-01-15T00:00:00+09:00</published><updated>2018-01-15T00:00:00+09:00</updated><id>http://localhost:4000/records/Hello_Digital_World</id><content type="html" xml:base="http://localhost:4000/records/2018-01-15-Hello_Digital_World/">&lt;h1 id=&quot;커니핸-교수의-hello-digital-world-공부&quot;&gt;커니핸 교수의 Hello Digital World 공부&lt;/h1&gt;

&lt;p&gt;제이펍 출판사에서 출판한 &lt;code class=&quot;highlighter-rouge&quot;&gt;커니핸 교수의 Hello Digital World&lt;/code&gt;를 공부하며 오래 기억하고 싶은 내용들을 기록한 게시물 입니다.&lt;/p&gt;

&lt;p&gt;저작권 관련 문제가 있을 경우 블로그에서 내리겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;소프트웨어의-계층&quot;&gt;소프트웨어의 계층&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;하드웨어
커널
운영체제
라이브러리집합(API를 통해 접근 가능)
애플리케이션
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;운영 체제와 애플리케이션 사이의 경계는 뚜렷하게 정의되어 있지 않다. 완벽하진 않아도 유용한 지침은 한 애플리케이션이 다른 애플리케이션을 간섭하지 않도록 보장하는 데 필요한 것은 무엇이든 운영체제의 일부라는 점이다. 메모리 관리, 즉 프로그램이 실행되는 동안 메모리 어디에 프로그램을 둘지 결정하는 일은 운영 체제의 일부다. 마찬가지로 디스크 어디에 정보를 저장할 것인지 결정하는 파일 시스템은 핵심적인 기능이다. 장치의 제어도 마찬가지다. 두 개의 애플리케이션이 프린터를 동시에 작동시킬 수 있어서는 안 되고, 중간 조정 없이 디스플레이에 값을 기록해서도 안된다. 중심에서 CPU를 제어하는 일은 운영 체제의 기능인데 다른 모든 속성을 보장하기 위해 필요한 일이기 때문이다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 이야기 하면 애플리케이션이 컴퓨터 자원을 사용하는데 있어서 다른 애플리케이션의 간섭을 받지 않고 독립적으로 우영될 수 있도록 도와주는 일은 운영 체제의 영역.&lt;/p&gt;

&lt;h3 id=&quot;자바스크립트-예제-중-변수에-대해서&quot;&gt;자바스크립트 예제 중 변수에 대해서&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;변수란 프로그램이 실행되는 동안 프로그램이 값을 저장할 수 있는 RAM상의 장소를 뜻한다. 프로그램이 무엇을 하는지에 따라 값이 변경될 수 있기 때문에 변수라고 한다. 변수를 선언하는 것은 모형 어셈블리 언어에서 했던 것처럼 메모리 위치에 이름을 지정하는 일의 고수준 언어 버전이다. 은유적으로, 선언문은 ‘등장인물들’로, 희곡에 나오는 인물의 목록이다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;광케이블에-대하여&quot;&gt;광케이블에 대하여&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;광케이블&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;광케이블&lt;/strong&gt;(光cable, optical cable)이란 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%AC%EC%9C%A0&quot;&gt;광섬유&lt;/a&gt;를 이용한 하나의 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=%ED%86%B5%EC%8B%A0_%EB%A7%A4%EC%B2%B4&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;통신 매체&lt;/a&gt;이다. 광케이블은 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=%EA%B5%AC%EB%A6%AC%EC%84%A0&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;구리선&lt;/a&gt;을 사용하는 통신방식보다 자료 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1%EC%86%8D%EB%8F%84&quot;&gt;전송속도&lt;/a&gt;가 수십 배로 빠르나, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC&quot;&gt;네트워크&lt;/a&gt;를 새로 구축해야 한다는 단점이 있다.&lt;/p&gt;

  &lt;p&gt;(위키백과 발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;광섬유&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;광학섬유라고도 한다. 이 현상을 이용하여 빛을 전송할 때 광손실을 줄이기 위하여 투명도가 고도로 높은 재료가 필요하며, 고순도의 석영이나 광학적 성질이 우수한 고분자재료를 사용한다. 광섬유는 1970년에 미국의 코닝사가 저손실석영섬유를 개발한 것을 계기로 개량을 거듭하여 광통신의 실용화에 크게 이용되고 있다.&lt;/p&gt;

  &lt;p&gt;광통신은 광섬유의 한쪽 끝에서 전기신호를 따라 점멸하는 발광소자를 써서 빛을 점멸하면 광섬유의 다른 쪽 끝에서 수광소자를 써서 이 점멸하는 빛을 받을 수 있는 현상을 이용한 것이다. 수광소자로서 포토다이오드를 쓰면 점멸하는 빛의 신호를 전기신호로 바꿀 수 있고, 발광소자로는 1초 동안에 4억 회나 점멸할 수 있는 발광다이오드도 개발되어 있다. 이 발광소자를 쓰면 광섬유 하나로써 5,760회선의 전화통화가 가능해진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;광케이블은 광섬유를 이용한 것인데 전기 신호를 빛으로의 점멸로 바꾸고 광섬유로 보내서 한쪽 끝에서는 점멸하는 빛을 받아서 전기신호로 바꾸는 것&lt;/p&gt;

&lt;p&gt;이런 기술을 통해서 멀리 떨어진 사람들과 통신할 수 있다는 사실에 대해서 너무나 놀랍고, 이런기술을 만들어낸 기술자들에 대해서 경외심을 가지게 된다.&lt;/p&gt;

&lt;h3 id=&quot;이더넷&quot;&gt;이더넷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴퓨터끼리 연결하거나 프린터 같은 공유 자원에 연결하기 위해 1970년대 초 로버트 메트칼프와 데이빗 바그스가 발명한 네트워킹 기술.&lt;/p&gt;

  &lt;p&gt;(발췌요약)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;패킷&quot;&gt;패킷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이더넷에 대한 정보는 패킷으로 전송된다. 패킷(packet)은 정보를 전송하기 위해 담아 두었다가 수신되면 열어 볼 수 있도록 정확히 정의된 형식으로 정보를 담고 있는 일련의 비트 또는 바이트다. 패킷이 발신자 주소, 수신자 주소, 내용, 여러가지 기타 정보가 표준 형식으로 구성돼 있는 봉투(또는 아마도 엽서)라고 생각하면 상당히 적절한 비유라고 볼 수 있고, 페덱스 같은 택배 회사에서 이용하는 표준화된 포장용 상자도 괜찮은 비유다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;광섬유, 이더넷, 무선 등 서로 다른 물성을 가지고 서로 멀리 떨어져 있을지 모를 네트워크를 어떻게 연결할까? 네트워크와 컴퓨터를 식별하고 조회할 수 있도록 이름과 주소가 필요한데, 전화번호부에서 이름으로 전화번호를 찾는 것과 비슷한 방식을 사용한다. 또한 직접 연결되지 않은 네트워크 사이의 경로를 찾을 수 있어야 한다. 정보가 이동함에 따라 그 형식이 어떻게 바뀌는지, 그리고 오류, 지연, 과부하에 대처하는 것 같은 다수의 다른 덜 명백한 문제에 대해 합의를 봐야한다. 그러한 합의가 없으면 통신하기가 어렵거나 심지어 불가능 할 수 있다.&lt;/p&gt;

  &lt;p&gt;누가 먼저 말하고 어떤 응답이 이어질 수 있는지, 오류를 어떻게 처리할 것인지 등 데이터 형식에 대한 합의는 모든 네트워크에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;프로토콜&lt;/code&gt;을 이용하여 처리되는데, 인터넷에서는 특히 더 그렇다. &lt;code class=&quot;highlighter-rouge&quot;&gt;프로토콜&lt;/code&gt;은 일반적인 담화에서와 어느 정도 같은 의미를 지닌다. 즉, 상대방과 소통하기 위한 일련의 규칙이다. 하지만 네트워크 프로토콜은 사회적 관습이 아닌 기술적 고려 사항을 기반으로 하며, 가장 엄격한 사회 구조의 규칙보다도 훨씬 더 엄밀하게 정의된다.&lt;/p&gt;

  &lt;p&gt;규칙이 완전히 명백하지는 않을 수도 있지만, 인터넷은 그러한 규칙을 강하게 필요로 한다. 정보를 형식화하는 방법, 컴퓨터 간에 정보를 교환하는 방법, 컴퓨터를 식별하고 인증하는 방법, 무언가가 실패할 때 수행할 작업에 대한 프로토콜 및 표준에 모두 동의해야 한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;인터넷-개요&quot;&gt;인터넷 개요&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;오늘날 인터넷은 느슨하게 연결된 수백만 개의 독립적인 네트워크로 구성된다. 가까이 있는 컴퓨터들은 근거리 통신망(종종 무선 이더넷)으로 연결된다. 다음으로 네트워크는 하나의 네트워크에서 다음 네트워크로 정보 패킷을 라우팅하는 특수한 컴퓨터인 &lt;code class=&quot;highlighter-rouge&quot;&gt;게이트웨이&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;라우터&lt;/code&gt;를 통해 다른 네트워크에 연결된다. 게이트웨이는 라우팅 정보를 교환하여 적어도 국지적인 방식으로라도 무엇이 연결되어 있고 그래서 접근 가능한지 알게 된다.&lt;/p&gt;

  &lt;p&gt;각 네트워크는 가정, 사무실, 기숙사에 있는 컴퓨터와 전화 같은 많은 호스트 시스템을 연결할 수도 있다. 가정 내의 개별 컴퓨터는 라우터에 연결하기 위해 무선을 사용할 가능성이 있고, 라우터는 케이블이나 DSL로 인터넷 서비스 제공업체(Internet Service Provider), 즉 ISP에 연결된다. 반변 사무실에 있는 컴퓨터는 유선 이더넷 연결을 사용할 수도 있다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip-패킷&quot;&gt;IP 패킷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전 장에서 언급했듯이 정보는 패킷이라고 하는 덩어리로 네트워크를 통해 이동한다. 패킷은 지정된 형식의 바이트 시퀀스로, 다른 장치는 다른 패킷 형식을 사용한다. 패킷의 일부에는 패킷이 어디서 오고 어디로 향하는지를 알려주는 주소정보가 들어있다. 패킷의 나머지 부분에는 길이 같은 패킷 자체에 대한 정보가 들어있고, 마지막으로는 전달하는 정보인 &lt;code class=&quot;highlighter-rouge&quot;&gt;페이로드(payload)&lt;/code&gt;가 들어있다.&lt;/p&gt;

  &lt;p&gt;인터넷에서 데이터는 IP 패킷(IP packet, IP는 ‘인터넷 프로토콜’을 의미)으로 전달된다. IP 패킷은 모두 같은 형식으로 되어 있다. 특정 물리적 네트워크에서 IP 패킷은 하나 이상의 물리적 패킷으로 전송될 수 있다. 예를 들어, 가능한 한 가장 큰 이더넷 패킷(약 1500바이트)이 가능한 한 가장 큰 IP패킷(약 65000바이트)보다 훨씬 작기 때문에 큰 IP패킷은 여러개의 작은 이더넷 패킷으로 분할된다.&lt;/p&gt;

  &lt;p&gt;각 IP 패킷은 여러 개의 게이트웨이를 통과한다. 각 게이트웨이는 최종 수신지에 더 가까운 게이트웨이로 패킷을 보낸다. 패킷이 여기저기로 이동함에 따라, 여남은 개의 다른 회사나 기관이 소유하고 운영하며 다른 국가에 있을 확률이 꽤 높은 20개의 게이트웨이를 통과할 수도 있다. 트래픽은 최단 경로를 따를 필요가 없다. 편의성과 비용으로 인해 더 긴 경로를 통해 패킷을 라우팅할 가능성이 있다. 발신지와 수신지가 미국 이외 지역으로 되어 있는 많은 패킷이 미국을 통과하는 케이블을 사용하는데, 이 점을 이용하여 NSA가 전 세계의 트래픽을 기록한 것이다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip-주소의-할당&quot;&gt;IP 주소의 할당&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;중앙 기관은 연속적인 IP 주소 블록을 네트워크 관리자에게 할당하고, 네트워크 관리자는 네트워크상의 호스트 컴퓨터들에 개별 주소를 할당한다. 따라서 각 호스트 컴퓨터에는 자신이 있는 네트워크에 따라 로컬로 할당된 고유한 주소가 있다. 이 주소는 데스크톱 컴퓨터에서는 영구적일 수 있지만, 모바일 장치의 경우 동적이며 적어도 장치가 인터넷에 다시 연결될 때마다 바뀐다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip와-tcp&quot;&gt;IP와 TCP&lt;/h3&gt;

&lt;p&gt;IP는 Internet Protocol을 뜻한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;인터넷 프로토콜&lt;/strong&gt;(&lt;strong&gt;IP&lt;/strong&gt;, &lt;strong&gt;I&lt;/strong&gt;nternet &lt;strong&gt;P&lt;/strong&gt;rotocol, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4&quot;&gt;문화어&lt;/a&gt;: 호상망규약)은 송신 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%98%B8%EC%8A%A4%ED%8A%B8&quot;&gt;호스트&lt;/a&gt;와 수신 호스트가 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7_%EA%B5%90%ED%99%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC&quot;&gt;패킷 교환 네트워크&lt;/a&gt;(패킷 스위칭 네트워크, Packet Switching Network)에서 정보를 주고받는 데 사용하는 정보 위주의 규약(프로토콜, Protocol)이며, OSI 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당한다. 줄여서 &lt;strong&gt;아이피&lt;/strong&gt;(IP)라고도 한다.&lt;/p&gt;

  &lt;p&gt;IP의 정보는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7&quot;&gt;패킷&lt;/a&gt; 혹은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8&quot;&gt;데이터그램&lt;/a&gt;이라고 하는 덩어리로 나뉘어 전송된다. IP에서는 이전에 통신한 적 없는 호스트에 패킷을 보낼 때 경로 설정이 필요없다.&lt;/p&gt;

  &lt;p&gt;IP는 비신뢰성(unreliability)과 비연결성(connectionlessness)이 특징이다. 비신뢰성은 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다는 뜻이다. 예를 들어 전송과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패킷이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있다. 패킷 전송과 정확한 순서를 보장하려면 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;TCP&lt;/a&gt; 프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.&lt;/p&gt;

  &lt;p&gt;현재 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7&quot;&gt;인터넷&lt;/a&gt;에서 사용하는 표준 프로토콜은 인터넷 프로토콜의 4번째 판인 &lt;a href=&quot;https://ko.wikipedia.org/wiki/IPv4&quot;&gt;IPv4&lt;/a&gt;이다. 그러나 IPv4는 주소공간 고갈 문제를 겪고 있어 조만간 6번째 판인 &lt;a href=&quot;https://ko.wikipedia.org/wiki/IPv6&quot;&gt;IPv6&lt;/a&gt;가 대중화될 것으로 보인다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8&quot;&gt;마이크로소프트&lt;/a&gt; &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9C%88%EB%8F%84_7&quot;&gt;윈도 7&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/OS_X&quot;&gt;OS X&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4&quot;&gt;리눅스&lt;/a&gt; 등 현재 널리 쓰이고 있는 대부분의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C&quot;&gt;운영 체제&lt;/a&gt;는 IPv6 프로토콜을 지원한다.&lt;/p&gt;

  &lt;p&gt;(위키백과 발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;인터넷 프로토콜 스위트&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;인터넷 프로토콜 스위트&lt;/strong&gt;(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%81%EC%96%B4&quot;&gt;영어&lt;/a&gt;: Internet Protocol Suite)는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7&quot;&gt;인터넷&lt;/a&gt;에서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0&quot;&gt;컴퓨터&lt;/a&gt;들이 서로 정보를 주고받는 데 쓰이는 통신규약(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;프로토콜&lt;/a&gt;)의 모음이다. 인터넷 프로토콜 스위트 중 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;TCP&lt;/a&gt;와 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;IP&lt;/a&gt;가 가장 많이 쓰이기 때문에 &lt;strong&gt;TCP/IP 프로토콜&lt;/strong&gt; 스위트라고도 불린다.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8&quot;&gt;(위키백과 발췌)&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95&quot;&gt;OSI 모형 참조, 위키백과 발췌&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TCP&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;IP 위에 있는 TCP(Transmission Control Protocol: 전송 제어 프로토콜)라는 프로토콜은 IP를 사용하여 발신지에서 수신지까지 임의 길이의 바이트 시퀀스를 전송하는 안정적인 메커니즘을 제공한다. TCP 위에서는 고수준의 프로토콜들이 웹 브라우징, 메일, 파일 공유 등 우리가 ‘인터넷’ 이라고 생각하는 서비스를 제공하기 위해 TCP를 사용한다. 다른 프로토콜도 많이 있다. 예를 들어, 동적으로 IP 주소를 변경하는 것은 DHCP(동적 호스트 구성 프로토콜)라는 프로토콜에 의해 처리된다. 이 프로토콜들이 모두 합쳐져서 인터넷을 정의한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;전송 제어 프로토콜&lt;/strong&gt;(&lt;strong&gt;T&lt;/strong&gt;ransmission &lt;strong&gt;C&lt;/strong&gt;ontrol &lt;strong&gt;P&lt;/strong&gt;rotocol, &lt;strong&gt;TCP&lt;/strong&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4&quot;&gt;문화어&lt;/a&gt;: 전송조종규약)은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8&quot;&gt;인터넷 프로토콜 스위트&lt;/a&gt;(IP)의 핵심 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;프로토콜&lt;/a&gt; 중 하나로, IP와 함께 &lt;em&gt;TCP/IP&lt;/em&gt;라는 명칭으로도 널리 불린다. TCP는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B7%BC%EA%B1%B0%EB%A6%AC_%ED%86%B5%EC%8B%A0%EB%A7%9D&quot;&gt;근거리 통신망&lt;/a&gt;이나 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%8A%B8%EB%9D%BC%EB%84%B7&quot;&gt;인트라넷&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7&quot;&gt;인터넷&lt;/a&gt;에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%A5%ED%85%9F_(%EC%BB%B4%ED%93%A8%ED%8C%85)&quot;&gt;옥텟&lt;/a&gt;을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다. TCP는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EA%B3%84%EC%B8%B5&quot;&gt;전송 계층&lt;/a&gt;에 위치한다. 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜의 하나로서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B5%AD%EC%A0%9C_%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%91%9C%EC%A4%80%ED%99%94_%EA%B8%B0%EA%B5%AC&quot;&gt;국제 인터넷 표준화 기구&lt;/a&gt;(IETF)의 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=RFC_793&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;RFC 793&lt;/a&gt;에 기술되어 있다.&lt;/p&gt;

  &lt;p&gt;TCP는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80&quot;&gt;웹 브라우저&lt;/a&gt;들이 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9&quot;&gt;월드 와이드 웹&lt;/a&gt;에서 서버에 연결할 때 사용되며, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%A9%94%EC%9D%BC&quot;&gt;이메일&lt;/a&gt; 전송이나 파일 전송에도 사용된다.&lt;/p&gt;

  &lt;p&gt;TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=%EB%B9%84%EC%A0%91%EC%86%8D%ED%98%95_%ED%86%B5%EC%8B%A0&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;비접속형&lt;/a&gt; &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;사용자 데이터그램 프로토콜&lt;/a&gt;(User Datagram Protocol)을 사용한다. 이것은 전달 확인 및 순차 보장 기능이 없는 대신 오버헤드가 작고 지연시간이 짧다는 장점이 있다.&lt;/p&gt;

  &lt;p&gt;(위키백과 발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TCP/IP 프로토콜&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터넷에는 많은 프로토콜이 있으며 그중 두 가지는 정말 필수적이다. IP는 인터넷 프로토콜(Internet Protocol)이다. IP는 개별 패킷의 형식을 지정하고 패킷을 전송하는 방법을 정의한다. TCP, 즉 전송 제어 프로토콜(Transmission Control Protocol)은 IP 패킷을 데이터 스트림으로 결합하고 서비스에 연결하느 방법을 정의 한다. 이 둘을 합쳐서 TCP/IP라고 한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;IP 레벨 위에서는 TCP가 안정적인 통신을 제공하므로 사용자(실제로는 프로그래머)가 정보의 스트림에 불과한 패킷에 관해 생각할 필요가 없다. 우리가 ‘인터넷’이라고 생각하는 서비스의 대부분은 TCP를 사용한다.&lt;/p&gt;

  &lt;p&gt;이 프로토콜들 위에는 웹, 메일, 파일 전송 등의 서비스를 제공하는 애플리케이션 레벨 프로토콜들이 있고, 주로 TCP에 기반을 두고 구현된다. 따라서 여러 개의 프로토콜 계층이 있고, 각각은 아래에 있는 프로토콜 서비스에 의존하고 위에 있는 프로토콜에 서비스를 제공한다. 이것은 6장에서 설명한 소프트웨어의 계층화에 대한 매우 좋은 예다.&lt;/p&gt;

  &lt;p&gt;UDP, 즉 사용자 데이터그램 프로토콜(User Datagram Protocol)은 TCP와 같은 레벨의 또 다른 프로토콜이다. UDP는 TCP보다 훨씬 간단하고 양방향 스트림을 필요로 하지 않는 데이터 교환에 사용되며, 몇 가지 추가 기능을 갖출 효율적인 패킷을 전달만 가능하다. DNS가 UDP를 사용하고, 비디오 스트리밍, VoIP, 일부 온라인 게임도 UDP를 사용한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     [애플리케이션]
    [    TCP    ]
  [       IP       ]
[       물리 계층       ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;상위-레벨-프로토콜&quot;&gt;상위 레벨 프로토콜&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP는 두 대의 컴퓨터 간에 데이터를 주고받는 신뢰할 수 있는 양방향 스트림을 제공한다. 인터넷 서비스와 애플리케이션은 TCP를 전송 메커니즘으로 사용하지만, 필요한 기능에 특유한 자신만의 프로토콜을 가지고 있다. 예를 들어, HTTP, 즉 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)은 웹 브라우저와 서버에서 사용되는 특히 간단한 프로토콜이다. 링크를 클릭하면 브라우저가 서버(가령 amazon.com)의 포트 80에 TCP/IP연결을 열고 특정 페이지를 요청하는 짧은 메시지를 보낸다. 그림 9.6에서 브라우저는 왼쪽 상단의 클라이언트 애플리케이션이다. 메시지는 프로토콜 체인을 따라 내려가서 인터넷을 건너고(보통 후러씬 더 많은 단계를 거친다), 반대쪽 끝에서 상응하는 서버 애플리케이션까지 올라간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(클라이언트)                                                        (서버)
앱                                                                 앱
TCP             (게이트웨이)       (게이트웨이)  (게이트웨이)            TCP
IP                 IP                IP     ... IP                 IP
	-&amp;gt; 물리 계층 -&amp;gt;     -&amp;gt; 물리 계층 -&amp;gt;     -&amp;gt;         -&amp;gt; 물리 계층  -&amp;gt;
	  (예:전화)          (예:광섬유)                     (예:이더넷)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">커니핸 교수의 Hello Digital World 공부</summary></entry><entry><title type="html">Docker관련</title><link href="http://localhost:4000/records/2017-11-16-docker%EA%B4%80%EB%A0%A8/" rel="alternate" type="text/html" title="Docker관련" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/records/docker%EA%B4%80%EB%A0%A8</id><content type="html" xml:base="http://localhost:4000/records/2017-11-16-docker%EA%B4%80%EB%A0%A8/">&lt;h1 id=&quot;docker-세팅&quot;&gt;Docker 세팅&lt;/h1&gt;

&lt;p&gt;도커를 처음 설치하고 나서 다음 명령어로 우분투 이미지를 다운받고 해당 운영체제를 실행할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm it ubuntu:16:04 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜진 도커환경 안에서는 처음부터 root권한이 주어지기 때문에 sudo입력 없이도 여러가지 설치 명령을 실행시킬 수 있다.&lt;/p&gt;

&lt;p&gt;Dockerfile.base 이미지 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t base -f Dockerfile.base .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile.base를 기준으로 우리가 쓸 도커(container) 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t eb .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만든 이미지 확인 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker(Container) 실행시키는 명령어(예: eb)&lt;/p&gt;

&lt;p&gt;(마지막의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/zsh&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;옵션으로 프로그램을 실행시키기 위해 입력해주는 것, &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;터미널 형식으로 연다는 뜻, &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt;옵션은 컨테이너가 꺼졌을 때 삭제한다는 의미)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker를 외부랑 연결시키기 위해서 옵션을 추가한 멸영어&lt;/p&gt;

&lt;p&gt;(우리가 8012로 접근하면 docker는 80으로 받는다. 우리가 8013으로 접근하면 docker는  8000으로 받는다. 80번 포트와 8000포트를 둘다 테스트해보고 싶을 때 이런식으로 쓴다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it -p 8012:80 -p 8013:8000 eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜져있는 도커에 접속할 수 있는 명령어 (4317은 docker id)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와같은 명령어를 아래와 같이 접속도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행되고 있는 이미지 파일(container) 정보 확인하는 명령어&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">Docker 세팅</summary></entry><entry><title type="html">Ecs</title><link href="http://localhost:4000/records/2017-11-16-ECS/" rel="alternate" type="text/html" title="Ecs" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/records/ECS</id><content type="html" xml:base="http://localhost:4000/records/2017-11-16-ECS/">&lt;p&gt;도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기&lt;/p&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기</summary></entry><entry><title type="html">Postgresql</title><link href="http://localhost:4000/records/2017-10-15-postgresql/" rel="alternate" type="text/html" title="Postgresql" /><published>2017-10-15T00:00:00+09:00</published><updated>2017-10-15T00:00:00+09:00</updated><id>http://localhost:4000/records/postgresql</id><content type="html" xml:base="http://localhost:4000/records/2017-10-15-postgresql/">&lt;h1 id=&quot;명령어-기록-ubuntu-1604&quot;&gt;명령어 기록 (ubuntu-1604)&lt;/h1&gt;

&lt;h3 id=&quot;데이터베이스-생성&quot;&gt;데이터베이스 생성&lt;/h3&gt;
&lt;p&gt;커맨드창 에서 ‘zoozoo’라는 계정 이름으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;testname&lt;/code&gt;이라는 데이터베이스를 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;createdb testname --owner=zoozoo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE testname OWNER zoozoo;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 이름이 대문자인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;(쌍따옴표)로 데이터베이스 이름을 감싸서 명령을 실행시켜야 실행이 된다.&lt;/p&gt;

&lt;h3 id=&quot;기본생성된-사용자-이름으로-postgresql연결&quot;&gt;기본생성된 사용자 이름으로 postgresql연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 postgres 데이터베이스에 연결한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;postgres-사용자로-다른-데이터베이스-연결&quot;&gt;postgres 사용자로 다른 데이터베이스 연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 testdb 데이터베이스에 연결한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql testdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-삭제터미널-창에서&quot;&gt;데이터베이스 삭제(터미널 창에서)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres dropdb &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 삭제&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP DATABASE &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-목록확인-데이터베이스-명령어&quot;&gt;데이터베이스 목록확인 (데이터베이스 명령어)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\ㅣ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;특정-데이터베이스에-접속&quot;&gt;특정 데이터베이스에 접속&lt;/h3&gt;
&lt;p&gt;ex) database명 instagram&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;psql instagram
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;위의-특정-데이터베이스에-접속-후-관련-테이블-확인&quot;&gt;위의 특정 데이터베이스에 접속 후 관련 테이블 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dt\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;테이블의-전체-내용-확인&quot;&gt;테이블의 전체 내용 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from 테이블명
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용자-비밀번호-변경하기&quot;&gt;사용자 비밀번호 변경하기&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo -u postgres psql template1&lt;/code&gt; 명령을 통해 데이터베이스 접속&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ALTER USER postgres with encrypted password 'your_password';&lt;/code&gt; 명령을 통해 패스워드 변경 아래는 예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER USER James with encrypted password 'asldkhf';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl restart postgresql.service&lt;/code&gt;명령을 통해 postgresql 재시작&lt;/li&gt;
&lt;/ol&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">명령어 기록 (ubuntu-1604)</summary></entry><entry><title type="html">Dajngo_queryset_method</title><link href="http://localhost:4000/records/2017-10-14-dajngo_querySet_method/" rel="alternate" type="text/html" title="Dajngo_queryset_method" /><published>2017-10-14T00:00:00+09:00</published><updated>2017-10-14T00:00:00+09:00</updated><id>http://localhost:4000/records/dajngo_querySet_method</id><content type="html" xml:base="http://localhost:4000/records/2017-10-14-dajngo_querySet_method/">&lt;h1 id=&quot;queryset-api&quot;&gt;QuerySet API&lt;/h1&gt;

&lt;h2 id=&quot;methods-that-return-new-querysets&quot;&gt;Methods that return new QuerySets&lt;/h2&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개 변수와 일치하는 객체가 포함 된 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;복잡한 쿼리문을 사용해야 할 경우 Q objects를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;exclude&quot;&gt;exclude()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개변수와 일치하는 객체가 포함되지 않은 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;h3 id=&quot;annotate&quot;&gt;annotate()&lt;/h3&gt;

&lt;p&gt;제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다.제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다. 표현식은 단순 값, 모델의 필드에 대한 참조 (또는 모든 관련 모델), 또는 개체의 개체와 관련하여 계산 된 집계 식 (평균, 합계 등)이 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;annotate ()에 대한 각 인수는 반환되는 QuerySet의 각 객체에 추가되는 주석입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.annotate(Count('entry'))
# The name of the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].name
'Blogasaurus'
# The number of entries on the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].entry__count
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 블로그 모델은 entry__count 속성을 단독으로 정의하지 않지만 키워드 인수를 사용하여 집계 함수를 지정하면 주석의 이름을 제어 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;order_by&quot;&gt;order_by()&lt;/h3&gt;

&lt;p&gt;기본적으로 QuerySet에 의해 반환 된 결과는 Model’s Meta의 정렬 옵션에 의해 주어진 순서 튜플에 의해 정렬됩니다. order_by 메소드를 사용하여 QuerySet 단위로이 값을 겹쳐 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과는 pub_date가 내림차순으로 정렬 된 다음 headline이 오름차순으로 정렬됩니다. “-pub_date”앞에있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 기호는 내림차순을 나타냅니다. 기본적으로 오름차순으로 정렬됩니다.&lt;/p&gt;

&lt;p&gt;렌덤으로 정렬하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;를 사용합니다. (아래 예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('?')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델의 필드로 정렬하려면 모델 관계를 쿼리 할 때와 같은 구문을 사용하십시오. 즉, 필드 이름과 이중 밑줄 (__), 새 모델의 필드 이름 등이 포함되며, 원하는만큼의 모델을 추가 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델과 관계가있는 필드로 정렬하려고하면 Django는 관련 모델의 기본 순서를 사용하거나 Meta.ordering이 지정되지 않은 경우 관련 모델의 기본 키순으로 정렬합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 블로그 모델에는 기본 주문이 지정되어 있지 않으므로&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시는 아래의 예시와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__id')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 Blog 테이블에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ordering = ['name']&lt;/code&gt; 이 지정되어 있다면 위의 첫번째 쿼리는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reverse&quot;&gt;reverse()&lt;/h3&gt;

&lt;p&gt;reverse() 메서드를 사용하여 쿼리셋 결과물을 반대방향으로 정렬할 수 있습니다. reverse()를 한번더 호출하면 기존의 순서대로 다시 정렬할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 쿼리셋으로 끝에서 5번째까지의 항목을 불러올 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_queryset.reverse()[:5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django에서는 파이썬에서 사용할 수 잇는 [-1:] 과 같은 역 슬라이스를 사용하지 않습니다.   SQL에서 효율적으로 수행 할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한 reverse ()는 일반적으로 정의 된 순서가있는 QuerySet에서만 호출되어야합니다. 주어진 QuerySet에 대해 그러한 정렬이 정의되어 있지 않으면 reverse ()를 호출하면 아무런 효과가 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;distinct&quot;&gt;distinct()&lt;/h3&gt;

&lt;p&gt;SQL 쿼리에서 SELECT DISTINCT를 사용하는 새 QuerySet을 반환합니다. 이렇게하면 조회 결과에서 중복 행이 제거됩니다.&lt;/p&gt;

&lt;p&gt;기본적으로 QuerySet은 중복 행을 제거하지 않습니다. 실제로 Blog.objects.all ()과 같은 간단한 쿼리는 결과 행이 중복 될 가능성이 있기 때문에 거의 문제가되지 않습니다. 그러나 쿼리가 여러 테이블에 걸쳐있는 경우 QuerySet을 평가할 때 중복 결과를 얻을 수 있습니다. 이러한 상황에서 distinct ()를 사용하여 중복된 항목을 제거할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;values&quot;&gt;values()&lt;/h3&gt;

&lt;p&gt;iterable한 모델객체가 아닌 dictionary로 반환하는 쿼리셋입니다.&lt;/p&gt;

&lt;p&gt;반환된 dictionary는 모델 오브젝트의 속성이름을 키로, 가지고 데이터는 value로 가집니다.&lt;/p&gt;

&lt;p&gt;다음의 예시는 일반적인 쿼리셋과 values()쿼리셋의 차이를 보여줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This list contains a Blog object.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles')
&amp;lt;QuerySet [&amp;lt;Blog: Beatles Blog&amp;gt;]&amp;gt;

# This list contains a dictionary.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles').values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메소드는 모델이 가지고 있는 필드명을 인자로 가질 수 있습니다. 인자를 지정하지 않으면 모든 필드가 반환됩니다. (아래예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('id', 'name')
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메서드는 키워드인자로 annotate()를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values(lower_name=Lower('name'))
&amp;lt;QuerySet [{'lower_name': 'beatles blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;values_listfields-flatfalse&quot;&gt;values_list(*fields, flat=False)&lt;/h3&gt;

&lt;p&gt;values_list()는 dictionary를 반환하는 대신 튜플로 만들어진 리스트를 반환한다는 점을 제외하면 values ()와 유사합니다. 각 튜플에는 해당 필드의 값이나 values_list () 호출로 전달 된 표현식이 들어 있으므로 첫 번째 항목이 첫 번째 입력란이됩니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', 'headline')
&amp;lt;QuerySet [(1, 'First entry'), ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', Lower('headline'))
&amp;lt;QuerySet [(1, 'first entry'), ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 매게변수로 단일 필드 만 전달하면 flat 매개 변수를 전달할 수도 있습니다. flat=True이면 단일 튜플 아닌 단일 값으로 이루어진 리스트 반환합니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id').order_by('id')
&amp;lt;QuerySet[(1,), (2,), (3,), ...]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', flat=True).order_by('id')
&amp;lt;QuerySet [1, 2, 3, ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나 이상의 필드인자를 할당했는데 flat매게변수를 사용한다면 에러가 납니다.&lt;/p&gt;

&lt;p&gt;values_list ()에 값을 전달하지 않으면 모델의 모든 필드가 선언 된 순서대로 반환됩니다.&lt;/p&gt;

&lt;p&gt;values()와 values_list() 메서드는 모델 인스턴스를 생성하지 않고도 필드의 집합을 산출해 내는데에 최적화 되어 설계되었습니다. 관계가 형성되어있는 모델을 다룰 때에는 해당되지 않습니다. 한행에 하나의 객체가 할당되는 가정이 유지되지 않기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;datesfield-kind-orderasc&quot;&gt;dates(field, kind, order=’ASC’)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 모든 사용 가능한 날짜를 나타내는 datetime.date 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateField 여야 하며 종류는 “year”, “month” or “day”지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;datetimesfield_name--kind-orderasc-tzinfonone&quot;&gt;datetimes(field_name,  kind, order=’ASC’, tzinfo=None)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 사용 가능한 모든 날짜를 나타내는 datetime.datetime 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateTimeField 여야 하며 종류는 “year”, “month”,  “day”, “hour:, “minute”, “second”로지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;h3 id=&quot;none&quot;&gt;none()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;none ()을 호출하면 객체를 반환하지 않는 쿼리 세트가 만들어지며 결과에 액세스 할 때 쿼리가 실행되지 않습니다. qs.none () 쿼리 세트는 EmptyQuerySet의 인스턴스입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;all&quot;&gt;all()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;현재의 QuerySet (또는 QuerySet 서브 클래스)의 복사본을 반환합니다. 이는 모델 매니저 또는 QuerySet을 전달하고 결과에 대해 추가 필터링을 수행하려는 상황에서 유용 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unionother_qs-allfalse&quot;&gt;union(*other_qs, all=False)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 UNION 연산자를 사용하여 두 개 이상의 QuerySet 결과를 결합합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.union(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 all = True 인수를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;intersectionother_qs&quot;&gt;intersection(*other_qs)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 INTERSECT 연산자를 사용하여 두 개 이상의 QuerySets의 공통 요소를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.intersection(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select_relatedfields&quot;&gt;select_related(*fields)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;외래 키 관계가 형성되어 있는 QuerySet를 리턴 해, 조회를 실행할 때에 추가의 관련 오브젝트 데이터를 선택합니다. 이것은 하나의 복잡한 쿼리로 이어지는 성능 향상이지만 나중에 외래 키 관계를 사용하면 데이터베이스 쿼리가 필요하지 않음을 의미합니다. 다음 예제는 일반 조회와 select_related () 조회 간의 차이점을 보여줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 표준 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ex) select_related&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.select_related('blog').get(id=5)

# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한번에 관계가 이루어진 데이터베이스까지 조회해 와서 다음 쿼리시에 데이터베이스를 거치지 않고서도 원하는 정보를 산출해 낼 수 있다는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;select_related()쿼리는 다른 쿼리 객체와도 함께 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.utils import timezone

# Find all the blogs with entries scheduled to be published in the future.
blogs = set()

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;filter()와 select_related()의 체이닝 순서는 중요하지 않습니다. 어떤 것이 앞에 있더라도 결과는 동일합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select_related ()를 많은 관련 객체로 호출하거나 모든 관계를 모르는 경우가 있습니다. 이러한 경우에는 인수없이 select_related ()를 호출 할 수 있습니다. 이것은 발견 할 수있는 null이 아닌 모든 외래 키를 반환합니다. null 입력 가능 외래 키가 지정되어야합니다. 대부분의 경우에는 기본 쿼리를보다 복잡하게 만들고 실제로 필요한 것보다 많은 데이터를 반환하기 때문에 권장되지 않습니다.&lt;/p&gt;

&lt;p&gt;QuerySet에서 select_related의 이전 호출에 의해 추가 된 관련 필드 목록을 지우려면 매개 변수로 None을 전달할 수 있습니다.&lt;/p&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">QuerySet API</summary></entry><entry><title type="html">Django_model_fieldtype</title><link href="http://localhost:4000/records/2017-10-13-django_model_fieldtype-/" rel="alternate" type="text/html" title="Django_model_fieldtype" /><published>2017-10-13T00:00:00+09:00</published><updated>2017-10-13T00:00:00+09:00</updated><id>http://localhost:4000/records/django_model_fieldtype-</id><content type="html" xml:base="http://localhost:4000/records/2017-10-13-django_model_fieldtype-/">&lt;h1 id=&quot;model-field-reference&quot;&gt;Model field reference&lt;/h1&gt;

&lt;h2 id=&quot;field-types&quot;&gt;Field types&lt;/h2&gt;

&lt;h3 id=&quot;autofieldoptions&quot;&gt;AutoField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;추가하는 인스턴스마다 자동으로 사용가능한 ID값을 할당하는 IntegerField. 기본적으로 primary key field가 자동으로 추가해 주기 때문에 필요한 경우에 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigautofieldoptions&quot;&gt;BigAutoField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사용 할 수 있는 숫자가 1부터 9223372036854775807까지 보장되는 AutoField와 유사한 필드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigintegerfieldoptions&quot;&gt;BigIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;9223372036854775807까지의 숫자를 맞출 수 있다는 것을 제외하고는 IntegerField와 매우 흡사 한 64 비트 정수입니다.이 필드의 기본 양식 위젯은 TextInput입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binaryfieldoptions&quot;&gt;BinaryField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이진 데이터를 저장하는 필드입니다. 바이트 할당 만 지원합니다. 이 입력란에는 기능이 제한되어 있습니다. 예를 들어, BinaryField 값에 대한 쿼리 집합을 필터링 할 수 없습니다. 또한 BinaryField를 ModelForm에 포함시키는 것도 불가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;booleanfieldoptions&quot;&gt;BooleanField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ture/False 값을 가지는 필드입니다.&lt;/li&gt;
  &lt;li&gt;필드에 대한 기본 위젯은 CheckboxInput입니다.&lt;/li&gt;
  &lt;li&gt;null값을 받아야만 한다면 NullBooleanField를 대신 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;default값이 정의되어 있지 않으면 BooleanField의 기본값은 None입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;charfieldmax_lengthnone-options&quot;&gt;Charfield(max_length=None, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;string field로 길거나 짧은 문자열 보두 지원합니다.&lt;/li&gt;
  &lt;li&gt;대량의 텍스트를 사용해야 한다면 Textfield를 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯은 TextInput입니다.&lt;/li&gt;
  &lt;li&gt;CharField는 필수인자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;max_length&lt;/code&gt;를 반드시 입력해줘야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;DateField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;python에서 datetime.date 인스턴스로 표현되는 날짜입니다. 추가로 몇 가지 선택적 인수가 있습니다.&lt;/li&gt;
  &lt;li&gt;DateField.auto_now : 데이터가 save될 때 마다 현재시각을 자동으로 부여합니다.&lt;/li&gt;
  &lt;li&gt;DateField.auto_now_add : 데이터를 처음 만들 때 마다 자동으로 현재시각을 부여합니다.&lt;/li&gt;
  &lt;li&gt;기본적으로 현재시각을 부여하지만 기본값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;default=date.today&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;default=timezone.now&lt;/code&gt;와 같은 옵션을 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯은 TextInput입니다. admin페이지에는 기본적으로 Today를 설정할 수 있는 단축키가 만들어 집니다.&lt;/li&gt;
  &lt;li&gt;auto_now_add, auto_now 및 default 옵션은 상호 배타적입니다. 이러한 옵션을 함께 사용하면 오류가 발생합니다.&lt;/li&gt;
  &lt;li&gt;auto_now 또는 auto_now_add를 True로 설정하면 해당 필드는 editable = False 및 blank = True로 설정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datetimefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;DateTimeField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 datetime.datetime 인스턴스로 표현되는 날짜와 시간입니다.&lt;/li&gt;
  &lt;li&gt;DateField와 동일한 인수를 사용합니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯으로 한개의 TextInput을 가지며, admin페이지 JavaScript 바로 가기가있는 두 개의 별도 TextInput 위젯을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;decimalfieldmax_digitsnone-decimal_placesnone-options&quot;&gt;DecimalField(max_digits=None, decimal_places=None, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;고정 소수점 이하의 십진수로 파이썬에서 Decimal 인스턴스로 나타냅니다. 필수 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;max_digits(최대 자릿수)&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;decimal_places(소숫점)&lt;/code&gt;가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;durationfieldoptions&quot;&gt;Durationfield(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 기간을 담을 수 있는 필드입니다. (python의 timedelta)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;emailfieldmax_length254-options&quot;&gt;EmailField(max_length=254, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;email주소 유효성을 확인할 수 있는 CharField입니다. EmailCalidator를 이용하여 유효성을 검사합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;filefieldupolad_tonone-max_length100-options&quot;&gt;FileField(upolad_to=None, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;해당 필드에 primary_key는 사용할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;이 속성은 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며 두 가지 방법으로 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;upload_to : 이 속성은 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며 두 가지 방법으로 설정할 수 있습니다. 두 경우 모두 값은 Storage.save () 메서드에 전달됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyModel(models.Model):
    # file will be uploaded to MEDIA_ROOT/uploads
    upload = models.FileField(upload_to='uploads/')
    # or...
    # file will be saved to MEDIA_ROOT/uploads/2015/01/30
    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;기본 FileSystemStorage를 사용하는 경우 문자열 값이 MEDIA_ROOT 경로에 추가되어 업로드 된 파일이 저장 될 로컬 파일 시스템의 위치가 형성됩니다.&lt;/li&gt;
  &lt;li&gt;upload_to는 함수와 같이 호출 할 수 있습니다. 이것은 파일 이름을 포함하여 업로드 경로를 얻기 위해 호출됩니다. 호출 할 때에는 FileField가 선언된 model의 instance와 filename인자가 필요합니다.&lt;/li&gt;
  &lt;li&gt;storage  : 파일의 저장 및 검색을 처리하는 저장 할 수 있는 속성입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Filefield와 ImageField를 사용함에 있어서 몇가지 순서가 있습니다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;설정 파일에서 Django가 업로드 된 파일을 저장할 디렉토리의 전체 경로로 MEDIA_ROOT을 정의해야합니다. MEDIA_URL을 해당 디렉토리의 기본 공개 URL로 정의하십시오.&lt;/li&gt;
      &lt;li&gt;모델에 FileField 또는 ImageField를 추가하고 upload_to 옵션을 정의하여 업로드 된 파일이 저장될 MEDIA_ROOT의 하위 디렉토리를 지정합니다.&lt;/li&gt;
      &lt;li&gt;데이터베이스에 저장되는 것은 파일 경로입니다. 장고가 제공하는 url속성도 사용할 수 있습니다. 예를 들어 mug_shot 이라는 ImageField를 만들었다고 가정하면 ``과 같은 형식으로 파일의 경로를 가져올 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;업로드된 파일의 URL을 url속성을 사용하여 사용할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;#### FieldFile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;모델에서 FileField에 액세스하면 FieldFile 인스턴스가 기본 파일에 액세스하기위한 프록시로 제공됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* FieldFile.name - 연결된 FileField의 저장소 루트로부터의 상대 경로를 포함하는 파일의 이름입니다.
* FieldFile.size - 기본 Storage.size () 메서드의 결과입니다.
* FieldFile.url - 기본 Storage 클래스의 url () 메서드를 호출하여 파일의 상대 URL에 액세스하는 읽기 전용 속성입니다.
* FieldFile.open(mode='rb') - 지정된 모드에서이 인스턴스와 관련된 파일을 열거 나 다시 엽니 다. 표준 파이썬 open () 메소드와는 달리, 파일 디스크립터를 리턴하지 않습니다.
* FieldFile.close -  표준 파이썬 file.close () 메소드와 유사하게 동작하고이 인스턴스와 관련된 파일을 닫습니다.
* FieldFile.save(name, content, save=True) - 이 메서드는 파일 이름과 파일 내용을 가져 와서 필드의 저장소 클래스에 전달한 다음 저장된 파일을 모델 필드와 연결합니다. 모델의 FileField 인스턴스에 파일 데이터를 수동으로 연결하려면 save () 메서드를 사용하여 해당 파일 데이터를 유지합니다.
* FieldFile.delete(save=True) - 이 인스턴스와 관련된 파일을 삭제하고 필드의 모든 특성을 지 웁니다. 이 메소드는 delete ()가 호출 될 때 열려있을 경우 파일을 닫습니다.모델을 삭제하면 관련 파일이 삭제되지 않습니다. 고아 파일을 정리해야하는 경우 직접 처리해야합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;filepathfieldpathnone-matchnone-recursivefalse-max_length100-options&quot;&gt;FilePathField(path=None, match=None, recursive=False, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CharField는 파일 시스템의 특정 디렉토리에있는 제한된 파일 이름을 선택합니다. 3개의 인자를 받으며 그중 첫번째는 필수인자 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* FilePathField.path - 필수인자로 해당 필드가 선택해야하는 파일의 절대경로를 입력해줍니다.
* FilePathField.match - 정규표현식을 통해 해당 필드가 파일네임을 필터링 할 수 있게 합니다.
* FilePathField.recursive - path의 모든 하위 디렉토리가 포함되어야하는지 여부를 지정합니다.
* FilePathField.allow_files - 지정된 위치의 파일을 포함할지 여부를 지정합니다.
* FilePathField.allow_folders - 지정된 위치의 폴더를 포함할지 여부를 지정합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;floatfieldoptions&quot;&gt;FloatField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;float 인스턴스로 파이썬에서 표현 된 부동 소수점 숫자입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;imagefieldupload_tonone-height_fieldnone-width_fieldnone-max_length100-options&quot;&gt;ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FileField의 모든 특성 및 메서드를 상속하지만 업로드 된 개체가 유효한 이미지인지 확인합니다.&lt;/li&gt;
  &lt;li&gt;FileField에서 사용할 수있는 특수 특성 외에도 ImageField에는 height 및 width 특성이 있습니다. 이러한 속성에 대한 쿼리를 용이하게하기 위해 ImageField에는 두 개의 추가 선택적 인수가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* ImageField.height_field - 모델 인스턴스가 저장 될 때마다 자동으로 지정된 높이를 갖게하는모델 필드의 이름입니다.
* ImageField.width_field - 모델 인스턴스가 저장 될 때마다 자동으로 지정된 너비를 갖게하는모델 필드의 이름입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Imagefield를 사용하기 위해서는 Pillow 라이브러리를 설치해야만 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;integerfieldoptions&quot;&gt;IntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;정수를 받을 수 있는 필드입니다. 정수. -2147483648에서 2147483647까지의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다. 이 필드의 기본 양식 위젯은 localize가 False 일 때 NumberInput이고 그렇지 않으면 TextInput입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;genericipaddressfieldprotocolboth-unpack_ipv4false-options&quot;&gt;GenericIPAddressField(protocol=’both’, unpack_ipv4=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 형식의 IPv4 또는 IPv6 주소를 받을 수 있는 필드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nullbooleanfieldoptions&quot;&gt;NullBooleanField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;BooleanField와 비슷하지만 NULL을 옵션 중 하나로 허용합니다. BooleanField 대신 null = True를 사용할 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;positiveintegerfieldoptions&quot;&gt;PositiveIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IntegerField와 같으나 양수 또는 0이어야합니다. 0에서 2147483647 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다. 이전 버전과의 호환성을 위해 0 값이 허용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;positivesmallintegerfieldoptions&quot;&gt;PositiveSmallIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PositiveIntegerField와 같지만 특정 (데이터베이스에 따라 다릅니다.) 지점에서만 값을 허용합니다. 0에서 32767 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;slugfieldmax_length50-options&quot;&gt;SlugField(max_length=50, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Slug는 신문 용어입니다. Slug는 글자, 숫자, 밑줄 또는 하이픈 만 포함하는 짧은 레이블입니다. 일반적으로 URL에 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;smallintegerfieldoptions&quot;&gt;SmallIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IntegerField와 같지만 특정 (데이터베이스에 따라) 지점에서만 값을 허용합니다. -32768에서 32767 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;textfieldoptions&quot;&gt;TextField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;큰 텍스트 필드. 이 필드의 기본 양식 위젯은 Textarea입니다. max_length 속성을 지정하면 자동 생성 양식 필드의 Textarea 위젯에 반영됩니다. 그러나 모델 또는 데이터베이스 수준에서는 적용되지 않습니다. CharField를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;timefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;TimeField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 datetime.time 인스턴스로 표현되는 시간입니다. DateField와 동일한 자동 채우기 옵션을 적용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;urlfieldmax_length200-options&quot;&gt;URLField(max_length=200, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;url을 위한 CharField입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uuidfieldoptions&quot;&gt;UUIDField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;보편적으로 유일한 식별자를 저장하기위한 필드입니다. 파이썬의 UUID 클래스를 사용합니다. PostgreSQL에서 사용될 때 이것은 uuid 데이터 유형에 저장되고, 그렇지 않으면 char (32)에 저장됩니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">Model field reference</summary></entry><entry><title type="html">Django_document</title><link href="http://localhost:4000/records/2017-10-10-django_document/" rel="alternate" type="text/html" title="Django_document" /><published>2017-10-10T00:00:00+09:00</published><updated>2017-10-10T00:00:00+09:00</updated><id>http://localhost:4000/records/django_document</id><content type="html" xml:base="http://localhost:4000/records/2017-10-10-django_document/">&lt;h4 id=&quot;field-option-중-choices&quot;&gt;Field option 중 choices&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;choices 에서 앞쪽이 데이터베이스 에서 인식하는 벨류값, 뒤쪽이 클라이언트 화면에서 보이는 값&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;example)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;null값과-blank&quot;&gt;null값과 blank&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;값은 데이터베이스에 어떠한 데이터도 갖고 있지 않다는 것을 말한다. (datetime 이나 integerfield에는 비어있는 시간이나 숫자라는 개념이 없기 때문에 빈값을 적용시키기 위헤서는 null=True옵션을 줘야한다.)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;blnak&lt;/code&gt;값은 ‘비어있는 값’을 말하며 blank=True를 적용 했을 때에 데이터베이스에 ‘비어있는 값’을 저장하게 된다.(charfield, textfield에는 비어있는 값을 인식시키기 위헤서 blnak=True 옵션을 준다.) blank의 또다른 기능 중 하나는 admin에서 필수 입력요소 인지를 판단할 수 있게 해준다.&lt;/p&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">Field option 중 choices</summary></entry><entry><title type="html">Test!</title><link href="http://localhost:4000/records/2017-10-09-welcome-to-jekyll/" rel="alternate" type="text/html" title="Test!" /><published>2017-10-09T22:48:43+09:00</published><updated>2017-10-09T22:48:43+09:00</updated><id>http://localhost:4000/records/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/records/2017-10-09-welcome-to-jekyll/">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>