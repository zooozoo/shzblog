<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-01-11T15:23:54+09:00</updated><id>http://localhost:4000/</id><title type="html">Record, Organize, Make it mine</title><subtitle>My programming study blog and I hope it help someone who struggling with code</subtitle><author><name>-Yoda</name></author><entry><title type="html">Docker관련</title><link href="http://localhost:4000/docker%EA%B4%80%EB%A0%A8/" rel="alternate" type="text/html" title="Docker관련" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/docker%EA%B4%80%EB%A0%A8</id><content type="html" xml:base="http://localhost:4000/docker%EA%B4%80%EB%A0%A8/">&lt;h1 id=&quot;docker-세팅&quot;&gt;Docker 세팅&lt;/h1&gt;

&lt;p&gt;도커를 처음 설치하고 나서 다음 명령어로 우분투 이미지를 다운받고 해당 운영체제를 실행할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm it ubuntu:16:04 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜진 도커환경 안에서는 처음부터 root권한이 주어지기 때문에 sudo입력 없이도 여러가지 설치 명령을 실행시킬 수 있다.&lt;/p&gt;

&lt;p&gt;Dockerfile.base 이미지 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t base -f Dockerfile.base .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile.base를 기준으로 우리가 쓸 도커(container) 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t eb .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만든 이미지 확인 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker(Container) 실행시키는 명령어(예: eb)&lt;/p&gt;

&lt;p&gt;(마지막의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/zsh&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;옵션으로 프로그램을 실행시키기 위해 입력해주는 것, &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;터미널 형식으로 연다는 뜻, &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt;옵션은 컨테이너가 꺼졌을 때 삭제한다는 의미)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker를 외부랑 연결시키기 위해서 옵션을 추가한 멸영어&lt;/p&gt;

&lt;p&gt;(우리가 8012로 접근하면 docker는 80으로 받는다. 우리가 8013으로 접근하면 docker는  8000으로 받는다. 80번 포트와 8000포트를 둘다 테스트해보고 싶을 때 이런식으로 쓴다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it -p 8012:80 -p 8013:8000 eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜져있는 도커에 접속할 수 있는 명령어 (4317은 docker id)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와같은 명령어를 아래와 같이 접속도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행되고 있는 이미지 파일(container) 정보 확인하는 명령어&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><summary type="html">Docker 세팅</summary></entry><entry><title type="html">Ecs</title><link href="http://localhost:4000/ECS/" rel="alternate" type="text/html" title="Ecs" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/ECS</id><content type="html" xml:base="http://localhost:4000/ECS/">&lt;p&gt;도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기&lt;/p&gt;</content><author><name>-Yoda</name></author><summary type="html">도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기</summary></entry><entry><title type="html">Postgresql</title><link href="http://localhost:4000/postgresql/" rel="alternate" type="text/html" title="Postgresql" /><published>2017-10-15T00:00:00+09:00</published><updated>2017-10-15T00:00:00+09:00</updated><id>http://localhost:4000/postgresql</id><content type="html" xml:base="http://localhost:4000/postgresql/">&lt;h1 id=&quot;명령어-기록-ubuntu-1604&quot;&gt;명령어 기록 (ubuntu-1604)&lt;/h1&gt;

&lt;h3 id=&quot;데이터베이스-생성&quot;&gt;데이터베이스 생성&lt;/h3&gt;
&lt;p&gt;커맨드창 에서 ‘zoozoo’라는 계정 이름으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;testname&lt;/code&gt;이라는 데이터베이스를 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;createdb testname --owner=zoozoo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE testname OWNER zoozoo;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 이름이 대문자인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;(쌍따옴표)로 데이터베이스 이름을 감싸서 명령을 실행시켜야 실행이 된다.&lt;/p&gt;

&lt;h3 id=&quot;기본생성된-사용자-이름으로-postgresql연결&quot;&gt;기본생성된 사용자 이름으로 postgresql연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 postgres 데이터베이스에 연결한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;postgres-사용자로-다른-데이터베이스-연결&quot;&gt;postgres 사용자로 다른 데이터베이스 연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 testdb 데이터베이스에 연결한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql testdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-삭제터미널-창에서&quot;&gt;데이터베이스 삭제(터미널 창에서)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres dropdb &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 삭제&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP DATABASE &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-목록확인-데이터베이스-명령어&quot;&gt;데이터베이스 목록확인 (데이터베이스 명령어)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\ㅣ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;특정-데이터베이스에-접속&quot;&gt;특정 데이터베이스에 접속&lt;/h3&gt;
&lt;p&gt;ex) database명 instagram&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;psql instagram
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;위의-특정-데이터베이스에-접속-후-관련-테이블-확인&quot;&gt;위의 특정 데이터베이스에 접속 후 관련 테이블 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dt\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;테이블의-전체-내용-확인&quot;&gt;테이블의 전체 내용 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from 테이블명
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용자-비밀번호-변경하기&quot;&gt;사용자 비밀번호 변경하기&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo -u postgres psql template1&lt;/code&gt; 명령을 통해 데이터베이스 접속&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ALTER USER postgres with encrypted password 'your_password';&lt;/code&gt; 명령을 통해 패스워드 변경 아래는 예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER USER James with encrypted password 'asldkhf';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl restart postgresql.service&lt;/code&gt;명령을 통해 postgresql 재시작&lt;/li&gt;
&lt;/ol&gt;</content><author><name>-Yoda</name></author><summary type="html">명령어 기록 (ubuntu-1604)</summary></entry><entry><title type="html">Dajngo_queryset_method</title><link href="http://localhost:4000/dajngo_querySet_method/" rel="alternate" type="text/html" title="Dajngo_queryset_method" /><published>2017-10-14T00:00:00+09:00</published><updated>2017-10-14T00:00:00+09:00</updated><id>http://localhost:4000/dajngo_querySet_method</id><content type="html" xml:base="http://localhost:4000/dajngo_querySet_method/">&lt;h1 id=&quot;queryset-api&quot;&gt;QuerySet API&lt;/h1&gt;

&lt;h2 id=&quot;methods-that-return-new-querysets&quot;&gt;Methods that return new QuerySets&lt;/h2&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개 변수와 일치하는 객체가 포함 된 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;복잡한 쿼리문을 사용해야 할 경우 Q objects를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;exclude&quot;&gt;exclude()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개변수와 일치하는 객체가 포함되지 않은 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;h3 id=&quot;annotate&quot;&gt;annotate()&lt;/h3&gt;

&lt;p&gt;제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다.제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다. 표현식은 단순 값, 모델의 필드에 대한 참조 (또는 모든 관련 모델), 또는 개체의 개체와 관련하여 계산 된 집계 식 (평균, 합계 등)이 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;annotate ()에 대한 각 인수는 반환되는 QuerySet의 각 객체에 추가되는 주석입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.annotate(Count('entry'))
# The name of the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].name
'Blogasaurus'
# The number of entries on the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].entry__count
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 블로그 모델은 entry__count 속성을 단독으로 정의하지 않지만 키워드 인수를 사용하여 집계 함수를 지정하면 주석의 이름을 제어 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;order_by&quot;&gt;order_by()&lt;/h3&gt;

&lt;p&gt;기본적으로 QuerySet에 의해 반환 된 결과는 Model’s Meta의 정렬 옵션에 의해 주어진 순서 튜플에 의해 정렬됩니다. order_by 메소드를 사용하여 QuerySet 단위로이 값을 겹쳐 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과는 pub_date가 내림차순으로 정렬 된 다음 headline이 오름차순으로 정렬됩니다. “-pub_date”앞에있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 기호는 내림차순을 나타냅니다. 기본적으로 오름차순으로 정렬됩니다.&lt;/p&gt;

&lt;p&gt;렌덤으로 정렬하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;를 사용합니다. (아래 예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('?')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델의 필드로 정렬하려면 모델 관계를 쿼리 할 때와 같은 구문을 사용하십시오. 즉, 필드 이름과 이중 밑줄 (__), 새 모델의 필드 이름 등이 포함되며, 원하는만큼의 모델을 추가 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델과 관계가있는 필드로 정렬하려고하면 Django는 관련 모델의 기본 순서를 사용하거나 Meta.ordering이 지정되지 않은 경우 관련 모델의 기본 키순으로 정렬합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 블로그 모델에는 기본 주문이 지정되어 있지 않으므로&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시는 아래의 예시와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__id')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 Blog 테이블에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ordering = ['name']&lt;/code&gt; 이 지정되어 있다면 위의 첫번째 쿼리는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reverse&quot;&gt;reverse()&lt;/h3&gt;

&lt;p&gt;reverse() 메서드를 사용하여 쿼리셋 결과물을 반대방향으로 정렬할 수 있습니다. reverse()를 한번더 호출하면 기존의 순서대로 다시 정렬할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 쿼리셋으로 끝에서 5번째까지의 항목을 불러올 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_queryset.reverse()[:5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django에서는 파이썬에서 사용할 수 잇는 [-1:] 과 같은 역 슬라이스를 사용하지 않습니다.   SQL에서 효율적으로 수행 할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한 reverse ()는 일반적으로 정의 된 순서가있는 QuerySet에서만 호출되어야합니다. 주어진 QuerySet에 대해 그러한 정렬이 정의되어 있지 않으면 reverse ()를 호출하면 아무런 효과가 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;distinct&quot;&gt;distinct()&lt;/h3&gt;

&lt;p&gt;SQL 쿼리에서 SELECT DISTINCT를 사용하는 새 QuerySet을 반환합니다. 이렇게하면 조회 결과에서 중복 행이 제거됩니다.&lt;/p&gt;

&lt;p&gt;기본적으로 QuerySet은 중복 행을 제거하지 않습니다. 실제로 Blog.objects.all ()과 같은 간단한 쿼리는 결과 행이 중복 될 가능성이 있기 때문에 거의 문제가되지 않습니다. 그러나 쿼리가 여러 테이블에 걸쳐있는 경우 QuerySet을 평가할 때 중복 결과를 얻을 수 있습니다. 이러한 상황에서 distinct ()를 사용하여 중복된 항목을 제거할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;values&quot;&gt;values()&lt;/h3&gt;

&lt;p&gt;iterable한 모델객체가 아닌 dictionary로 반환하는 쿼리셋입니다.&lt;/p&gt;

&lt;p&gt;반환된 dictionary는 모델 오브젝트의 속성이름을 키로, 가지고 데이터는 value로 가집니다.&lt;/p&gt;

&lt;p&gt;다음의 예시는 일반적인 쿼리셋과 values()쿼리셋의 차이를 보여줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This list contains a Blog object.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles')
&amp;lt;QuerySet [&amp;lt;Blog: Beatles Blog&amp;gt;]&amp;gt;

# This list contains a dictionary.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles').values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메소드는 모델이 가지고 있는 필드명을 인자로 가질 수 있습니다. 인자를 지정하지 않으면 모든 필드가 반환됩니다. (아래예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('id', 'name')
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메서드는 키워드인자로 annotate()를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values(lower_name=Lower('name'))
&amp;lt;QuerySet [{'lower_name': 'beatles blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;values_listfields-flatfalse&quot;&gt;values_list(*fields, flat=False)&lt;/h3&gt;

&lt;p&gt;values_list()는 dictionary를 반환하는 대신 튜플로 만들어진 리스트를 반환한다는 점을 제외하면 values ()와 유사합니다. 각 튜플에는 해당 필드의 값이나 values_list () 호출로 전달 된 표현식이 들어 있으므로 첫 번째 항목이 첫 번째 입력란이됩니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', 'headline')
&amp;lt;QuerySet [(1, 'First entry'), ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', Lower('headline'))
&amp;lt;QuerySet [(1, 'first entry'), ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 매게변수로 단일 필드 만 전달하면 flat 매개 변수를 전달할 수도 있습니다. flat=True이면 단일 튜플 아닌 단일 값으로 이루어진 리스트 반환합니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id').order_by('id')
&amp;lt;QuerySet[(1,), (2,), (3,), ...]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', flat=True).order_by('id')
&amp;lt;QuerySet [1, 2, 3, ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나 이상의 필드인자를 할당했는데 flat매게변수를 사용한다면 에러가 납니다.&lt;/p&gt;

&lt;p&gt;values_list ()에 값을 전달하지 않으면 모델의 모든 필드가 선언 된 순서대로 반환됩니다.&lt;/p&gt;

&lt;p&gt;values()와 values_list() 메서드는 모델 인스턴스를 생성하지 않고도 필드의 집합을 산출해 내는데에 최적화 되어 설계되었습니다. 관계가 형성되어있는 모델을 다룰 때에는 해당되지 않습니다. 한행에 하나의 객체가 할당되는 가정이 유지되지 않기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;datesfield-kind-orderasc&quot;&gt;dates(field, kind, order=’ASC’)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 모든 사용 가능한 날짜를 나타내는 datetime.date 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateField 여야 하며 종류는 “year”, “month” or “day”지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;datetimesfield_name--kind-orderasc-tzinfonone&quot;&gt;datetimes(field_name,  kind, order=’ASC’, tzinfo=None)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 사용 가능한 모든 날짜를 나타내는 datetime.datetime 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateTimeField 여야 하며 종류는 “year”, “month”,  “day”, “hour:, “minute”, “second”로지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;h3 id=&quot;none&quot;&gt;none()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;none ()을 호출하면 객체를 반환하지 않는 쿼리 세트가 만들어지며 결과에 액세스 할 때 쿼리가 실행되지 않습니다. qs.none () 쿼리 세트는 EmptyQuerySet의 인스턴스입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;all&quot;&gt;all()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;현재의 QuerySet (또는 QuerySet 서브 클래스)의 복사본을 반환합니다. 이는 모델 매니저 또는 QuerySet을 전달하고 결과에 대해 추가 필터링을 수행하려는 상황에서 유용 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unionother_qs-allfalse&quot;&gt;union(*other_qs, all=False)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 UNION 연산자를 사용하여 두 개 이상의 QuerySet 결과를 결합합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.union(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 all = True 인수를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;intersectionother_qs&quot;&gt;intersection(*other_qs)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 INTERSECT 연산자를 사용하여 두 개 이상의 QuerySets의 공통 요소를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.intersection(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select_relatedfields&quot;&gt;select_related(*fields)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;외래 키 관계가 형성되어 있는 QuerySet를 리턴 해, 조회를 실행할 때에 추가의 관련 오브젝트 데이터를 선택합니다. 이것은 하나의 복잡한 쿼리로 이어지는 성능 향상이지만 나중에 외래 키 관계를 사용하면 데이터베이스 쿼리가 필요하지 않음을 의미합니다. 다음 예제는 일반 조회와 select_related () 조회 간의 차이점을 보여줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 표준 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ex) select_related&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.select_related('blog').get(id=5)

# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한번에 관계가 이루어진 데이터베이스까지 조회해 와서 다음 쿼리시에 데이터베이스를 거치지 않고서도 원하는 정보를 산출해 낼 수 있다는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;select_related()쿼리는 다른 쿼리 객체와도 함께 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.utils import timezone

# Find all the blogs with entries scheduled to be published in the future.
blogs = set()

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;filter()와 select_related()의 체이닝 순서는 중요하지 않습니다. 어떤 것이 앞에 있더라도 결과는 동일합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select_related ()를 많은 관련 객체로 호출하거나 모든 관계를 모르는 경우가 있습니다. 이러한 경우에는 인수없이 select_related ()를 호출 할 수 있습니다. 이것은 발견 할 수있는 null이 아닌 모든 외래 키를 반환합니다. null 입력 가능 외래 키가 지정되어야합니다. 대부분의 경우에는 기본 쿼리를보다 복잡하게 만들고 실제로 필요한 것보다 많은 데이터를 반환하기 때문에 권장되지 않습니다.&lt;/p&gt;

&lt;p&gt;QuerySet에서 select_related의 이전 호출에 의해 추가 된 관련 필드 목록을 지우려면 매개 변수로 None을 전달할 수 있습니다.&lt;/p&gt;</content><author><name>-Yoda</name></author><summary type="html">QuerySet API</summary></entry><entry><title type="html">Django_model_fieldtype</title><link href="http://localhost:4000/django_model_fieldtype/" rel="alternate" type="text/html" title="Django_model_fieldtype" /><published>2017-10-13T00:00:00+09:00</published><updated>2017-10-13T00:00:00+09:00</updated><id>http://localhost:4000/django_model_fieldtype-</id><content type="html" xml:base="http://localhost:4000/django_model_fieldtype/">&lt;h1 id=&quot;model-field-reference&quot;&gt;Model field reference&lt;/h1&gt;

&lt;h2 id=&quot;field-types&quot;&gt;Field types&lt;/h2&gt;

&lt;h3 id=&quot;autofieldoptions&quot;&gt;AutoField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;추가하는 인스턴스마다 자동으로 사용가능한 ID값을 할당하는 IntegerField. 기본적으로 primary key field가 자동으로 추가해 주기 때문에 필요한 경우에 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigautofieldoptions&quot;&gt;BigAutoField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사용 할 수 있는 숫자가 1부터 9223372036854775807까지 보장되는 AutoField와 유사한 필드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigintegerfieldoptions&quot;&gt;BigIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;9223372036854775807까지의 숫자를 맞출 수 있다는 것을 제외하고는 IntegerField와 매우 흡사 한 64 비트 정수입니다.이 필드의 기본 양식 위젯은 TextInput입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binaryfieldoptions&quot;&gt;BinaryField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이진 데이터를 저장하는 필드입니다. 바이트 할당 만 지원합니다. 이 입력란에는 기능이 제한되어 있습니다. 예를 들어, BinaryField 값에 대한 쿼리 집합을 필터링 할 수 없습니다. 또한 BinaryField를 ModelForm에 포함시키는 것도 불가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;booleanfieldoptions&quot;&gt;BooleanField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ture/False 값을 가지는 필드입니다.&lt;/li&gt;
  &lt;li&gt;필드에 대한 기본 위젯은 CheckboxInput입니다.&lt;/li&gt;
  &lt;li&gt;null값을 받아야만 한다면 NullBooleanField를 대신 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;default값이 정의되어 있지 않으면 BooleanField의 기본값은 None입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;charfieldmax_lengthnone-options&quot;&gt;Charfield(max_length=None, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;string field로 길거나 짧은 문자열 보두 지원합니다.&lt;/li&gt;
  &lt;li&gt;대량의 텍스트를 사용해야 한다면 Textfield를 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯은 TextInput입니다.&lt;/li&gt;
  &lt;li&gt;CharField는 필수인자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;max_length&lt;/code&gt;를 반드시 입력해줘야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;DateField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;python에서 datetime.date 인스턴스로 표현되는 날짜입니다. 추가로 몇 가지 선택적 인수가 있습니다.&lt;/li&gt;
  &lt;li&gt;DateField.auto_now : 데이터가 save될 때 마다 현재시각을 자동으로 부여합니다.&lt;/li&gt;
  &lt;li&gt;DateField.auto_now_add : 데이터를 처음 만들 때 마다 자동으로 현재시각을 부여합니다.&lt;/li&gt;
  &lt;li&gt;기본적으로 현재시각을 부여하지만 기본값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;default=date.today&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;default=timezone.now&lt;/code&gt;와 같은 옵션을 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯은 TextInput입니다. admin페이지에는 기본적으로 Today를 설정할 수 있는 단축키가 만들어 집니다.&lt;/li&gt;
  &lt;li&gt;auto_now_add, auto_now 및 default 옵션은 상호 배타적입니다. 이러한 옵션을 함께 사용하면 오류가 발생합니다.&lt;/li&gt;
  &lt;li&gt;auto_now 또는 auto_now_add를 True로 설정하면 해당 필드는 editable = False 및 blank = True로 설정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datetimefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;DateTimeField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 datetime.datetime 인스턴스로 표현되는 날짜와 시간입니다.&lt;/li&gt;
  &lt;li&gt;DateField와 동일한 인수를 사용합니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯으로 한개의 TextInput을 가지며, admin페이지 JavaScript 바로 가기가있는 두 개의 별도 TextInput 위젯을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;decimalfieldmax_digitsnone-decimal_placesnone-options&quot;&gt;DecimalField(max_digits=None, decimal_places=None, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;고정 소수점 이하의 십진수로 파이썬에서 Decimal 인스턴스로 나타냅니다. 필수 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;max_digits(최대 자릿수)&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;decimal_places(소숫점)&lt;/code&gt;가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;durationfieldoptions&quot;&gt;Durationfield(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 기간을 담을 수 있는 필드입니다. (python의 timedelta)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;emailfieldmax_length254-options&quot;&gt;EmailField(max_length=254, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;email주소 유효성을 확인할 수 있는 CharField입니다. EmailCalidator를 이용하여 유효성을 검사합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;filefieldupolad_tonone-max_length100-options&quot;&gt;FileField(upolad_to=None, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;해당 필드에 primary_key는 사용할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;이 속성은 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며 두 가지 방법으로 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;upload_to : 이 속성은 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며 두 가지 방법으로 설정할 수 있습니다. 두 경우 모두 값은 Storage.save () 메서드에 전달됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyModel(models.Model):
    # file will be uploaded to MEDIA_ROOT/uploads
    upload = models.FileField(upload_to='uploads/')
    # or...
    # file will be saved to MEDIA_ROOT/uploads/2015/01/30
    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;기본 FileSystemStorage를 사용하는 경우 문자열 값이 MEDIA_ROOT 경로에 추가되어 업로드 된 파일이 저장 될 로컬 파일 시스템의 위치가 형성됩니다.&lt;/li&gt;
  &lt;li&gt;upload_to는 함수와 같이 호출 할 수 있습니다. 이것은 파일 이름을 포함하여 업로드 경로를 얻기 위해 호출됩니다. 호출 할 때에는 FileField가 선언된 model의 instance와 filename인자가 필요합니다.&lt;/li&gt;
  &lt;li&gt;storage  : 파일의 저장 및 검색을 처리하는 저장 할 수 있는 속성입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Filefield와 ImageField를 사용함에 있어서 몇가지 순서가 있습니다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;설정 파일에서 Django가 업로드 된 파일을 저장할 디렉토리의 전체 경로로 MEDIA_ROOT을 정의해야합니다. MEDIA_URL을 해당 디렉토리의 기본 공개 URL로 정의하십시오.&lt;/li&gt;
      &lt;li&gt;모델에 FileField 또는 ImageField를 추가하고 upload_to 옵션을 정의하여 업로드 된 파일이 저장될 MEDIA_ROOT의 하위 디렉토리를 지정합니다.&lt;/li&gt;
      &lt;li&gt;데이터베이스에 저장되는 것은 파일 경로입니다. 장고가 제공하는 url속성도 사용할 수 있습니다. 예를 들어 mug_shot 이라는 ImageField를 만들었다고 가정하면 ``과 같은 형식으로 파일의 경로를 가져올 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;업로드된 파일의 URL을 url속성을 사용하여 사용할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;#### FieldFile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;모델에서 FileField에 액세스하면 FieldFile 인스턴스가 기본 파일에 액세스하기위한 프록시로 제공됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* FieldFile.name - 연결된 FileField의 저장소 루트로부터의 상대 경로를 포함하는 파일의 이름입니다.
* FieldFile.size - 기본 Storage.size () 메서드의 결과입니다.
* FieldFile.url - 기본 Storage 클래스의 url () 메서드를 호출하여 파일의 상대 URL에 액세스하는 읽기 전용 속성입니다.
* FieldFile.open(mode='rb') - 지정된 모드에서이 인스턴스와 관련된 파일을 열거 나 다시 엽니 다. 표준 파이썬 open () 메소드와는 달리, 파일 디스크립터를 리턴하지 않습니다.
* FieldFile.close -  표준 파이썬 file.close () 메소드와 유사하게 동작하고이 인스턴스와 관련된 파일을 닫습니다.
* FieldFile.save(name, content, save=True) - 이 메서드는 파일 이름과 파일 내용을 가져 와서 필드의 저장소 클래스에 전달한 다음 저장된 파일을 모델 필드와 연결합니다. 모델의 FileField 인스턴스에 파일 데이터를 수동으로 연결하려면 save () 메서드를 사용하여 해당 파일 데이터를 유지합니다.
* FieldFile.delete(save=True) - 이 인스턴스와 관련된 파일을 삭제하고 필드의 모든 특성을 지 웁니다. 이 메소드는 delete ()가 호출 될 때 열려있을 경우 파일을 닫습니다.모델을 삭제하면 관련 파일이 삭제되지 않습니다. 고아 파일을 정리해야하는 경우 직접 처리해야합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;filepathfieldpathnone-matchnone-recursivefalse-max_length100-options&quot;&gt;FilePathField(path=None, match=None, recursive=False, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CharField는 파일 시스템의 특정 디렉토리에있는 제한된 파일 이름을 선택합니다. 3개의 인자를 받으며 그중 첫번째는 필수인자 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* FilePathField.path - 필수인자로 해당 필드가 선택해야하는 파일의 절대경로를 입력해줍니다.
* FilePathField.match - 정규표현식을 통해 해당 필드가 파일네임을 필터링 할 수 있게 합니다.
* FilePathField.recursive - path의 모든 하위 디렉토리가 포함되어야하는지 여부를 지정합니다.
* FilePathField.allow_files - 지정된 위치의 파일을 포함할지 여부를 지정합니다.
* FilePathField.allow_folders - 지정된 위치의 폴더를 포함할지 여부를 지정합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;floatfieldoptions&quot;&gt;FloatField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;float 인스턴스로 파이썬에서 표현 된 부동 소수점 숫자입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;imagefieldupload_tonone-height_fieldnone-width_fieldnone-max_length100-options&quot;&gt;ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FileField의 모든 특성 및 메서드를 상속하지만 업로드 된 개체가 유효한 이미지인지 확인합니다.&lt;/li&gt;
  &lt;li&gt;FileField에서 사용할 수있는 특수 특성 외에도 ImageField에는 height 및 width 특성이 있습니다. 이러한 속성에 대한 쿼리를 용이하게하기 위해 ImageField에는 두 개의 추가 선택적 인수가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* ImageField.height_field - 모델 인스턴스가 저장 될 때마다 자동으로 지정된 높이를 갖게하는모델 필드의 이름입니다.
* ImageField.width_field - 모델 인스턴스가 저장 될 때마다 자동으로 지정된 너비를 갖게하는모델 필드의 이름입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Imagefield를 사용하기 위해서는 Pillow 라이브러리를 설치해야만 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;integerfieldoptions&quot;&gt;IntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;정수를 받을 수 있는 필드입니다. 정수. -2147483648에서 2147483647까지의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다. 이 필드의 기본 양식 위젯은 localize가 False 일 때 NumberInput이고 그렇지 않으면 TextInput입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;genericipaddressfieldprotocolboth-unpack_ipv4false-options&quot;&gt;GenericIPAddressField(protocol=’both’, unpack_ipv4=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 형식의 IPv4 또는 IPv6 주소를 받을 수 있는 필드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nullbooleanfieldoptions&quot;&gt;NullBooleanField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;BooleanField와 비슷하지만 NULL을 옵션 중 하나로 허용합니다. BooleanField 대신 null = True를 사용할 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;positiveintegerfieldoptions&quot;&gt;PositiveIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IntegerField와 같으나 양수 또는 0이어야합니다. 0에서 2147483647 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다. 이전 버전과의 호환성을 위해 0 값이 허용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;positivesmallintegerfieldoptions&quot;&gt;PositiveSmallIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PositiveIntegerField와 같지만 특정 (데이터베이스에 따라 다릅니다.) 지점에서만 값을 허용합니다. 0에서 32767 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;slugfieldmax_length50-options&quot;&gt;SlugField(max_length=50, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Slug는 신문 용어입니다. Slug는 글자, 숫자, 밑줄 또는 하이픈 만 포함하는 짧은 레이블입니다. 일반적으로 URL에 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;smallintegerfieldoptions&quot;&gt;SmallIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IntegerField와 같지만 특정 (데이터베이스에 따라) 지점에서만 값을 허용합니다. -32768에서 32767 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;textfieldoptions&quot;&gt;TextField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;큰 텍스트 필드. 이 필드의 기본 양식 위젯은 Textarea입니다. max_length 속성을 지정하면 자동 생성 양식 필드의 Textarea 위젯에 반영됩니다. 그러나 모델 또는 데이터베이스 수준에서는 적용되지 않습니다. CharField를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;timefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;TimeField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 datetime.time 인스턴스로 표현되는 시간입니다. DateField와 동일한 자동 채우기 옵션을 적용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;urlfieldmax_length200-options&quot;&gt;URLField(max_length=200, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;url을 위한 CharField입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uuidfieldoptions&quot;&gt;UUIDField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;보편적으로 유일한 식별자를 저장하기위한 필드입니다. 파이썬의 UUID 클래스를 사용합니다. PostgreSQL에서 사용될 때 이것은 uuid 데이터 유형에 저장되고, 그렇지 않으면 char (32)에 저장됩니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>-Yoda</name></author><summary type="html">Model field reference</summary></entry><entry><title type="html">Django_document</title><link href="http://localhost:4000/django_document/" rel="alternate" type="text/html" title="Django_document" /><published>2017-10-10T00:00:00+09:00</published><updated>2017-10-10T00:00:00+09:00</updated><id>http://localhost:4000/django_document</id><content type="html" xml:base="http://localhost:4000/django_document/">&lt;h4 id=&quot;field-option-중-choices&quot;&gt;Field option 중 choices&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;choices 에서 앞쪽이 데이터베이스 에서 인식하는 벨류값, 뒤쪽이 클라이언트 화면에서 보이는 값&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;example)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db import models

class Person(models.Model):
    SHIRT_SIZES = (
        ('S', 'Small'),
        ('M', 'Medium'),
        ('L', 'Large'),
    )
    name = models.CharField(max_length=60)
    shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;null값과-blank&quot;&gt;null값과 blank&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;값은 데이터베이스에 어떠한 데이터도 갖고 있지 않다는 것을 말한다. (datetime 이나 integerfield에는 비어있는 시간이나 숫자라는 개념이 없기 때문에 빈값을 적용시키기 위헤서는 null=True옵션을 줘야한다.)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;blnak&lt;/code&gt;값은 ‘비어있는 값’을 말하며 blank=True를 적용 했을 때에 데이터베이스에 ‘비어있는 값’을 저장하게 된다.(charfield, textfield에는 비어있는 값을 인식시키기 위헤서 blnak=True 옵션을 준다.) blank의 또다른 기능 중 하나는 admin에서 필수 입력요소 인지를 판단할 수 있게 해준다.&lt;/p&gt;</content><author><name>-Yoda</name></author><summary type="html">Field option 중 choices</summary></entry><entry><title type="html">Test!</title><link href="http://localhost:4000/jekyll/update/welcome-to-jekyll/" rel="alternate" type="text/html" title="Test!" /><published>2017-10-09T22:48:43+09:00</published><updated>2017-10-09T22:48:43+09:00</updated><id>http://localhost:4000/jekyll/update/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/welcome-to-jekyll/">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>-Yoda</name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Sql</title><link href="http://localhost:4000/SQL/" rel="alternate" type="text/html" title="Sql" /><published>2017-10-03T00:00:00+09:00</published><updated>2017-10-03T00:00:00+09:00</updated><id>http://localhost:4000/SQL</id><content type="html" xml:base="http://localhost:4000/SQL/">&lt;h1 id=&quot;sql-기본-문법&quot;&gt;&lt;strong&gt;SQL 기본 문법&lt;/strong&gt;&lt;/h1&gt;

&lt;h3 id=&quot;sql이란-무엇인가&quot;&gt;SQL이란 무엇인가?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SQL은 구조화 된 쿼리 언어&lt;/li&gt;
  &lt;li&gt;SQL을 사용하면 데이터베이스에 액세스하고 조작 할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;SQL은 ANSI (American National Standards Institute) 표준입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;웹사이트에서-sql-사용&quot;&gt;웹사이트에서 SQL 사용&lt;/h3&gt;
&lt;p&gt;데이터베이스의 데이터를 보여주는 웹 사이트를 구축하려면 다음이 필요합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;RDBMS 데이터베이스 프로그램 (예 : MS Access, SQL Server, MySQL)&lt;/li&gt;
  &lt;li&gt;PHP 또는 ASP와 같은 서버 측 스크립팅 언어가 필요합니다.&lt;/li&gt;
  &lt;li&gt;SQL을 사용하여 원하는 데이터를 얻을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;HTML / CSS를 사용하여 페이지의 스타일을 지정합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;rdbms란&quot;&gt;RDBMS란?&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;RDBMS는 관계형 데이터베이스 관리 시스템의 약자입니다.&lt;/li&gt;
  &lt;li&gt;RDBMS는 SQL과 MS SQL Server, IBM DB2, Oracle, MySQL 및 Microsoft Access와 같은 모든 최신 데이터베이스 시스템의 기초입니다.&lt;/li&gt;
  &lt;li&gt;RDBMS의 데이터는 테이블이라는 데이터베이스 오브젝트에 저장됩니다. 테이블은 관련 데이터 항목의 모음이며 열과 행으로 구성됩니다.&lt;/li&gt;
  &lt;li&gt;모든 테이블은 필드라는 더 작은 엔티티로 나뉩니다. Customers 테이블의 필드는 CustomerID, CustomerName, ContactName, Address, City, PostalCode 및 Country로 구성됩니다. &lt;strong&gt;필드는 테이블의 모든 레코드에 대한 특정 정보를 유지 관리하도록 설계된 테이블의 열입니다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;레코드(행) :  레코드는 테이블에있는 개별 항목입니다. 예를 들어, 위의 Customers 테이블에는 91 개의 레코드가 있습니다. 레코드는 테이블의 가로 엔티티입니다.&lt;/li&gt;
  &lt;li&gt;컬럼(열) : 컬럼은 테이블의 특정 필드와 연관된 모든 정보를 포함하는 테이블의 수직 엔티티입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql문-기본-문법&quot;&gt;SQL문 기본 문법&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SQL 키워드는 대소 문자를 구분하지 않습니다. select는 SELECT와 같습니다.&lt;/li&gt;
  &lt;li&gt;일부 데이터베이스 시스템에서는 각 SQL 문의 끝에 세미콜론이 필요합니다. 세미콜론은 데이터베이스 시스템에서 각 SQL 문을 분리하여 서버에 대한 동일한 호출에서 둘 이상의 SQL 문을 실행할 수 있도록하는 표준 방법입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;주요-핵심-sql명령어&quot;&gt;주요 핵심 SQL명령어&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT - 데이터베이스에서 데이터를 추출합니다.
UPDATE - 데이터베이스의 데이터를 업데이트합니다.
DELETE - 데이터베이스에서 데이터를 삭제합니다.
INSERT INTO - 새로운 데이터를 데이터베이스에 삽입합니다.
CREATE DATABASE - 새 데이터베이스를 만듭니다.
ALTER DATABASE - 데이터베이스를 수정합니다.
CREATE TABLE - 새 테이블을 만듭니다.
ALTER TABLE - 테이블을 수정합니다.
DROP TABLE - 테이블을 삭제합니다.
CREATE INDEX - 색인 (검색 키)을 작성합니다.
DROP INDEX - 색인을 삭제합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-select문&quot;&gt;SQL SELECT문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SELECT 문은 데이터베이스에서 데이터를 선택하는 데 사용됩니다.리턴 된 데이터는 결과 세트라고하는 결과 테이블에 저장됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;SELECT문 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 필드이름, 필드이름, ... FROM  테이블 이름
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;전체 필드 선택
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM table_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-select-distinct문&quot;&gt;SQL SELECT DISTINCT문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SELECT DISTINCT는 고유 한 (다른) 값만 리턴하는 데 사용됩니다. 테이블 내에서 열은 종종 많은 중복 값을 포함합니다. 때로는 서로 다른 (뚜렷한) 값만 나열하려고합니다. SELECT DISTINCT.은 고유 한 (다른) 값만 리턴하는 데 사용됩니다. (중복값 제거하고 고유한 값들만 얻어내는 명령문)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT DISTINCT 필드이름, 필드이름, ... FROM 테이블이름
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음은 해당 필드의 고유한 레코드 값의 수를 나열한다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(DISTINCT 필드이름) FROM 테이블이름;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-where절&quot;&gt;SQL WHERE절&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;WHERE 절은 레코드를 필터링하는 데 사용됩니다. WHERE 절은 지정된 조건을 충족하는 레코드 만 추출하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 필드이름, 필드이름, ... FROM 테이블이름
WHERE 조건;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;사용예시1 : Customers 테이블에서 Mexico 국가의 모든 고객을 선택
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE country='Mexico';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL은 텍스트 값에 대해 작은 따옴표를 사용해야합니다 (대부분의 데이터베이스 시스템은 큰 따옴표도 허용합니다). 그러나 숫자 필드는 따옴표로 묶지 않아야합니다. 다음 사용예시는 전체 필드중에서 CustomersID값이 1인 값을 가져옵니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE CustomerID=1;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;WHERE 절에 있는 연산자&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Operator&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;=&lt;/td&gt;
      &lt;td&gt;Equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;Not equal. Note: In some versions of SQL this operator may be written as !=&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;Greater than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;&lt;/td&gt;
      &lt;td&gt;Less than&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;gt;=&lt;/td&gt;
      &lt;td&gt;Greater than or equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&amp;lt;=&lt;/td&gt;
      &lt;td&gt;Less than or equal&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BETWEEN&lt;/td&gt;
      &lt;td&gt;Between an inclusive range&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LIKE&lt;/td&gt;
      &lt;td&gt;Search for a pattern&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IN&lt;/td&gt;
      &lt;td&gt;To specify multiple possible values for a column&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;sql-and-or-및-not-연산자&quot;&gt;SQL AND, OR 및 NOT 연산자&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;WHERE 절은 AND, OR 및 NOT 연산자와 결합 할 수 있습니다. AND 및 OR 연산자는 둘 이상의 조건에 따라 레코드를 필터링하는 데 사용됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AND로 구분 된 모든 조건이 TRUE이면 AND 연산자는 레코드를 표시합니다.
OR로 구분 된 조건이 TRUE 인 경우 OR 연산자는 레코드를 표시합니다.
NOT 연산자는 조건이 참이 아닌 경우 레코드를 표시합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 필드이름, 필드이름, ...
FROM 테이블이름
WHERE 조건 AND 조건 AND 조건...;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 필드이름, 필드이름, ...
FROM 테이블이름
WHERE 조건 OR 조건 OR 조건...;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 필드이름, 필드이름, ...
FROM 테이블이름
WHERE NOT 조건...;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;AND, OR 및 NOT 결합
AND, OR 및 NOT 연산자를 결합 할 수도 있습니다.다음 SQL 문은 country가 “Germany”이고 도시가 “Berlin”또는 “München”(복잡한 표현식을 형성하기 위해 괄호를 사용해야 함) 인 “Customers”의 모든 필드를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE Country='Germany' AND (City='Berlin' OR City='München');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 country가 “Germany”가 아니며 “USA”가 아닌 “Customers”의 모든 필드를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE NOT Country='Germany' AND NOT Country='USA';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-order-by-키워드&quot;&gt;SQL ORDER BY 키워드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ORDER BY 키워드는 결과 집합을 오름차순 또는 내림차순으로 정렬하는 데 사용됩니다. ORDER BY 키워드는 기본적으로 레코드를 오름차순으로 정렬합니다. 내림차순으로 레코드를 정렬하려면 DESC 키워드를 사용하십시오.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 필드이름, 필드이름, ...
FROM 테이블이름
ORDER BY 필드이름, 필드이름, ... ASC|DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “고객”테이블의 모든 고객을 “국가”열로 정렬하여 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
ORDER BY Country;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “고객”테이블의 모든 고객을 “국가”열로 역순으로 정렬하여 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
ORDER BY country DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “Customers”테이블의 모든 고객을 “Country”및 “CustomerName”열로 정렬하여 선택합니다. (Country로 정렬한 다음 CustomerName으로 다시 정렬)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
ORDER BY Country, CustomerName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “Customers”테이블의 모든 고객을 “Country”로 오름차순으로 정렬하고 “CustomerName”열로 내림차순으로 정렬합니다. (Country로 오름차순 정렬후 CustomerName으로 다시 내림차순으로 정렬)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
ORDER BY Country ASC, CustomerName DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-insert-into문&quot;&gt;SQL INSERT INTO문&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;INSERT INTO 문은 테이블에 새 레코드를 삽입하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;INSERT INTO 문을 작성하는 첫 번째 방법 : 삽입 할 열 이름과 값을 모두 지정합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO table_name (column1, column2, column3, ...)
VALUES (value1, value2, value3, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;표의 모든 열에 값을 추가하는 경우 SQL 조회에서 열 이름을 지정할 필요가 없습니다. 그러나 값의 순서가 테이블의 열과 동일한 순서인지 확인하십시오. INSERT INTO 구문은 다음과 같습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO table_name
VALUES (value1, value2, value3, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 새 레코드를 삽입하지만 “CustomerName”, “City”및 “Country”열에 만 데이터를 삽입합니다 (CustomerID는 자동으로 업데이트됩니다).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO Customers (CustomerName, City, Country)
VALUES ('Cardinal', 'Stavanger', 'Norway');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-null-값&quot;&gt;SQL NULL 값&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NULL값이란? : NULL 값이있는 필드는 값이없는 필드입니다. 테이블의 필드가 선택적이면이 필드에 값을 추가하지 않고 새 레코드를 삽입하거나 레코드를 업데이트 할 수 있습니다. 그런 다음 필드는 NULL 값으로 저장됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://slowalk.tistory.com/2181&quot;&gt;NULL값에 대하여 잘 설명되어 있는 참고할만한 블로그&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NULL값이 0 이나 혹은 공백으로 되어있는 필드와는 다르다는 것을 이해하는 것이 중요합니다. 널 값이 있는 필드는 레코드가 생성되는 동안 빈공간으로 남겨져 있다는 것을 말합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IS NULL&lt;/code&gt; 연산자와 &lt;code class=&quot;highlighter-rouge&quot;&gt;IS NOT NULL&lt;/code&gt; 연산자를 통해 NULL 값을 테스트 할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL.은 IS NULL 연산자를 사용하여 주소가없는 모든 값을 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT LastName, FirstName, Address FROM Persons
WHERE Address IS NULL;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 IS NOT NULL 연산자를 사용하여 주소가있는 모든 사람을 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT LastName, FirstName, Address FROM Persons
WHERE Address IS NOT NULL;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-update문&quot;&gt;SQL UPDATE문&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UPDATE 문은 테이블의 기존 레코드를 수정하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPDATE table_name
SET column1 = value1, column2 = value2, ...
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블의 레코드를 업데이트 할 때에는 UPDATE 문에서 WHERE 절을 확인하십시오. WHERE 절은 갱신해야하는 레코드를 지정합니다. WHERE 절을 생략하면 테이블의 모든 레코드가 업데이트됩니다!
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPDATE Customers
SET ContactName='Juan';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;한번에 여러 레코드를 업데이트 할 수도 있습니다. 업데이트 될 레코드 수를 결정하는 것은 WHERE 절입니다.
다음 SQL 문은 country가 “Mexico”인 모든 레코드에 대해 연락처 이름을 “Juan”으로 업데이트합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;UPDATE Customers
SET ContactName='Juan'
WHERE Country='Mexico';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-delete문&quot;&gt;SQL DELETE문&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DELETE 문은 테이블의 기존 레코드를 삭제하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DELETE FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 : Customers; 테이블에서 고객 “Alfreds Futterkiste”를 제거합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DELETE FROM Customers
WHERE CustomerName='Alfreds Futterkiste';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;아래의 명령을 통해, 테이블을 제거하지 않고 테이블의 모든 행을 제거 할 수 있습니다. 이것은 테이블 구조, 속성 및 인덱스가 손상되지 않는다는 것을 의미합니다.
&lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE FROM table_name;&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;DELETE * FROM table_name;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-top-limit-또는-rownum절&quot;&gt;SQL TOP, LIMIT 또는 ROWNUM절&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SELECT TOP 절은 리턴 할 레코드 수를 지정하는 데 사용됩니다. SELECT TOP 절은 수천 개의 레코드가있는 큰 테이블에서 유용합니다. 많은 수의 레코드를 반환하면 성능에 영향을 줄 수 있습니다.
주의할 점은 모든 데이터베이스 시스템이 SELECT TOP 절을 지원하는 것은 아니라는 것 입니다. MySQL은 제한된 수의 레코드를 선택하기 위해 LIMIT 절을 지원하고 Oracle은 ROWNUM을 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 사용법&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL Server / MS 액세스 구문 :
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT TOP number|percent column_name(s)
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE condition
LIMIT number;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE ROWNUM &amp;lt;= number;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “Customers”테이블에서 처음 세 개의 레코드를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT TOP 3 * FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 LIMIT 절을 사용하는 동일한 예제를 보여줍니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
LIMIT 3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 ROWNUM을 사용하는 동일한 예제를 보여줍니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE ROWNUM &amp;lt;= 3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 국가가 “Germany”인 “Customers”테이블에서 처음 세 개의 레코드를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT TOP 3 * FROM Customers
WHERE Country='Germany';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 LIMIT 절을 사용하는 동일한 예제를 보여줍니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE Country='Germany'
LIMIT 3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 ROWNUM을 사용하는 동일한 예제를 보여줍니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE Country='Germany' AND ROWNUM &amp;lt;= 3;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-min-및-max합수&quot;&gt;SQL MIN() 및 MAX()합수&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;MIN () 함수는 선택된 컬럼의 가장 작은 값을 리턴합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT MIN(column_name)
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;MAX () 함수는 선택된 컬럼의의 가장 큰 값을 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT MAX(column_name)
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 가장 저렴한 제품의 가격을 찾습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT MIN(Price) AS SmallestPrice
FROM Products;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 가장 비싼 제품의 가격을 찾습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT MAX(Price) AS LargestPrice
FROM Products;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-count-avg및-sum-함수&quot;&gt;SQL COUNT(), AVG()및 SUM() 함수&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;COUNT () 함수는 지정된 기준과 일치하는 행 수를 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(column_name)
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;AVG () 함수는 숫자 열의 평균값을 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT AVG(column_name)
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SUM () 함수는 숫자 열의 총 합계를 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT SUM(column_name)
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-like연산자&quot;&gt;SQL LIKE연산자&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;LIKE 연산자는 WHERE 절에서 열의 지정된 패턴을 검색하는 데 사용됩니다. LIKE 연산자와 함께 사용되는 두 개의 와일드 카드가 있습니다. (MS Access는 밑줄 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 대신 물음표 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;를 사용합니다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt;백분율 기호는 0, 1 또는 복수 문자를 나타냅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt;밑줄은 한 문자를 나타냅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column1, column2, ...
FROM table_name
WHERE columnN LIKE pattern;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;AND 또는 OR 연산자를 사용하여 여러 조건을 결합 할 수도 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;몇가지 예시&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;LIKE Operator&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;WHERE CustomerName LIKE &lt;code class=&quot;highlighter-rouge&quot;&gt;a%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Finds any values that starts with “a”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WHERE CustomerName LIKE &lt;code class=&quot;highlighter-rouge&quot;&gt;%a&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Finds any values that ends with “a”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WHERE CustomerName LIKE &lt;code class=&quot;highlighter-rouge&quot;&gt;%or%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Finds any values that have “or” in any position&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WHERE CustomerName LIKE &lt;code class=&quot;highlighter-rouge&quot;&gt;_r%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Finds any values that have “r” in the second position&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WHERE CustomerName LIKE &lt;code class=&quot;highlighter-rouge&quot;&gt;a_%_%&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Finds any values that starts with “a” and are at least 3 characters in length&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;WHERE ContactName LIKE &lt;code class=&quot;highlighter-rouge&quot;&gt;a%o&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Finds any values that starts with “a” and ends with “o”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;sql-와일드-카드-문자&quot;&gt;SQL 와일드 카드 문자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;와일드 카드 문자는 문자열의 다른 문자를 대체하는 데 사용됩니다. 와일드 카드 문자는 SQL LIKE 연산자 와 함께 사용됩니다 . LIKE 연산자는 WHERE 절에서 열의 지정된 패턴을 검색하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LIKE 연산자와 함께 사용되는 두 개의 와일드 카드가 있습니다. (MS Access는 밑줄 &lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 대신 물음표 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;를 사용합니다.)&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; 백분율 기호는 0, 1 또는 복수 문자를 나타냅니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_&lt;/code&gt; 밑줄은 한 문자를 나타냅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;다음 SQL 문은 City가 “ber”로 시작하는 모든 고객을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE City LIKE 'ber%';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-in-연산자&quot;&gt;SQL IN 연산자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IN 연산자를 사용하여 WHERE 절에 여러 값을 지정할 수 있습니다. IN 연산자는 여러 OR 조건의 줄임말입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE column_name IN (value1, value2, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;또는&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE column_name IN (SELECT STATEMENT);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “Germany”, “France”및 “UK”에있는 모든 고객을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE Country IN ('Germany', 'France', 'UK');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 “Germany”, “France”또는 “UK”에 있지 않은 모든 고객을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers
WHERE Country NOT IN ('Germany', 'France', 'UK');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 공급 업체와 동일한 국가의 모든 고객을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ELECT * FROM Customers
WHERE Country IN (SELECT Country FROM Suppliers);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-between연산자&quot;&gt;SQL BETWEEN연산자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BETWEEN 연산자는 주어진 범위 내의 값을 선택합니다. 값은 숫자, 텍스트 또는 날짜 일 수 있습니다. BETWEEN 연산자는 시작과 끝 값이 포함됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 가격이 10과 20 사이 인 모든 제품을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 가격이 10과 20 사이 인 모든 제품을 선택합니다. CategoryID가 1,2 또는 3 인 제품을 표시하지 않습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Products
WHERE (Price BETWEEN 10 AND 20)
AND NOT CategoryID IN (1,2,3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL.은 ‘Carnarvon Tigers’와 ‘Mozzarella di Giovanni’사이에 ProductName이있는 모든 제품을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Products
WHERE ProductName BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni'
ORDER BY ProductName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 ProductName이 ‘Carnarvon Tigers’및 ‘Mozzarella di Giovanni’가 아닌 모든 제품을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Products
WHERE ProductName NOT BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni'
ORDER BY ProductName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 OrderDate BETWEEN ‘04 -July-1996 ‘및 ‘09-Junly-1996’이있는 모든 주문을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Orders
WHERE OrderDate BETWEEN #07/04/1996# AND #07/09/1996#;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-aliases&quot;&gt;SQL Aliases&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SQL (Aliases)별칭은 테이블 또는 테이블의 열에 임시 이름을 지정하는 데 사용됩니다. 앨리어스는 종종 컬럼 이름을 읽기 쉽게하기 위해 사용됩니다. 별명은 조회 기간 동안 만 존재합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;컬럼 Aliase 지정예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name AS alias_name
FROM table_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블 Aliase 지정예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name AS alias_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 CustomerID 열과 CustomerName 열의 두 가지 별칭을 만듭니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CustomerID as ID, CustomerName AS Customer
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 CustomerName 열과 ContactName 열의 두 가지 별칭을 만듭니다. 참고 : 별칭 이름에 공백이 포함되어 있으면 큰 따옴표 또는 대괄호가 필요합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CustomerName AS Customer, ContactName AS [Contact Person]
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 네 개의 열 (Address, PostalCode, City 및 Country)을 결합하는 “Address”라는 별칭을 만듭니다. (각 필드의 결합의 경우 결합될 양식을 ‘,’ 이나 ‘ ‘ 과 같이 만들어 줄 수 있다.)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;참고 : 위의 SQL 문을 MySQL에서 작동 시키려면 다음을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CustomerName, CONCAT(Address,', ',PostalCode,', ',City,', ',Country) AS Address
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL.은 CustomerID = 4 (Around the Horn) 인 고객의 모든 주.을 선택합니다. “Customers”및 “Orders”테이블을 사용하고 각각 “c”및 “o”테이블 별칭을 부여합니다 (여기서 별칭을 사용하여 SQL을 더 짧게 만듭니다).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT o.OrderID, o.OrderDate, c.CustomerName
FROM Customers AS c, Orders AS o
WHERE c.CustomerName=&quot;Around the Horn&quot; AND c.CustomerID=o.CustomerID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Aliase는 다음과 같은 경우에 유용합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;쿼리에 두 개 이상의 테이블이 관련되어 있습니다.
함수는 쿼리에서 사용됩니다.
열 이름이 크거나 매우 읽을 수 없습니다.
두 개 이상의 열이 결합되었습니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;join&quot;&gt;JOIN&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;JOIN 절은 두 개 이상의 테이블에있는 행을 결합하는 데 사용됩니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수학의 집합 처럼 조건을 두고 그 조건 안에서 원하는 자료를 선택하는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Oders&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;OrderID&lt;/th&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;OrderDate&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;10308&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1996-09-18&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10309&lt;/td&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;1996-09-19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10310&lt;/td&gt;
      &lt;td&gt;77&lt;/td&gt;
      &lt;td&gt;1996-09-20&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Customers&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;CustomerID&lt;/th&gt;
      &lt;th&gt;CustomerName&lt;/th&gt;
      &lt;th&gt;ContactName&lt;/th&gt;
      &lt;th&gt;Country&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Alfreds Futterkiste&lt;/td&gt;
      &lt;td&gt;Maria Anders&lt;/td&gt;
      &lt;td&gt;Germany&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Ana Trujillo Emparedados y helados&lt;/td&gt;
      &lt;td&gt;Ana Trujillo&lt;/td&gt;
      &lt;td&gt;Mexico&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Antonio Moreno Taquería&lt;/td&gt;
      &lt;td&gt;Antonio Moreno&lt;/td&gt;
      &lt;td&gt;Mexico&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Orders테이블의 CustomerID열은 Customers테이블의 CustomerID를 나타냅니다. 위의 두 테이블 사이의 공유하고 있는 정보는 CustomerID열 입니다. 이와같이 같은 정보를 통하여 위의 두 테이블의 공통된 Value를 가지는 레코드를 골라내는 SQL문장을 만들어 낼 수 있습니다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;INNER JOIN문에서 Orders의 CustomersID와 Customers의 CustomersID가 같은 값을 찾아내고 같은 값을 가지는 행의 정보를 두 테이블에서 가져와 SELECT문에서 산출한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다양한 유형의 SQL JOIN
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(INNER) JOIN : 두 테이블에서 값이 일치하는 레코드를 반환합니다.
LEFT (OUTER) JOIN : 왼쪽 테이블에서 모든 레코드를 반환하고 오른쪽 테이블에서 일치하는 레코드를 반환합니다.
RIGHT (OUTER) JOIN : 오른쪽 테이블에서 모든 레코드를 반환하고 왼쪽 테이블에서 일치하는 레코드를 반환합니다.
FULL (OUTER) JOIN : 왼쪽 또는 오른쪽 테이블에 일치하는 항목이 있으면 모든 레코드를 반환합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;./img_join.gif&quot; alt=&quot;벤다이어그램&quot; /&gt;
&lt;img src=&quot;./img_leftjoin.gif&quot; alt=&quot;벤다이어그램&quot; /&gt;
&lt;img src=&quot;./img_rightjoin.gif&quot; alt=&quot;벤다이어그램&quot; /&gt;
&lt;img src=&quot;./img_fulljoin.gif&quot; alt=&quot;벤다이어그램&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-inner-join-키워드&quot;&gt;SQL INNER JOIN 키워드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;INNER JOIN 키워드는 두 표에서 모두 일치하는 값을 가진 레코드를 선택합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table1
INNER JOIN table2 ON table1.column_name = table2.column_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;다음과 같이 놓고 보면 좀더 이해하기 쉽다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;해당 컬럼은 FROM table1 과 table2 의 colum_name INNER JOIN한 데이터를 기준으로 해서 자료를 가져온다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;INNER JOIN 키워드는 비교대상인 컬럼간에 일치하는 모든 행을 선택합니다. ‘주문 테이블의 비교대상컬럼과 ‘고객’테이블의 비교대상컬럼에 일치하는 레코드가 없을경우 아무런 레코드도 표시되지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 Customers정보와 Shippers정보가 있는 Orders 테이블을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName
FROM ((Orders
INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID)
INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-left-join키워드&quot;&gt;SQL LEFT JOIN키워드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;LEFT JOIN키워드는 왼쪽 테이블의 모든 레코드와 오른쪽테이블의 일치 레코들을 반환합니다. 일치하는 것이 없으면 오른쪽 테이블의 정보는 모두 Null값이 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table1
LEFT JOIN table2 ON table1.column_name = table2.column_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일부 데이터베이스에서는 LEFT JOIN을 LEFT OUTER JOIN이라고합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 고객과 주문번호를 선택하여 나타냅니다. LEFT JOIN 키워드는 오른쪽 테이블 (Orders)에 일치하는 항목이 없더라도 왼쪽 테이블 (Customers)의 모든 레코드를 반환합니다.(일치하는 CustomersID값을 기준으로 Orders.OrdesID정보를 가져옵니다. 일치하는 CustomersID가 없는 Customers테이블의 값들은 Orders.OrdesID에 Null이 할당됩니다.)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID
ORDER BY Customers.CustomerName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-right-join키워드&quot;&gt;SQL RIGHT JOIN키워드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;RRIGHT JOIN키워드는 오른쪽 테이블의 모든 레코드와 외쪽테이블의 일치 레코들을 반환합니다. 일치하는 것이 없으면 외쪽 테이블의 정보는 모두 Null값이 됩니다. RIGHT JOIN 키워드는 왼쪽 테이블 (Orders)에 일치하는 항목이 없더라도 오른쪽 테이블 (Employees)의 모든 레코드를 반환합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음 SQL문은 모든 직원 및 주문한 모든 주문을 반환합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Orders.OrderID, Employees.LastName, Employees.FirstName
FROM Orders
RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
ORDER BY Orders.OrderID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-full-outer-join키워드&quot;&gt;SQL FULL OUTER JOIN키워드&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;FULL OUTER JOIN 키워드는 왼쪽 (table1) 또는 오른쪽 (table2) 테이블 레코드가 일치 할 때 모든 레코드를 리턴합니다. FULL OUTER JOIN은 잠재적으로 매우 큰 결과 집합을 반환 할 수 있습니다!&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table1
FULL OUTER JOIN table2 ON table1.column_name = table2.column_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 모든 고객의 이름과 모든 주믄을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;FULL OUTER JOIN 키워드는 왼쪽 테이블 (Customers)의 모든 행과 오른쪽 테이블 (Orders)의 모든 행을 리턴합니다. ‘주문’에 일치하지 않는 행이 ‘고객’에 있거나 ‘고객’에 일치하지 않는 행이 ‘주문’에있는 경우 해당 행이 함께 표시됩니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;self-join문&quot;&gt;SELF JOIN문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SELF JOIN문은 조인문이지만 자기 자신과 결합합니다. 실제로 자기 자신과의 결합이 아니라 그렇게 하는 것과 같은 효과를 가졌다는 겄을 말한다. 같은 테이블 안에서 여러가지 컬럼을 조건으로 하여 결과값을 가져오고 싶을 때 사용합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table1 T1, table1 T2
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 같은 도시에서 온 고객들을 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City
FROM Customers A, Customers B
WHERE A.CustomerID &amp;lt;&amp;gt; B.CustomerID
AND A.City = B.City
ORDER BY A.City;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-union연산자&quot;&gt;SQL UNION연산자&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UNION 연산자는 두 개 이상의 SELECT 문의 결과를 결합하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UNION 연산자 사용조건&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;UNION 내의 각 SELECT 문은 같은 수의 열을 가져야합니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;열은 유사한 데이터 형식을 가져야합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;각 SELECT 문의 열은 같은 순서로 있어야합니다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s) FROM table1
UNION
SELECT column_name(s) FROM table2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 UNION ALL을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s) FROM table1
UNION ALL
SELECT column_name(s) FROM table2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;결과 집합의 열 이름은 일반적으로 UNION의 첫 번째 SELECT 문의 열 이름과 동일합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 “Customers”W “Suppliers”에서 모든 다른 독일 도시 (유일한 값만)를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT City, Country FROM Customers
WHERE Country='Germany'
UNION
SELECT City, Country FROM Suppliers
WHERE Country='Germany'
ORDER BY City;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 “Customers”W “Suppliers”에서 모든 독일 도시 (중복 값 포함)를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT City, Country FROM Customers
WHERE Country='Germany'
UNION ALL
SELECT City, Country FROM Suppliers
WHERE Country='Germany'
ORDER BY City;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 모든 고객과 공급자를 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT 'Customer' As Type, ContactName, City, Country
FROM Customers
UNION
SELECT 'Supplier', ContactName, City, Country
FROM Suppliers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-group-by문&quot;&gt;SQL GROUP BY문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GROUP BY문은 집계 함수 (COUNT, MAX, MIN, SUM, AVG)와 함께 사용되어 결과 집합을 하나 이상의 열로 그룹화 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
ORDER BY column_name(s);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 각 국가의 고객 수를 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 각 국가의 고객 수를 내림차순으로 정렬하여 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
ORDER BY COUNT(CustomerID) DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 각 발송인이 보낸 주문 수를 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders
LEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID
GROUP BY ShipperName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-having-clausehaving절&quot;&gt;SQL HAVING Clause(HAVING절)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HAVING절은 WHERE 키워드가 집합 함수(aggregate functions)와 함께 사용될 수 없기 때문에 SQL문에 추가되었습니다. (연산에 조건을 추가하여 더 세밀한 정보를 찾아낼 때 사용할 수 있다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE condition
GROUP BY column_name(s)
HAVING condition
ORDER BY column_name(s);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 각 국가의 고객 수를 나열합니다. 5 명 이상의 고객이있는 국가 만 포함
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) &amp;gt; 5;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 각 국가의 고객 수를 높은 순으로 정렬하여 나열합니다 (고객이 5 명 이상인 국가 만 포함).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT COUNT(CustomerID), Country
FROM Customers
GROUP BY Country
HAVING COUNT(CustomerID) &amp;gt; 5
ORDER BY COUNT(CustomerID) DESC;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Davolio”또는 “Fuller”직원이 25 개가 넘는 주문을 등록한 경우 다음 SQL 문에 나열됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders
FROM Orders
INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID
WHERE LastName = 'Davolio' OR LastName = 'Fuller'
GROUP BY LastName
HAVING COUNT(Orders.OrderID) &amp;gt; 25;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-exists-연산자&quot;&gt;SQL EXISTS 연산자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;EXISTS 연산자는 하위 쿼리의 레코드 존재 여부를 테스트하는 데 사용됩니다. EXISTS 연산자는 하위 쿼리가 하나 이상의 레코드를 반환하면 true를 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE EXISTS
(SELECT column_name FROM table_name WHERE condition);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 TRUE를 반환하고 제품 가격이 20 미만인 공급 업체를 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT SupplierName
FROM Suppliers
WHERE EXISTS (SELECT ProductName FROM Products WHERE SupplierId = Suppliers.supplierId AND Price &amp;lt; 20);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-any-및-all-연산자&quot;&gt;SQL ANY 및 ALL 연산자&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ANY 및 ALL 연산자는 WHERE 또는 HAVING 절과 함 2 사용됩니다. ANY 연산자는 하위 쿼리 값 중 하나가 조건을 충족하면 true를 반환합니다. ALL 연산자는 모든 하위 쿼리 값이 조건을 충족하면 true를 반환합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;ANY 구문 기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE column_name operator ANY
(SELECT column_name FROM table_name WHERE condition);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;ALL 구문 기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column_name(s)
FROM table_name
WHERE column_name operator ALL
(SELECT column_name FROM table_name WHERE condition);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 TRUE를 리턴하고 OrderDetails 의 quantity = 10 인 값의 ProductID와 Products의 ProductID를 비교하여 같은 값이 있다면 Products의 ProductsName을 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName
FROM Products
WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;OrderDetails 테이블의 모든 레코드가 quantity = 10이면 다음 SQL 문은 TRUE를 반환하고 제품 이름을 나열합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName
FROM Products
WHERE ProductID = ALL (SELECT ProductID FROM OrderDetails WHERE Quantity = 10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-select-into문&quot;&gt;SQL SELECT INTO문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SELECT INTO 문은 한 테이블의 데이터를 새 테이블로 복사합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법(모든 열을 새 테이블로 복사)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT *
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법(일부 열만 새 테이블로 복사)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT column1, column2, column3, ...
INTO newtable [IN externaldb]
FROM oldtable
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 Customers 백업 복사본을 만듭니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * INTO CustomersBackup2017
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 IN 절을 사용하여 테이블을 다른 데이터베이스의 새 테이블로 복사합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * INTO CustomersBackup2017 IN 'Backup.mdb'
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 몇 개의 열만 새 테이블에 복사합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CustomerName, ContactName INTO CustomersBackup2017
FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 독일 고객 만 새 테이블로 복사합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * INTO CustomersGermany
FROM Customers
WHERE Country = 'Germany';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL 문은 둘 이상의 테이블의 데이터를 새 테이블로 복사합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT Customers.CustomerName, Orders.OrderID
INTO CustomersOrderBackup2017
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SELECT INTO를 사용하여 다른 테이블의 스키마를 사용하여 빈 테이블을 새로 만들 수도 있습니다. 쿼리가 데이터를 반환하지 않게하는 WHERE 절을 추가하기만 하면됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * INTO newtable
FROM oldtable
WHERE 1 = 0;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-insert-into-select문&quot;&gt;SQL INSERT INTO SELECT문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;INSERT INTO SELECT 문은 한 테이블의 데이터를 복사하여 다른 테이블에 삽입합니다. INSERT INTO SELECT는 소스 및 목표 테이블의 데이터 유형이 일치해야합니다. 목표 테이블의 기존 레코드는 영향을받지 않습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;한 테이블의 모든 열을 다른 테이블로 복사
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO table2
SELECT * FROM table1
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;한 테이블의 일부 열만 다른 테이블로 복사
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO table2 (column1, column2, column3, ...)
SELECT column1, column2, column3, ...
FROM table1
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-null함수&quot;&gt;SQL NULL함수&lt;/h3&gt;
&lt;p&gt;예제 데이터
P_Id	|	ProductName	|	UnitPrice	|	UnitsInStock	|	UnitsOnOrder
—|—|—|—|—
1	|	Jarlsberg	|	10.45	|	16	|	15
2	|	Mascarpone	|	32.56	|	23	|
3	|	Gorgonzola	|	15.67	|	9	|	20&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“UnitsOnOrder”열이 선택적이며 NULL 값을 포함 할 수 있다고 가정합니다. 다음 SQL문에서는 위의 예제에서 위의 예제에서 “UnitsOnOrder”값 중 하나라도 NULL이면 결과는 NULL입니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName, UnitPrice * (UnitsInStock + UnitsOnOrder)
FROM Products;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;MY SQL에서는 IFNULL()함수를 사용하거나 COALESCE() 함수를 사용하여 대체 값을 반환 할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0))
FROM Products
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0))
FROM Products
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL서버에서는 ISNULL()함수를 사용하면 식이 NULL일 때 대체 값을 반환 할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName, UnitPrice * (UnitsInStock + ISNULL(UnitsOnOrder, 0))
FROM Products
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;MS Access IsNull()함수는 식이 null값이면 True(-1)를 반환하고 그렇지 않으면 FALSE(0)을 반환합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName, UnitPrice * (UnitsInStock + IIF(IsNull(UnitsOnOrder), 0, UnitsOnOrder))
FROM Products
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Oracle NVL () 함수는 동일한 결과를 얻습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT ProductName, UnitPrice * (UnitsInStock + NVL(UnitsOnOrder, 0))
FROM Products
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-주석&quot;&gt;SQL 주석&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;주석은 SQL 문의 섹션을 설명하거나 SQL 문의 실행을 막는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;한 줄 주석은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;로 시작합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;와 행 끝 사이의 모든 텍스트는 무시됩니다 (실행되지 않습니다). 다음 예제는 한 줄 주석을 설명으로 사용합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--Select all:
SELECT * FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 예제에서는 한 줄 주석을 사용하여 줄 끝을 무시합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Customers -- WHERE City='Berlin';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;여러 줄 주석은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/*&lt;/code&gt;로 시작하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;*/&lt;/code&gt;로 끝납니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;/*&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;*/&lt;/code&gt; 사이의 모든 텍스트는 무시됩니다. 다음 예제에서는 설명을 위해 여러 줄 주석을 사용합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*Select all the columns
of all the records
in the Customers table:*/
SELECT * FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;명령문의 일부만 무시하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/*&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;*/&lt;/code&gt; 주석도 사용하십시오. 다음 예제에서는 주석을 사용하여 행의 일부를 무시합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT CustomerName, /*City,*/ Country FROM Customers;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;sql-데이터베이스-동작-관련-문법&quot;&gt;&lt;strong&gt;SQL 데이터베이스 동작 관련 문법&lt;/strong&gt;&lt;/h1&gt;

&lt;h3 id=&quot;create-database문&quot;&gt;CREATE DATABASE문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CREATE DATABASE 문은 새 SQL 데이터베이스를 만드는 데 사용됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE databasename;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;drop-database문&quot;&gt;DROP DATABASE문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DROP DATABASE 문은 기존 SQL 데이터베이스를 삭제하는 데 사용됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP DATABASE databasename;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;create-table문&quot;&gt;CREATE TABLE문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CREATE TABLE 문은 데이터베이스에 새 테이블을 만드는 데 사용됩니다.
    &lt;blockquote&gt;
      &lt;p&gt;column 매개 변수는 테이블의 열 이름을 지정합니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;datatype 매개 변수는 열에서 보유 할 수있는 데이터 유형 (예 : varchar, 정수, 날짜 등)을 지정합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE table_name (
    column1 datatype,
    column2 datatype,
    column3 datatype,
   ....
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;다음 예에서는 PersonID, LastName, FirstName, Address 및 City라는 다섯 개의 열이 포함 된 “Persons”라는 테이블을 만듭니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  PersonID int,
  LastName varchar(255),
  FirstName varchar(255),
  Address varchar(255),
  City varchar(255)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;blockquote&gt;
      &lt;p&gt;PersonID 열은 int 유형이며 정수를 포함합니다.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;LastName, FirstName, Address 및 City 열은 varchar 유형이며 문자를 포함하며이 필드의 최대 길이는 255 자입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;빈 “Persons”테이블은 이제 다음과 같이 보입니다.&lt;/p&gt;

&lt;p&gt;PersonID	|	LastName	|	FirstName	|	Address	|	City
—|—|—|—|—
—|—|—|—|—&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;다른 테이블을 사용하여 새 테이블을 만들 수 있습니다. 기존 테이블의 사본은 CREATE TABLE.과 SELECT.의 조합을 사용하여 작성할 수 있습니다. 테이블은 동일한 열 정의를 가져옵니다. 모든 열 또는 특정 열을 선택할 수 있습니다. 기존 테이블을 사용하여 새 테이블을 만들면 새 테이블은 이전 테이블의 기존 값으로 채워집니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE new_table_name AS
  SELECT column1, column2,...
  FROM existing_table_name
  WHERE ....;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;drop-table문&quot;&gt;DROP TABLE문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;DROP TABLE 문은 데이터베이스의 기존 테이블을 삭제하는 데 사용됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP TABLE table_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;TRUNCATE TABLE 문은 테이블 내부의 데이터는 삭제하지만 테이블 자체는 삭제하지 않습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TRUNCATE TABLE table_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;alter-table문&quot;&gt;ALTER TABLE문&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ALTER TABLE 문은 기존 테이블의 열을 추가, 삭제 또는 수정하는 데 사용됩니다. ALTER TABLE문은 기존 테이블에 다양한 제한 조건을 추가 제거하는 데에도 사용됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE table_name
ADD column_name datatype;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블의 열을 삭제하려면 다음 구문을 사용합니다 (일부 데이터베이스 시스템에서는 열 삭제가 허용되지 않음).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE table_name
DROP COLUMN column_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블에있는 열의 데이터 형식을 변경하려면 다음 구문을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQL Server / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE table_name
ALTER COLUMN column_name datatype;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;내 SQL / 오라클 (이전 버전 10G) :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE table_name
MODIFY COLUMN column_name datatype;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Oracle 10G 이상&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE table_name
MODIFY column_name datatype;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-constraints&quot;&gt;SQL Constraints&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SQL 제한 조건은 테이블의 데이터에 대한 특정한 룰을 지정하는 데 사용됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;CREATE TABLE.으로 테이블이 작성 될 때 또는 ALTER TABLE.으로 테이블이 작성된 후에 제한 조건을 지정할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE table_name (
  column1 datatype constraint,
  column2 datatype constraint,
  column3 datatype constraint,
  ....
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL 제약 조건은 테이블의 데이터에 대한 규칙을 지정하는 데 사용됩니다.
제약 조건은 테이블에 들어갈 수있는 데이터 유형을 제한하는 데 사용됩니다. 이렇게하면 표의 데이터 정확성과 신뢰성이 보장됩니다. 제한 조건과 데이터 조치 사이에 위반이 있으면 조치가 중단됩니다.
제약 조건은 열 수준 또는 테이블 수준 일 수 있습니다. 컬럼 레벨 제한 조건은 컬럼에 적용되고 테이블 레벨 제한 조건은 전체 테이블에 적용됩니다.
SQL에서 일반적으로 사용되는 다음 제약 조건이 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NOT NULL - 열이 NULL 값을 가질 수 없음을 보장합니다.
UNIQUE - 열의 모든 값이 서로 다른지 확인합니다.
PRIMARY KEY - NOT NULL과 UNIQUE의 조합. 테이블의 각 행을 고유하게 식별합니다.
FOREIGN KEY - 다른 테이블의 행 / 레코드를 고유하게 식별합니다.
CHECK - 열의 모든 값이 특정 조건을 충족하는지 확인합니다.
DEFAULT - 값이 지정되지 않은 경우 열의 기본값을 설정합니다.
INDEX - 데이터베이스에서 데이터를 매우 신속하게 생성 및 검색하는 데 사용됩니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-not-null-제약-조건&quot;&gt;SQL NOT NULL 제약 조건&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;기본적으로 열은 NULL 값을 포함 할 수 있습니다. NOT NULL 제약 조건은 열이 NULL 값을 허용하지 않도록 강제합니다. 이렇게하면 필드에 항상 값이 포함될 수 있습니다. 즉, 새 레코드를 삽입하거나이 필드에 값을 추가하지 않고 레코드를 업데이트 할 수 없습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다음 SQL은 “ID”, “LastName”및 “FirstName”열이 NULL 값을 허용하지 않도록합니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255) NOT NULL,
  Age int
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-unique-제약-조건&quot;&gt;SQL UNIQUE 제약 조건&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;UNIQUE 제약 조건은 열의 모든 값이 서로 다른지 확인합니다. UNIQUE 및 PRIMARY KEY 제약 조건은 열 또는 열 집합의 고유성을 보장합니다. PRIMARY KEY 제약 조건에는 자동으로 UNIQUE 제약 조건이 있습니다. 그러나 테이블 당 많은 UNIQUE 제약 조건을 가질 수 있지만 테이블 당 하나의 PRIMARY KEY 제약 조건 만 가질 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL은 “Person”테이블을 만들 때 “ID”열에 UNIQUE 제약 조건을 만듭니다.
SQL Server / Oracle / MS 액세스
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL UNIQUE,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;MySQL&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  UNIQUE (ID)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;UNIQUE 제약 조건의 이름을 지정하고 여러 열에 UNIQUE 제약 조건을 정의하려면 다음 SQL 구문을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  CONSTRAINT UC_Person UNIQUE (ID,LastName)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블이 이미 만들어 졌을 때 “ID”열에 UNIQUE 제약 조건을 만들려면 다음 SQL을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ADD UNIQUE (ID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;UNIQUE 제약 조건의 이름을 지정하고 여러 열에 UNIQUE 제약 조건을 정의하려면 다음 SQL 구문을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ADD CONSTRAINT UC_Person UNIQUE (ID,LastName);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;UNIQUE 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
MySQL
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
DROP INDEX UC_Person;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQL Server / Oracle / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
DROP CONSTRAINT UC_Person;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-primary-key제약&quot;&gt;SQL PRIMARY KEY제약&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PRIMARY KEY 제약 조건은 데이터베이스 테이블의 각 레코드를 고유하게 식별합니다. (각 레코드를 식별해 주는 고유한 값으로 보면 된다.)&lt;/li&gt;
  &lt;li&gt;기본 키는 UNIQUE 값을 포함해야하며 NULL 값을 포함 할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;테이블에는 기본 키가 하나만있을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;기본 키는 하나 또는 여러 개의 필드로 구성 될 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 “Person”테이블이 생성 될 때 “ID”열에 PRIMARY KEY를 만듭니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MySQL&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int,
    PRIMARY KEY (ID)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;SQL Server / Oracle / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
    ID int NOT NULL PRIMARY KEY,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;PRIMARY KEY 제약 조건의 이름 지정을 허용하고 여러 열에 대해 PRIMARY KEY 제약 조건을 정의하려면 다음 SQL 구문을 사용합니다. (참고 : 다음 예에서는 오직 하나의 PRIMARY KEY (PK_Person) 만 있습니다. 그러나 기본 키의 VALUE는 두 개의 COLUMNS (ID + 성)로 구성됩니다.)
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  CONSTRAINT PK_Person PRIMARY KEY (ID,LastName)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블이 이미 만들어 졌을 때 “ID”열에 PRIMARY KEY 제약 조건을 만들려면 다음 SQL을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ADD PRIMARY KEY (ID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;PRIMARY KEY 제약 조건의 이름 지정을 허용하고 여러 열에 대해 PRIMARY KEY 제약 조건을 정의하려면 다음 SQL 구문을 사용합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ALTER TABLE 문을 사용하여 PRIMARY KEY를 추가하는 경우 PRIMARY KEY 열은 (테이블이 처음 작성되었을 때) NULL 값을 포함하지 않도록 이미 선언되어 있어야합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;PRIMARY KEY 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
MySQL
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
DROP PRIMARY KEY;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQL Server / Oracle / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
DROP CONSTRAINT PK_Person;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-foreign-key제약&quot;&gt;SQL FOREIGN KEY제약&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FOREIGN KEY는 두 테이블을 서로 연결하는 데 사용되는 키입니다.&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY는 다른 테이블의 PRIMARY KEY를 참조하는 테이블의 필드 (또는 필드 모음)입니다.&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY가 들어있는 테이블을 하위 테이블이라고하고 candidate key가 들어있는 테이블을 참조 된 테이블 또는 상위 테이블이라고합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Persons  table
PersonID	|	LastName	|	FirstName	|	Age
—|—|—|—
1	|	Hansen	|	Ola	|	30
2	|	Svendson	|	Tove	|	23
3	|	Pettersen	|	Kari	|	20&lt;/p&gt;

&lt;p&gt;Orders table
OrderID	|	OrderNumber	|	PersonID
—|—|—
1	|	77895	|	3
2	|	44678	|	3
3	|	22456	|	2
4	|	24562	|	1&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“Orders”테이블의 “PersonID”열이 “Person”테이블의 “PersonID”열을 가리키는 것을 확인하십시오.&lt;/li&gt;
  &lt;li&gt;“Person”테이블의 “PersonID”열은 “Person”테이블의 PRIMARY KEY입니다.&lt;/li&gt;
  &lt;li&gt;“Orders”테이블의 “PersonID”열은 “Orders”테이블의 FOREIGN KEY입니다.&lt;/li&gt;
  &lt;li&gt;FOREIGN KEY 제약 조건은 테이블 간의 연결을 파괴하는 작업을 방지하는 데 사용됩니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;FOREIGN KEY 제약 조건은 또한 가리키는 테이블에 포함 된 값 중 하나 여야하기 때문에 잘못된 데이터가 외부 키 열에 삽입되는 것을 방지합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL문은 “Orders”테이블을 만들 때 “PersonID”열에 FOREIGN KEY를 만듭니다.
MySQL
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Orders (
  OrderID int NOT NULL,
  OrderNumber int NOT NULL,
  PersonID int,
  PRIMARY KEY (OrderID),
  FOREIGN KEY (PersonID) REFERENCES Persons(PersonID)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;SQL Server / Oracle / MS 액세스&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Orders (
  OrderID int NOT NULL PRIMARY KEY,
  OrderNumber int NOT NULL,
  PersonID int FOREIGN KEY REFERENCES Persons(PersonID)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;FOREIGN KEY 제약 조건의 이름 지정 및 여러 열의 FOREIGN KEY 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Orders (
  OrderID int NOT NULL,
  OrderNumber int NOT NULL,
  PersonID int,
  PRIMARY KEY (OrderID),
  CONSTRAINT FK_PersonOrder FOREIGN KEY (PersonID)
  REFERENCES Persons(PersonID)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;“Orders”테이블이 이미 생성 된 경우 “PersonID”열에 FOREIGN KEY 제약 조건을 만들려면 다음 SQL을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Orders
ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;FOREIGN KEY 제약 조건의 이름 지정 및 여러 열의 FOREIGN KEY 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Orders
ADD CONSTRAINT FK_PersonOrder
FOREIGN KEY (PersonID) REFERENCES Persons(PersonID);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;FOREIGN KEY 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
MySQL
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Orders
DROP FOREIGN KEY FK_PersonOrder;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQL Server / Oracle / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Orders
DROP CONSTRAINT FK_PersonOrder;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sql-check-constraint&quot;&gt;SQL CHECK Constraint&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CHECK 제약 조건은 열에 배치 할 수있는 값 범위를 제한하는 데 사용됩니다.&lt;/li&gt;
  &lt;li&gt;단일 열에 CHECK 제한 조건을 정의하면이 열에 대해 특정 값만 허용됩니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;테이블에 CHECK 제한 조건을 정의하면 행의 다른 컬럼에있는 값을 기준으로 특정 컬럼의 값을 제한 할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL은 “Person”테이블이 작성 될 때 “Age”컬럼에 CHECK 제한 조건을 작성합니다. CHECK 제약 조건은 18 세 미만의 사람을 가질 수 없도록 보장합니다.
MySQL
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  CHECK (Age&amp;gt;=18)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQL Server / Oracle / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
    ID int NOT NULL,
    LastName varchar(255) NOT NULL,
    FirstName varchar(255),
    Age int CHECK (Age&amp;gt;=18)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;CHECK 제약 조건의 이름 지정 및 여러 열에 대한 CHECK 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  City varchar(255),
  CONSTRAINT CHK_Person CHECK (Age&amp;gt;=18 AND City='Sandnes')
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블이 이미 생성 된 경우 “Age”열에 CHECK 제약 조건을 만들려면 다음 SQL을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ADD CHECK (Age&amp;gt;=18);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;CHECK 제약 조건의 이름 지정 및 여러 열에 대한 CHECK 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용하십시오.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ADD CONSTRAINT CHK_PersonAge CHECK (Age&amp;gt;=18 AND City='Sandnes');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;CHECK 제약 조건을 삭제하려면 다음 SQL을 사용하십시오.
SQL Server / Oracle / MS 액세스
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
DROP CONSTRAINT CHK_PersonAge;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MySQL&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
DROP CHECK CHK_PersonAge;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;default-constraint&quot;&gt;DEFAULT Constraint&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;DEFAULT 제약 조건은 열의 기본값을 제공하는 데 사용됩니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;다른 값을 지정하지 않으면 기본값이 모든 새 레코드에 추가됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 SQL은 “Person”테이블을 만들 때 “City”열의 DEFAULT 값을 설정합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  City varchar(255) DEFAULT 'Sandnes'
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;DEFAULT 제약 조건은 GETDATE ()와 같은 함수를 사용하여 시스템 값을 삽입하는 데에도 사용할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Orders (
  ID int NOT NULL,
  OrderNumber int NOT NULL,
  OrderDate date DEFAULT GETDATE()
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블이 이미 만들어 졌을 때 “도시”열에 DEFAULT 제약 조건을 만들려면 다음 SQL을 사용하십시오
MySQL
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ALTER City SET DEFAULT 'Sandnes';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SQL Server / MS Access:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ALTER COLUMN City SET DEFAULT 'Sandnes';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Oracle&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
MODIFY City DEFAULT 'Sandnes';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;DEFAULT 제약 조건을 삭제하려면 다음 SQL을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;MySQL&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ALTER City DROP DEFAULT;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Server / Oracle / MS 액세스&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons
ALTER COLUMN City DROP DEFAULT;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;create-index문&quot;&gt;CREATE INDEX문&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;DEX 문은 테이블에 인덱스를 만드는 데 사용됩니다.&lt;/li&gt;
  &lt;li&gt;인덱스는 데이터베이스에서 데이터를 매우 빨리 검색하는 데 사용됩니다. 사용자는 색인을 볼 수 없으며 검색 / 쿼리의 속도를 높이기 위해 사용됩니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;인텍스와 함께 테이블을 갱신하는 것은 테이블만 갱신하는 것 보다 많은 시간을 잡아먹습니다. 따라서 자주 검색 할 열에 대해서만 인덱스를 작성하십시오.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블에 인덱스를 만듭니다. 중복 된 값이 허용됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE INDEX index_name
ON table_name (column1, column2, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;테이블에 고유 인덱스를 작성합니다. 중복 값은 허용되지 않습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE UNIQUE INDEX index_name
ON table_name (column1, column2, ...);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;참고 : 인덱스를 만드는 구문은 데이터베이스마다 다릅니다. 따라서 데이터베이스의 인덱스 작성 구문을 확인하십시오.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DROP INDEX 문은 테이블의 인덱스를 삭제하는 데 사용됩니다.
MS 액세스
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP INDEX index_name ON table_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;SQL Server&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP INDEX table_name.index_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;DB2 / Oracle&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P INDEX index_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;MySQL&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE table_name
DROP INDEX index_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;increment-필드&quot;&gt;INCREMENT 필드&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AUTO INCREMENT 필드 : 자동 증가는 새 레코드가 테이블에 삽입 될 때 고유 번호가 자동으로 생성되도록합니다. 종종 이것은 새로운 레코드가 삽입 될 때마다 자동으로 생성되기를 원하는 기본 키 필드입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MySQL : 다음 SQL 문은 “Person”테이블의 자동 증가 기본 키 필드로 “ID”열을 정의합니다. MySQL은 AUTO_INCREMENT 키워드를 사용하여 자동 증가 기능을 수행합니다. 기본적으로 AUTO_INCREMENT의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int NOT NULL AUTO_INCREMENT,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int,
  PRIMARY KEY (ID)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;AUTO_INCREMENT 시퀀스를 다른 값으로 시작하려면 다음 SQL 문을 사용하십시오.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER TABLE Persons AUTO_INCREMENT=100;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;“Persons”테이블에 새 레코드를 삽입하려면 “ID”열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다).&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL Server구문 : 다음 SQL 문은 “Person”테이블의 자동 증가 기본 키 필드로 “ID”열을 정의합니다. MS SQL Server는 IDENTITY 키워드를 사용하여 자동 증가 기능을 수행합니다. 위의 예에서 IDENTITY의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID int IDENTITY(1,1) PRIMARY KEY,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;팁 : “ID”열이 값 10에서 시작하여 5 씩 증가하도록 지정하려면 IDENTITY (10,5)로 변경하십시오.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;“Persons”테이블에 새 레코드를 삽입하려면 “ID”열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Access : 다음 SQL 문은 “Person”테이블의 자동 증가 기본 키 필드로 “ID”열을 정의합니다. MS Access는 AUTOINCREMENT 키워드를 사용하여 자동 증가 기능을 수행합니다. 기본적으로 AUTOINCREMENT의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE Persons (
  ID Integer PRIMARY KEY AUTOINCREMENT,
  LastName varchar(255) NOT NULL,
  FirstName varchar(255),
  Age int
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;팁 : “ID”열이 값 10에서 시작하여 5 씩 증가하도록 지정하려면 자동 증가를 AUTOINCREMENT (10,5)로 변경하십시오.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;“Persons”테이블에 새 레코드를 삽입하려면 “ID”열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO Persons (FirstName,LastName)
VALUES ('Lars','Monsen');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;오라클 : 오라클에서는 코드가 좀 더 까다 롭습니다. 시퀀스 객체로 자동 증가 필드를 만들어야합니다 (이 객체는 숫자 시퀀스를 생성합니다).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE SEQUENCE seq_person
MINVALUE 1
START WITH 1
INCREMENT BY 1
CACHE 10;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위의 코드는 seq_person이라는 시퀀스 객체를 생성합니다. seq_person은 1부터 시작하여 1 씩 증가합니다. 또한 성능을 위해 최대 10 개의 값을 캐시합니다. 캐시 옵션은 더 빠른 액세스를 위해 얼마나 많은 순서 값이 메모리에 저장 될지 지정합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;“Persons”테이블에 새 레코드를 삽입하려면 nextval 함수를 사용해야합니다 (이 함수는 seq_person 시퀀스에서 다음 값을 검색합니다).
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO Persons (ID,FirstName,LastName)
VALUES (seq_person.nextval,'Lars','Monsen');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-date&quot;&gt;SQL Date&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;날짜 작업을 할 때 가장 어려운 부분은 삽입하려는 날짜의 형식이 데이터베이스의 날짜 열 형식과 일치하는지 확인하는 것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;MySQL 에는 데이터베이스에 날짜 또는 날짜 / 시간 값을 저장하기위한 다음 데이터 유형이 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DATE - YYYY-MM-DD 형식
DATETIME - 형식 : YYYY-MM-DD HH : MI : SS
TIMESTAMP - 형식 : YYYY-MM-DD HH : MI : SS
YEAR - YYYY 또는 YY 형식
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;SQL Server 에는 데이터베이스에 날짜 또는 날짜 / 시간 값을 저장하기위한 다음 데이터 형식이 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DATE - YYYY-MM-DD 형식
DATETIME - 형식 : YYYY-MM-DD HH : MI : SS
SMALLDATETIME - 형식 : YYYY-MM-DD HH : MI : SS
TIMESTAMP - 형식 : 고유 번호
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다음 “Orders” 테이블이 있다고 가정합니다.
OrderId	|	ProductName	|	OrderDate
—|—|—
1	|	Geitost	|	2008-11-11
2	|	Camembert Pierrot	|	2008-11-09
3	|	Mozzarella di Giovanni	|	2008-11-11
4	|	Mascarpone Fabioli	|	2008-10-29&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;위 표에서 OrderDate가 “2008-11-11”인 레코드를 선택하려고합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM Orders WHERE OrderDate='2008-11-11'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 “주문”테이블이 다음과 같이 보입니다 ( “주문일”열의 시간 구성 요소에 주목하십시오).
OrderId	|	ProductName	|	OrderDate
—|—|—
1	|	Geitost	|	2008-11-11 13:23
2	|	Camembert Pierrot	|	2008-11-09 15:45
3	|	Mozzarella di Giovanni	|	2008-11-11 11:12
4	|	Mascarpone Fabioli	|	2008-10-29 14:56&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;위와 같은 SELECT 문을 사용하는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM Orders WHERE OrderDate='2008-11-11'&lt;/code&gt; 우리는 결과를 얻지 못할 것이다! 이는 쿼리가 시간 부분이없는 날짜 만 찾고 있기 때문입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;팁 : 검색어를 간단하고 쉽게 유지하려면 날짜에 시간 구성 요소를 허용하지 마십시오!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-create-view문&quot;&gt;SQL CREATE VIEW문&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL에서 뷰는 SQL 문의 결과 세트를 기반으로하는 가상 테이블입니다.&lt;/li&gt;
  &lt;li&gt;뷰에는 실제 테이블과 마찬가지로 행과 열이 포함됩니다. 뷰의 필드는 데이터베이스에있는 하나 이상의 실제 테이블의 필드입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SQL 함수, WHERE 및 JOIN 문을 뷰에 추가하고 데이터가 하나의 단일 테이블에서 온 것처럼 데이터를 표시 할 수 있습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;참고 : 보기에는 항상 최신 데이터가 표시됩니다! 데이터베이스 엔진은 사용자가 뷰를 쿼리 할 때마다 뷰의 SQL 문을 사용하여 데이터를 다시 작성합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;“현재 제품 목록”보기에는 “제품”테이블의 모든 활성 제품 (중단되지 않은 제품)이 나열됩니다. 뷰는 다음 SQL로 작성됩니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE VIEW [Current Product List] AS
SELECT ProductID, ProductName
FROM Products
WHERE Discontinued = No;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;그런 다음 다음과 같이 뷰를 쿼리 할 수 ​​있습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM [Current Product List];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Northwind 샘플 데이터베이스의 또 다른보기는 “제품”테이블의 모든 제품을 평균 단가보다 높은 단가로 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE VIEW [Products Above Average Price] AS
SELECT ProductName, UnitPrice
FROM Products
WHERE UnitPrice &amp;gt; (SELECT AVG(UnitPrice) FROM Products);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위의보기는 다음과 같이 쿼리 할 수 ​​있습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM [Products Above Average Price];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Northwind 데이터베이스의 다른보기는 1997 년 각 범주의 총 ​​판매량을 계산합니다.이보기는 “1997 년 제품 판매”라는 다른보기에서 해당 데이터를 선택합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE VIEW [Category Sales For 1997] AS
SELECT DISTINCT CategoryName, Sum(ProductSales) AS CategorySales
FROM [Product Sales for 1997]
GROUP BY CategoryName;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위의보기는 다음과 같이 쿼리 할 수 ​​있습니다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM [Category Sales For 1997];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;쿼리에 조건을 추가 할 수도 있습니다. “음료수”카테고리에 대해서만 총 판매를 봅시다.&lt;/p&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * FROM [Category Sales For 1997]
WHERE CategoryName = 'Beverages';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-view-update&quot;&gt;SQL VIEW UPDATE&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;기본 사용법
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE OR REPLACE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;다음 예시는 위의 “현재 제품 목록” VIEW에 “범주”열을 추가합니다. 다음 SQL로 뷰를 업데이트합니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE OR REPLACE VIEW [Current Product List] AS
SELECT ProductID, ProductName, Category
FROM Products
WHERE Discontinued = No;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;VIEW 삭제 : 다음 SQL 명령으로 VIEW를 삭제할 수 있습니다.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP VIEW view_name;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-injection-추가공부-필요&quot;&gt;SQL INJECTION (추가공부 필요)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SQL INJECTION은 데이터베이스를 파괴 할 수있는 코드 삽입 기술입니다.&lt;/li&gt;
  &lt;li&gt;SQL INJECTION은 가장 일반적인 웹 해킹 기술 중 하나입니다.&lt;/li&gt;
  &lt;li&gt;SQL INJECTION은 웹 페이지 입력을 통해 SQL 문에 악의적 인 코드를 배치합니다.&lt;/li&gt;
  &lt;li&gt;SQL 인젝션은 대개 사용자에게 username / userid와 같은 입력을 요청할 때 발생하며 이름 / ID 대신 사용자가 알지 못하게 데이터베이스에서 실행할 SQL 문을 제공 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sql-hosting&quot;&gt;SQL Hosting&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;웹 사이트에서 데이터베이스의 데이터를 저장하고 검색 할 수있게하려면 웹 서버가 SQL 언어를 사용하는 데이터베이스 시스템에 액세스 할 수 있어야합니다.&lt;/li&gt;
  &lt;li&gt;웹 서버가 ISP (Internet Service Provider)에 의해 호스팅되는 경우 SQL 호스팅 계획을 찾아야합니다.&lt;/li&gt;
  &lt;li&gt;가장 일반적인 SQL 호스팅 데이터베이스는 MS SQL Server, Oracle, MySQL 및 MS Access입니다.&lt;/li&gt;
  &lt;li&gt;Microsoft의 SQL Server는 트래픽이 많은 데이터베이스 중심 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어입니다. SQL Server는 강력하고 완벽한 SQL 데이터베이스 시스템입니다.&lt;/li&gt;
  &lt;li&gt;오라클은 트래픽이 많은 데이터베이스 중심 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어이기도합니다.&lt;/li&gt;
  &lt;li&gt;MySQL은 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어이기도합니다. MySQL은 값 비싼 Microsoft 및 Oracle 솔루션 대신 저렴한 방법입니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>-Yoda</name></author><summary type="html">SQL 기본 문법 SQL이란 무엇인가? SQL은 구조화 된 쿼리 언어 SQL을 사용하면 데이터베이스에 액세스하고 조작 할 수 있습니다. SQL은 ANSI (American National Standards Institute) 표준입니다. 웹사이트에서 SQL 사용 데이터베이스의 데이터를 보여주는 웹 사이트를 구축하려면 다음이 필요합니다. RDBMS 데이터베이스 프로그램 (예 : MS Access, SQL Server, MySQL) PHP 또는 ASP와 같은 서버 측 스크립팅 언어가 필요합니다. SQL을 사용하여 원하는 데이터를 얻을 수 있습니다. HTML / CSS를 사용하여 페이지의 스타일을 지정합니다. RDBMS란? RDBMS는 관계형 데이터베이스 관리 시스템의 약자입니다. RDBMS는 SQL과 MS SQL Server, IBM DB2, Oracle, MySQL 및 Microsoft Access와 같은 모든 최신 데이터베이스 시스템의 기초입니다. RDBMS의 데이터는 테이블이라는 데이터베이스 오브젝트에 저장됩니다. 테이블은 관련 데이터 항목의 모음이며 열과 행으로 구성됩니다. 모든 테이블은 필드라는 더 작은 엔티티로 나뉩니다. Customers 테이블의 필드는 CustomerID, CustomerName, ContactName, Address, City, PostalCode 및 Country로 구성됩니다. 필드는 테이블의 모든 레코드에 대한 특정 정보를 유지 관리하도록 설계된 테이블의 열입니다. 레코드(행) : 레코드는 테이블에있는 개별 항목입니다. 예를 들어, 위의 Customers 테이블에는 91 개의 레코드가 있습니다. 레코드는 테이블의 가로 엔티티입니다. 컬럼(열) : 컬럼은 테이블의 특정 필드와 연관된 모든 정보를 포함하는 테이블의 수직 엔티티입니다. SQL문 기본 문법 SQL 키워드는 대소 문자를 구분하지 않습니다. select는 SELECT와 같습니다. 일부 데이터베이스 시스템에서는 각 SQL 문의 끝에 세미콜론이 필요합니다. 세미콜론은 데이터베이스 시스템에서 각 SQL 문을 분리하여 서버에 대한 동일한 호출에서 둘 이상의 SQL 문을 실행할 수 있도록하는 표준 방법입니다. 주요 핵심 SQL명령어 SELECT - 데이터베이스에서 데이터를 추출합니다. UPDATE - 데이터베이스의 데이터를 업데이트합니다. DELETE - 데이터베이스에서 데이터를 삭제합니다. INSERT INTO - 새로운 데이터를 데이터베이스에 삽입합니다. CREATE DATABASE - 새 데이터베이스를 만듭니다. ALTER DATABASE - 데이터베이스를 수정합니다. CREATE TABLE - 새 테이블을 만듭니다. ALTER TABLE - 테이블을 수정합니다. DROP TABLE - 테이블을 삭제합니다. CREATE INDEX - 색인 (검색 키)을 작성합니다. DROP INDEX - 색인을 삭제합니다. SQL SELECT문 SELECT 문은 데이터베이스에서 데이터를 선택하는 데 사용됩니다.리턴 된 데이터는 결과 세트라고하는 결과 테이블에 저장됩니다. SELECT문 사용법 SELECT 필드이름, 필드이름, ... FROM 테이블 이름 전체 필드 선택 SELECT * FROM table_name; SQL SELECT DISTINCT문 SELECT DISTINCT는 고유 한 (다른) 값만 리턴하는 데 사용됩니다. 테이블 내에서 열은 종종 많은 중복 값을 포함합니다. 때로는 서로 다른 (뚜렷한) 값만 나열하려고합니다. SELECT DISTINCT.은 고유 한 (다른) 값만 리턴하는 데 사용됩니다. (중복값 제거하고 고유한 값들만 얻어내는 명령문) 기본 사용법 SELECT DISTINCT 필드이름, 필드이름, ... FROM 테이블이름 다음은 해당 필드의 고유한 레코드 값의 수를 나열한다. SELECT COUNT(DISTINCT 필드이름) FROM 테이블이름; SQL WHERE절 WHERE 절은 레코드를 필터링하는 데 사용됩니다. WHERE 절은 지정된 조건을 충족하는 레코드 만 추출하는 데 사용됩니다. 기본 사용법 SELECT 필드이름, 필드이름, ... FROM 테이블이름 WHERE 조건; 사용예시1 : Customers 테이블에서 Mexico 국가의 모든 고객을 선택 SELECT * FROM Customers WHERE country='Mexico'; SQL은 텍스트 값에 대해 작은 따옴표를 사용해야합니다 (대부분의 데이터베이스 시스템은 큰 따옴표도 허용합니다). 그러나 숫자 필드는 따옴표로 묶지 않아야합니다. 다음 사용예시는 전체 필드중에서 CustomersID값이 1인 값을 가져옵니다. SELECT * FROM Customers WHERE CustomerID=1; WHERE 절에 있는 연산자 Operator Description = Equal &amp;lt;&amp;gt; Not equal. Note: In some versions of SQL this operator may be written as != &amp;gt; Greater than &amp;lt; Less than &amp;gt;= Greater than or equal &amp;lt;= Less than or equal BETWEEN Between an inclusive range LIKE Search for a pattern IN To specify multiple possible values for a column SQL AND, OR 및 NOT 연산자 WHERE 절은 AND, OR 및 NOT 연산자와 결합 할 수 있습니다. AND 및 OR 연산자는 둘 이상의 조건에 따라 레코드를 필터링하는 데 사용됩니다. AND로 구분 된 모든 조건이 TRUE이면 AND 연산자는 레코드를 표시합니다. OR로 구분 된 조건이 TRUE 인 경우 OR 연산자는 레코드를 표시합니다. NOT 연산자는 조건이 참이 아닌 경우 레코드를 표시합니다. 기본 사용법 SELECT 필드이름, 필드이름, ... FROM 테이블이름 WHERE 조건 AND 조건 AND 조건...; SELECT 필드이름, 필드이름, ... FROM 테이블이름 WHERE 조건 OR 조건 OR 조건...; SELECT 필드이름, 필드이름, ... FROM 테이블이름 WHERE NOT 조건...; AND, OR 및 NOT 결합 AND, OR 및 NOT 연산자를 결합 할 수도 있습니다.다음 SQL 문은 country가 “Germany”이고 도시가 “Berlin”또는 “München”(복잡한 표현식을 형성하기 위해 괄호를 사용해야 함) 인 “Customers”의 모든 필드를 선택합니다. SELECT * FROM Customers WHERE Country='Germany' AND (City='Berlin' OR City='München'); 다음 SQL 문은 country가 “Germany”가 아니며 “USA”가 아닌 “Customers”의 모든 필드를 선택합니다. SELECT * FROM Customers WHERE NOT Country='Germany' AND NOT Country='USA'; SQL ORDER BY 키워드 ORDER BY 키워드는 결과 집합을 오름차순 또는 내림차순으로 정렬하는 데 사용됩니다. ORDER BY 키워드는 기본적으로 레코드를 오름차순으로 정렬합니다. 내림차순으로 레코드를 정렬하려면 DESC 키워드를 사용하십시오. 기본 사용법 SELECT 필드이름, 필드이름, ... FROM 테이블이름 ORDER BY 필드이름, 필드이름, ... ASC|DESC; 다음 SQL 문은 “고객”테이블의 모든 고객을 “국가”열로 정렬하여 선택합니다. SELECT * FROM Customers ORDER BY Country; 다음 SQL 문은 “고객”테이블의 모든 고객을 “국가”열로 역순으로 정렬하여 선택합니다. SELECT * FROM Customers ORDER BY country DESC; 다음 SQL 문은 “Customers”테이블의 모든 고객을 “Country”및 “CustomerName”열로 정렬하여 선택합니다. (Country로 정렬한 다음 CustomerName으로 다시 정렬) SELECT * FROM Customers ORDER BY Country, CustomerName; 다음 SQL 문은 “Customers”테이블의 모든 고객을 “Country”로 오름차순으로 정렬하고 “CustomerName”열로 내림차순으로 정렬합니다. (Country로 오름차순 정렬후 CustomerName으로 다시 내림차순으로 정렬) SELECT * FROM Customers ORDER BY Country ASC, CustomerName DESC; SQL INSERT INTO문 INSERT INTO 문은 테이블에 새 레코드를 삽입하는 데 사용됩니다. INSERT INTO 문을 작성하는 첫 번째 방법 : 삽입 할 열 이름과 값을 모두 지정합니다. INSERT INTO table_name (column1, column2, column3, ...) VALUES (value1, value2, value3, ...); 표의 모든 열에 값을 추가하는 경우 SQL 조회에서 열 이름을 지정할 필요가 없습니다. 그러나 값의 순서가 테이블의 열과 동일한 순서인지 확인하십시오. INSERT INTO 구문은 다음과 같습니다. INSERT INTO table_name VALUES (value1, value2, value3, ...); 다음 SQL 문은 새 레코드를 삽입하지만 “CustomerName”, “City”및 “Country”열에 만 데이터를 삽입합니다 (CustomerID는 자동으로 업데이트됩니다). INSERT INTO Customers (CustomerName, City, Country) VALUES ('Cardinal', 'Stavanger', 'Norway'); SQL NULL 값 NULL값이란? : NULL 값이있는 필드는 값이없는 필드입니다. 테이블의 필드가 선택적이면이 필드에 값을 추가하지 않고 새 레코드를 삽입하거나 레코드를 업데이트 할 수 있습니다. 그런 다음 필드는 NULL 값으로 저장됩니다. NULL값에 대하여 잘 설명되어 있는 참고할만한 블로그 NULL값이 0 이나 혹은 공백으로 되어있는 필드와는 다르다는 것을 이해하는 것이 중요합니다. 널 값이 있는 필드는 레코드가 생성되는 동안 빈공간으로 남겨져 있다는 것을 말합니다. IS NULL 연산자와 IS NOT NULL 연산자를 통해 NULL 값을 테스트 할 수 있습니다. 다음 SQL.은 IS NULL 연산자를 사용하여 주소가없는 모든 값을 나열합니다. SELECT LastName, FirstName, Address FROM Persons WHERE Address IS NULL; 다음 SQL 문은 IS NOT NULL 연산자를 사용하여 주소가있는 모든 사람을 나열합니다. SELECT LastName, FirstName, Address FROM Persons WHERE Address IS NOT NULL; SQL UPDATE문 UPDATE 문은 테이블의 기존 레코드를 수정하는 데 사용됩니다. 기본 사용법 UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; 테이블의 레코드를 업데이트 할 때에는 UPDATE 문에서 WHERE 절을 확인하십시오. WHERE 절은 갱신해야하는 레코드를 지정합니다. WHERE 절을 생략하면 테이블의 모든 레코드가 업데이트됩니다! UPDATE Customers SET ContactName='Juan'; 한번에 여러 레코드를 업데이트 할 수도 있습니다. 업데이트 될 레코드 수를 결정하는 것은 WHERE 절입니다. 다음 SQL 문은 country가 “Mexico”인 모든 레코드에 대해 연락처 이름을 “Juan”으로 업데이트합니다. UPDATE Customers SET ContactName='Juan' WHERE Country='Mexico'; SQL DELETE문 DELETE 문은 테이블의 기존 레코드를 삭제하는 데 사용됩니다. 기본 사용법 DELETE FROM table_name WHERE condition; 다음 SQL문은 : Customers; 테이블에서 고객 “Alfreds Futterkiste”를 제거합니다. DELETE FROM Customers WHERE CustomerName='Alfreds Futterkiste'; 아래의 명령을 통해, 테이블을 제거하지 않고 테이블의 모든 행을 제거 할 수 있습니다. 이것은 테이블 구조, 속성 및 인덱스가 손상되지 않는다는 것을 의미합니다. DELETE FROM table_name; 또는 DELETE * FROM table_name; SQL TOP, LIMIT 또는 ROWNUM절 SELECT TOP 절은 리턴 할 레코드 수를 지정하는 데 사용됩니다. SELECT TOP 절은 수천 개의 레코드가있는 큰 테이블에서 유용합니다. 많은 수의 레코드를 반환하면 성능에 영향을 줄 수 있습니다. 주의할 점은 모든 데이터베이스 시스템이 SELECT TOP 절을 지원하는 것은 아니라는 것 입니다. MySQL은 제한된 수의 레코드를 선택하기 위해 LIMIT 절을 지원하고 Oracle은 ROWNUM을 사용합니다. 기본 사용법 SQL Server / MS 액세스 구문 : SELECT TOP number|percent column_name(s) FROM table_name WHERE condition; SELECT column_name(s) FROM table_name WHERE condition LIMIT number; SELECT column_name(s) FROM table_name WHERE ROWNUM &amp;lt;= number; 다음 SQL 문은 “Customers”테이블에서 처음 세 개의 레코드를 선택합니다. SELECT TOP 3 * FROM Customers; 다음 SQL 문은 LIMIT 절을 사용하는 동일한 예제를 보여줍니다. SELECT * FROM Customers LIMIT 3; 다음 SQL 문은 ROWNUM을 사용하는 동일한 예제를 보여줍니다. SELECT * FROM Customers WHERE ROWNUM &amp;lt;= 3; 다음 SQL 문은 국가가 “Germany”인 “Customers”테이블에서 처음 세 개의 레코드를 선택합니다. SELECT TOP 3 * FROM Customers WHERE Country='Germany'; 다음 SQL 문은 LIMIT 절을 사용하는 동일한 예제를 보여줍니다. SELECT * FROM Customers WHERE Country='Germany' LIMIT 3; 다음 SQL 문은 ROWNUM을 사용하는 동일한 예제를 보여줍니다. SELECT * FROM Customers WHERE Country='Germany' AND ROWNUM &amp;lt;= 3; SQL MIN() 및 MAX()합수 MIN () 함수는 선택된 컬럼의 가장 작은 값을 리턴합니다. SELECT MIN(column_name) FROM table_name WHERE condition; MAX () 함수는 선택된 컬럼의의 가장 큰 값을 반환합니다. SELECT MAX(column_name) FROM table_name WHERE condition; 다음 SQL 문은 가장 저렴한 제품의 가격을 찾습니다. SELECT MIN(Price) AS SmallestPrice FROM Products; 다음 SQL 문은 가장 비싼 제품의 가격을 찾습니다. SELECT MAX(Price) AS LargestPrice FROM Products; SQL COUNT(), AVG()및 SUM() 함수 COUNT () 함수는 지정된 기준과 일치하는 행 수를 반환합니다. SELECT COUNT(column_name) FROM table_name WHERE condition; AVG () 함수는 숫자 열의 평균값을 반환합니다. SELECT AVG(column_name) FROM table_name WHERE condition; SUM () 함수는 숫자 열의 총 합계를 반환합니다. SELECT SUM(column_name) FROM table_name WHERE condition; SQL LIKE연산자 LIKE 연산자는 WHERE 절에서 열의 지정된 패턴을 검색하는 데 사용됩니다. LIKE 연산자와 함께 사용되는 두 개의 와일드 카드가 있습니다. (MS Access는 밑줄 _ 대신 물음표 ?를 사용합니다.) %백분율 기호는 0, 1 또는 복수 문자를 나타냅니다. _밑줄은 한 문자를 나타냅니다. 기본 사용법 SELECT column1, column2, ... FROM table_name WHERE columnN LIKE pattern; AND 또는 OR 연산자를 사용하여 여러 조건을 결합 할 수도 있습니다. 몇가지 예시 LIKE Operator Description WHERE CustomerName LIKE a% Finds any values that starts with “a” WHERE CustomerName LIKE %a Finds any values that ends with “a” WHERE CustomerName LIKE %or% Finds any values that have “or” in any position WHERE CustomerName LIKE _r% Finds any values that have “r” in the second position WHERE CustomerName LIKE a_%_% Finds any values that starts with “a” and are at least 3 characters in length WHERE ContactName LIKE a%o Finds any values that starts with “a” and ends with “o” SQL 와일드 카드 문자 와일드 카드 문자는 문자열의 다른 문자를 대체하는 데 사용됩니다. 와일드 카드 문자는 SQL LIKE 연산자 와 함께 사용됩니다 . LIKE 연산자는 WHERE 절에서 열의 지정된 패턴을 검색하는 데 사용됩니다. LIKE 연산자와 함께 사용되는 두 개의 와일드 카드가 있습니다. (MS Access는 밑줄 _ 대신 물음표 ?를 사용합니다.) % 백분율 기호는 0, 1 또는 복수 문자를 나타냅니다. _ 밑줄은 한 문자를 나타냅니다. 다음 SQL 문은 City가 “ber”로 시작하는 모든 고객을 선택합니다. SELECT * FROM Customers WHERE City LIKE 'ber%'; SQL IN 연산자 IN 연산자를 사용하여 WHERE 절에 여러 값을 지정할 수 있습니다. IN 연산자는 여러 OR 조건의 줄임말입니다. 기본 사용법 SELECT column_name(s) FROM table_name WHERE column_name IN (value1, value2, ...); 또는 SELECT column_name(s) FROM table_name WHERE column_name IN (SELECT STATEMENT); 다음 SQL 문은 “Germany”, “France”및 “UK”에있는 모든 고객을 선택합니다. SELECT * FROM Customers WHERE Country IN ('Germany', 'France', 'UK'); 다음 SQL 문은 “Germany”, “France”또는 “UK”에 있지 않은 모든 고객을 선택합니다. SELECT * FROM Customers WHERE Country NOT IN ('Germany', 'France', 'UK'); 다음 SQL 문은 공급 업체와 동일한 국가의 모든 고객을 선택합니다. ELECT * FROM Customers WHERE Country IN (SELECT Country FROM Suppliers); SQL BETWEEN연산자 BETWEEN 연산자는 주어진 범위 내의 값을 선택합니다. 값은 숫자, 텍스트 또는 날짜 일 수 있습니다. BETWEEN 연산자는 시작과 끝 값이 포함됩니다. 기본 사용법 SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2; 다음 SQL 문은 가격이 10과 20 사이 인 모든 제품을 선택합니다. SELECT * FROM Products WHERE Price BETWEEN 10 AND 20; 다음 SQL 문은 가격이 10과 20 사이 인 모든 제품을 선택합니다. CategoryID가 1,2 또는 3 인 제품을 표시하지 않습니다. SELECT * FROM Products WHERE (Price BETWEEN 10 AND 20) AND NOT CategoryID IN (1,2,3); 다음 SQL.은 ‘Carnarvon Tigers’와 ‘Mozzarella di Giovanni’사이에 ProductName이있는 모든 제품을 선택합니다. SELECT * FROM Products WHERE ProductName BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni' ORDER BY ProductName; 다음 SQL 문은 ProductName이 ‘Carnarvon Tigers’및 ‘Mozzarella di Giovanni’가 아닌 모든 제품을 선택합니다. SELECT * FROM Products WHERE ProductName NOT BETWEEN 'Carnarvon Tigers' AND 'Mozzarella di Giovanni' ORDER BY ProductName; 다음 SQL 문은 OrderDate BETWEEN ‘04 -July-1996 ‘및 ‘09-Junly-1996’이있는 모든 주문을 선택합니다. SELECT * FROM Orders WHERE OrderDate BETWEEN #07/04/1996# AND #07/09/1996#; SQL Aliases SQL (Aliases)별칭은 테이블 또는 테이블의 열에 임시 이름을 지정하는 데 사용됩니다. 앨리어스는 종종 컬럼 이름을 읽기 쉽게하기 위해 사용됩니다. 별명은 조회 기간 동안 만 존재합니다. 컬럼 Aliase 지정예시 SELECT column_name AS alias_name FROM table_name; 테이블 Aliase 지정예시 SELECT column_name(s) FROM table_name AS alias_name; 다음 SQL 문은 CustomerID 열과 CustomerName 열의 두 가지 별칭을 만듭니다. SELECT CustomerID as ID, CustomerName AS Customer FROM Customers; 다음 SQL 문은 CustomerName 열과 ContactName 열의 두 가지 별칭을 만듭니다. 참고 : 별칭 이름에 공백이 포함되어 있으면 큰 따옴표 또는 대괄호가 필요합니다. SELECT CustomerName AS Customer, ContactName AS [Contact Person] FROM Customers; 다음 SQL 문은 네 개의 열 (Address, PostalCode, City 및 Country)을 결합하는 “Address”라는 별칭을 만듭니다. (각 필드의 결합의 경우 결합될 양식을 ‘,’ 이나 ‘ ‘ 과 같이 만들어 줄 수 있다.) SELECT CustomerName, Address + ', ' + PostalCode + ' ' + City + ', ' + Country AS Address FROM Customers; 참고 : 위의 SQL 문을 MySQL에서 작동 시키려면 다음을 사용하십시오. SELECT CustomerName, CONCAT(Address,', ',PostalCode,', ',City,', ',Country) AS Address FROM Customers; 다음 SQL.은 CustomerID = 4 (Around the Horn) 인 고객의 모든 주.을 선택합니다. “Customers”및 “Orders”테이블을 사용하고 각각 “c”및 “o”테이블 별칭을 부여합니다 (여기서 별칭을 사용하여 SQL을 더 짧게 만듭니다). SELECT o.OrderID, o.OrderDate, c.CustomerName FROM Customers AS c, Orders AS o WHERE c.CustomerName=&quot;Around the Horn&quot; AND c.CustomerID=o.CustomerID; Aliase는 다음과 같은 경우에 유용합니다. 쿼리에 두 개 이상의 테이블이 관련되어 있습니다. 함수는 쿼리에서 사용됩니다. 열 이름이 크거나 매우 읽을 수 없습니다. 두 개 이상의 열이 결합되었습니다. JOIN JOIN 절은 두 개 이상의 테이블에있는 행을 결합하는 데 사용됩니다. 수학의 집합 처럼 조건을 두고 그 조건 안에서 원하는 자료를 선택하는 것 기본 사용법 Oders OrderID CustomerID OrderDate 10308 2 1996-09-18 10309 37 1996-09-19 10310 77 1996-09-20 Customers CustomerID CustomerName ContactName Country 1 Alfreds Futterkiste Maria Anders Germany 2 Ana Trujillo Emparedados y helados Ana Trujillo Mexico 3 Antonio Moreno Taquería Antonio Moreno Mexico Orders테이블의 CustomerID열은 Customers테이블의 CustomerID를 나타냅니다. 위의 두 테이블 사이의 공유하고 있는 정보는 CustomerID열 입니다. 이와같이 같은 정보를 통하여 위의 두 테이블의 공통된 Value를 가지는 레코드를 골라내는 SQL문장을 만들어 낼 수 있습니다. SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate FROM Orders INNER JOIN Customers ON Orders.CustomerID=Customers.CustomerID; INNER JOIN문에서 Orders의 CustomersID와 Customers의 CustomersID가 같은 값을 찾아내고 같은 값을 가지는 행의 정보를 두 테이블에서 가져와 SELECT문에서 산출한다. 다양한 유형의 SQL JOIN (INNER) JOIN : 두 테이블에서 값이 일치하는 레코드를 반환합니다. LEFT (OUTER) JOIN : 왼쪽 테이블에서 모든 레코드를 반환하고 오른쪽 테이블에서 일치하는 레코드를 반환합니다. RIGHT (OUTER) JOIN : 오른쪽 테이블에서 모든 레코드를 반환하고 왼쪽 테이블에서 일치하는 레코드를 반환합니다. FULL (OUTER) JOIN : 왼쪽 또는 오른쪽 테이블에 일치하는 항목이 있으면 모든 레코드를 반환합니다. SQL INNER JOIN 키워드 INNER JOIN 키워드는 두 표에서 모두 일치하는 값을 가진 레코드를 선택합니다. 기본 사용법 SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; 다음과 같이 놓고 보면 좀더 이해하기 쉽다. SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name = table2.column_name; 해당 컬럼은 FROM table1 과 table2 의 colum_name INNER JOIN한 데이터를 기준으로 해서 자료를 가져온다. INNER JOIN 키워드는 비교대상인 컬럼간에 일치하는 모든 행을 선택합니다. ‘주문 테이블의 비교대상컬럼과 ‘고객’테이블의 비교대상컬럼에 일치하는 레코드가 없을경우 아무런 레코드도 표시되지 않습니다. 다음 SQL문은 Customers정보와 Shippers정보가 있는 Orders 테이블을 선택합니다. SELECT Orders.OrderID, Customers.CustomerName, Shippers.ShipperName FROM ((Orders INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID) INNER JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID); SQL LEFT JOIN키워드 LEFT JOIN키워드는 왼쪽 테이블의 모든 레코드와 오른쪽테이블의 일치 레코들을 반환합니다. 일치하는 것이 없으면 오른쪽 테이블의 정보는 모두 Null값이 됩니다. 기본 사용법 SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name = table2.column_name; 일부 데이터베이스에서는 LEFT JOIN을 LEFT OUTER JOIN이라고합니다. 다음 SQL문은 고객과 주문번호를 선택하여 나타냅니다. LEFT JOIN 키워드는 오른쪽 테이블 (Orders)에 일치하는 항목이 없더라도 왼쪽 테이블 (Customers)의 모든 레코드를 반환합니다.(일치하는 CustomersID값을 기준으로 Orders.OrdesID정보를 가져옵니다. 일치하는 CustomersID가 없는 Customers테이블의 값들은 Orders.OrdesID에 Null이 할당됩니다.) SELECT Customers.CustomerName, Orders.OrderID FROM Customers LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID ORDER BY Customers.CustomerName; SQL RIGHT JOIN키워드 RRIGHT JOIN키워드는 오른쪽 테이블의 모든 레코드와 외쪽테이블의 일치 레코들을 반환합니다. 일치하는 것이 없으면 외쪽 테이블의 정보는 모두 Null값이 됩니다. RIGHT JOIN 키워드는 왼쪽 테이블 (Orders)에 일치하는 항목이 없더라도 오른쪽 테이블 (Employees)의 모든 레코드를 반환합니다. 다음 SQL문은 모든 직원 및 주문한 모든 주문을 반환합니다. SELECT Orders.OrderID, Employees.LastName, Employees.FirstName FROM Orders RIGHT JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID ORDER BY Orders.OrderID; SQL FULL OUTER JOIN키워드 FULL OUTER JOIN 키워드는 왼쪽 (table1) 또는 오른쪽 (table2) 테이블 레코드가 일치 할 때 모든 레코드를 리턴합니다. FULL OUTER JOIN은 잠재적으로 매우 큰 결과 집합을 반환 할 수 있습니다! 기본 사용법 SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name = table2.column_name; 다음 SQL문은 모든 고객의 이름과 모든 주믄을 선택합니다. SELECT Customers.CustomerName, Orders.OrderID FROM Customers FULL OUTER JOIN Orders ON Customers.CustomerID=Orders.CustomerID ORDER BY Customers.CustomerName; FULL OUTER JOIN 키워드는 왼쪽 테이블 (Customers)의 모든 행과 오른쪽 테이블 (Orders)의 모든 행을 리턴합니다. ‘주문’에 일치하지 않는 행이 ‘고객’에 있거나 ‘고객’에 일치하지 않는 행이 ‘주문’에있는 경우 해당 행이 함께 표시됩니다. SELF JOIN문 SELF JOIN문은 조인문이지만 자기 자신과 결합합니다. 실제로 자기 자신과의 결합이 아니라 그렇게 하는 것과 같은 효과를 가졌다는 겄을 말한다. 같은 테이블 안에서 여러가지 컬럼을 조건으로 하여 결과값을 가져오고 싶을 때 사용합니다. 기본 사용법 SELECT column_name(s) FROM table1 T1, table1 T2 WHERE condition; 다음 SQL문은 같은 도시에서 온 고객들을 선택합니다. SELECT A.CustomerName AS CustomerName1, B.CustomerName AS CustomerName2, A.City FROM Customers A, Customers B WHERE A.CustomerID &amp;lt;&amp;gt; B.CustomerID AND A.City = B.City ORDER BY A.City; SQL UNION연산자 UNION 연산자는 두 개 이상의 SELECT 문의 결과를 결합하는 데 사용됩니다. UNION 연산자 사용조건 UNION 내의 각 SELECT 문은 같은 수의 열을 가져야합니다. 열은 유사한 데이터 형식을 가져야합니다. 각 SELECT 문의 열은 같은 순서로 있어야합니다 기본 사용법 SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2; UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 UNION ALL을 사용하십시오. SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2; 결과 집합의 열 이름은 일반적으로 UNION의 첫 번째 SELECT 문의 열 이름과 동일합니다. 다음 SQL문은 “Customers”W “Suppliers”에서 모든 다른 독일 도시 (유일한 값만)를 선택합니다. SELECT City, Country FROM Customers WHERE Country='Germany' UNION SELECT City, Country FROM Suppliers WHERE Country='Germany' ORDER BY City; 다음 SQL문은 “Customers”W “Suppliers”에서 모든 독일 도시 (중복 값 포함)를 선택합니다. SELECT City, Country FROM Customers WHERE Country='Germany' UNION ALL SELECT City, Country FROM Suppliers WHERE Country='Germany' ORDER BY City; 다음 SQL문은 모든 고객과 공급자를 나열합니다. SELECT 'Customer' As Type, ContactName, City, Country FROM Customers UNION SELECT 'Supplier', ContactName, City, Country FROM Suppliers; SQL GROUP BY문 GROUP BY문은 집계 함수 (COUNT, MAX, MIN, SUM, AVG)와 함께 사용되어 결과 집합을 하나 이상의 열로 그룹화 합니다. 기본 사용법 SELECT column_name(s) FROM table_name WHERE condition GROUP BY column_name(s) ORDER BY column_name(s); 다음 SQL 문은 각 국가의 고객 수를 나열합니다. SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country; 다음 SQL 문은 각 국가의 고객 수를 내림차순으로 정렬하여 나열합니다. SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country ORDER BY COUNT(CustomerID) DESC; 다음 SQL 문은 각 발송인이 보낸 주문 수를 나열합니다. SELECT Shippers.ShipperName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders LEFT JOIN Shippers ON Orders.ShipperID = Shippers.ShipperID GROUP BY ShipperName; SQL HAVING Clause(HAVING절) HAVING절은 WHERE 키워드가 집합 함수(aggregate functions)와 함께 사용될 수 없기 때문에 SQL문에 추가되었습니다. (연산에 조건을 추가하여 더 세밀한 정보를 찾아낼 때 사용할 수 있다.) 기본 사용법 SELECT column_name(s) FROM table_name WHERE condition GROUP BY column_name(s) HAVING condition ORDER BY column_name(s); 다음 SQL문은 각 국가의 고객 수를 나열합니다. 5 명 이상의 고객이있는 국가 만 포함 SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country HAVING COUNT(CustomerID) &amp;gt; 5; 다음 SQL문은 각 국가의 고객 수를 높은 순으로 정렬하여 나열합니다 (고객이 5 명 이상인 국가 만 포함). SELECT COUNT(CustomerID), Country FROM Customers GROUP BY Country HAVING COUNT(CustomerID) &amp;gt; 5 ORDER BY COUNT(CustomerID) DESC; “Davolio”또는 “Fuller”직원이 25 개가 넘는 주문을 등록한 경우 다음 SQL 문에 나열됩니다. SELECT Employees.LastName, COUNT(Orders.OrderID) AS NumberOfOrders FROM Orders INNER JOIN Employees ON Orders.EmployeeID = Employees.EmployeeID WHERE LastName = 'Davolio' OR LastName = 'Fuller' GROUP BY LastName HAVING COUNT(Orders.OrderID) &amp;gt; 25; SQL EXISTS 연산자 EXISTS 연산자는 하위 쿼리의 레코드 존재 여부를 테스트하는 데 사용됩니다. EXISTS 연산자는 하위 쿼리가 하나 이상의 레코드를 반환하면 true를 반환합니다. SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT column_name FROM table_name WHERE condition); 다음 SQL 문은 TRUE를 반환하고 제품 가격이 20 미만인 공급 업체를 나열합니다. SELECT SupplierName FROM Suppliers WHERE EXISTS (SELECT ProductName FROM Products WHERE SupplierId = Suppliers.supplierId AND Price &amp;lt; 20); SQL ANY 및 ALL 연산자 ANY 및 ALL 연산자는 WHERE 또는 HAVING 절과 함 2 사용됩니다. ANY 연산자는 하위 쿼리 값 중 하나가 조건을 충족하면 true를 반환합니다. ALL 연산자는 모든 하위 쿼리 값이 조건을 충족하면 true를 반환합니다. ANY 구문 기본 사용법 SELECT column_name(s) FROM table_name WHERE column_name operator ANY (SELECT column_name FROM table_name WHERE condition); ALL 구문 기본 사용법 SELECT column_name(s) FROM table_name WHERE column_name operator ALL (SELECT column_name FROM table_name WHERE condition); 다음 SQL문은 TRUE를 리턴하고 OrderDetails 의 quantity = 10 인 값의 ProductID와 Products의 ProductID를 비교하여 같은 값이 있다면 Products의 ProductsName을 반환합니다. SELECT ProductName FROM Products WHERE ProductID = ANY (SELECT ProductID FROM OrderDetails WHERE Quantity = 10); OrderDetails 테이블의 모든 레코드가 quantity = 10이면 다음 SQL 문은 TRUE를 반환하고 제품 이름을 나열합니다. SELECT ProductName FROM Products WHERE ProductID = ALL (SELECT ProductID FROM OrderDetails WHERE Quantity = 10); SQL SELECT INTO문 SELECT INTO 문은 한 테이블의 데이터를 새 테이블로 복사합니다. 기본 사용법(모든 열을 새 테이블로 복사) SELECT * INTO newtable [IN externaldb] FROM oldtable WHERE condition; 기본 사용법(일부 열만 새 테이블로 복사) SELECT column1, column2, column3, ... INTO newtable [IN externaldb] FROM oldtable WHERE condition; 다음 SQL 문은 Customers 백업 복사본을 만듭니다. SELECT * INTO CustomersBackup2017 FROM Customers; 다음 SQL 문은 IN 절을 사용하여 테이블을 다른 데이터베이스의 새 테이블로 복사합니다. SELECT * INTO CustomersBackup2017 IN 'Backup.mdb' FROM Customers; 다음 SQL 문은 몇 개의 열만 새 테이블에 복사합니다. SELECT CustomerName, ContactName INTO CustomersBackup2017 FROM Customers; 다음 SQL 문은 독일 고객 만 새 테이블로 복사합니다. SELECT * INTO CustomersGermany FROM Customers WHERE Country = 'Germany'; 다음 SQL 문은 둘 이상의 테이블의 데이터를 새 테이블로 복사합니다. SELECT Customers.CustomerName, Orders.OrderID INTO CustomersOrderBackup2017 FROM Customers LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID; SELECT INTO를 사용하여 다른 테이블의 스키마를 사용하여 빈 테이블을 새로 만들 수도 있습니다. 쿼리가 데이터를 반환하지 않게하는 WHERE 절을 추가하기만 하면됩니다. SELECT * INTO newtable FROM oldtable WHERE 1 = 0; SQL INSERT INTO SELECT문 INSERT INTO SELECT 문은 한 테이블의 데이터를 복사하여 다른 테이블에 삽입합니다. INSERT INTO SELECT는 소스 및 목표 테이블의 데이터 유형이 일치해야합니다. 목표 테이블의 기존 레코드는 영향을받지 않습니다. 한 테이블의 모든 열을 다른 테이블로 복사 INSERT INTO table2 SELECT * FROM table1 WHERE condition; 한 테이블의 일부 열만 다른 테이블로 복사 INSERT INTO table2 (column1, column2, column3, ...) SELECT column1, column2, column3, ... FROM table1 WHERE condition; SQL NULL함수 예제 데이터 P_Id | ProductName | UnitPrice | UnitsInStock | UnitsOnOrder —|—|—|—|— 1 | Jarlsberg | 10.45 | 16 | 15 2 | Mascarpone | 32.56 | 23 | 3 | Gorgonzola | 15.67 | 9 | 20 “UnitsOnOrder”열이 선택적이며 NULL 값을 포함 할 수 있다고 가정합니다. 다음 SQL문에서는 위의 예제에서 위의 예제에서 “UnitsOnOrder”값 중 하나라도 NULL이면 결과는 NULL입니다. SELECT ProductName, UnitPrice * (UnitsInStock + UnitsOnOrder) FROM Products; MY SQL에서는 IFNULL()함수를 사용하거나 COALESCE() 함수를 사용하여 대체 값을 반환 할 수 있습니다. SELECT ProductName, UnitPrice * (UnitsInStock + IFNULL(UnitsOnOrder, 0)) FROM Products SELECT ProductName, UnitPrice * (UnitsInStock + COALESCE(UnitsOnOrder, 0)) FROM Products SQL서버에서는 ISNULL()함수를 사용하면 식이 NULL일 때 대체 값을 반환 할 수 있습니다. SELECT ProductName, UnitPrice * (UnitsInStock + ISNULL(UnitsOnOrder, 0)) FROM Products MS Access IsNull()함수는 식이 null값이면 True(-1)를 반환하고 그렇지 않으면 FALSE(0)을 반환합니다. SELECT ProductName, UnitPrice * (UnitsInStock + IIF(IsNull(UnitsOnOrder), 0, UnitsOnOrder)) FROM Products Oracle NVL () 함수는 동일한 결과를 얻습니다. SELECT ProductName, UnitPrice * (UnitsInStock + NVL(UnitsOnOrder, 0)) FROM Products SQL 주석 주석은 SQL 문의 섹션을 설명하거나 SQL 문의 실행을 막는 데 사용됩니다. 한 줄 주석은 -로 시작합니다. -와 행 끝 사이의 모든 텍스트는 무시됩니다 (실행되지 않습니다). 다음 예제는 한 줄 주석을 설명으로 사용합니다. --Select all: SELECT * FROM Customers; 다음 예제에서는 한 줄 주석을 사용하여 줄 끝을 무시합니다. SELECT * FROM Customers -- WHERE City='Berlin'; 여러 줄 주석은 /*로 시작하고 */로 끝납니다. /*와 */ 사이의 모든 텍스트는 무시됩니다. 다음 예제에서는 설명을 위해 여러 줄 주석을 사용합니다. /*Select all the columns of all the records in the Customers table:*/ SELECT * FROM Customers; 명령문의 일부만 무시하려면 /* */ 주석도 사용하십시오. 다음 예제에서는 주석을 사용하여 행의 일부를 무시합니다. SELECT CustomerName, /*City,*/ Country FROM Customers; SQL 데이터베이스 동작 관련 문법 CREATE DATABASE문 CREATE DATABASE 문은 새 SQL 데이터베이스를 만드는 데 사용됩니다. CREATE DATABASE databasename; DROP DATABASE문 DROP DATABASE 문은 기존 SQL 데이터베이스를 삭제하는 데 사용됩니다. DROP DATABASE databasename; CREATE TABLE문 CREATE TABLE 문은 데이터베이스에 새 테이블을 만드는 데 사용됩니다. column 매개 변수는 테이블의 열 이름을 지정합니다. datatype 매개 변수는 열에서 보유 할 수있는 데이터 유형 (예 : varchar, 정수, 날짜 등)을 지정합니다. CREATE TABLE table_name ( column1 datatype, column2 datatype, column3 datatype, .... ); 다음 예에서는 PersonID, LastName, FirstName, Address 및 City라는 다섯 개의 열이 포함 된 “Persons”라는 테이블을 만듭니다. CREATE TABLE Persons ( PersonID int, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255) ); PersonID 열은 int 유형이며 정수를 포함합니다. LastName, FirstName, Address 및 City 열은 varchar 유형이며 문자를 포함하며이 필드의 최대 길이는 255 자입니다. 빈 “Persons”테이블은 이제 다음과 같이 보입니다. PersonID | LastName | FirstName | Address | City —|—|—|—|— —|—|—|—|— 다른 테이블을 사용하여 새 테이블을 만들 수 있습니다. 기존 테이블의 사본은 CREATE TABLE.과 SELECT.의 조합을 사용하여 작성할 수 있습니다. 테이블은 동일한 열 정의를 가져옵니다. 모든 열 또는 특정 열을 선택할 수 있습니다. 기존 테이블을 사용하여 새 테이블을 만들면 새 테이블은 이전 테이블의 기존 값으로 채워집니다. CREATE TABLE new_table_name AS SELECT column1, column2,... FROM existing_table_name WHERE ....; DROP TABLE문 DROP TABLE 문은 데이터베이스의 기존 테이블을 삭제하는 데 사용됩니다. DROP TABLE table_name; TRUNCATE TABLE 문은 테이블 내부의 데이터는 삭제하지만 테이블 자체는 삭제하지 않습니다. TRUNCATE TABLE table_name; ALTER TABLE문 ALTER TABLE 문은 기존 테이블의 열을 추가, 삭제 또는 수정하는 데 사용됩니다. ALTER TABLE문은 기존 테이블에 다양한 제한 조건을 추가 제거하는 데에도 사용됩니다. ALTER TABLE table_name ADD column_name datatype; 테이블의 열을 삭제하려면 다음 구문을 사용합니다 (일부 데이터베이스 시스템에서는 열 삭제가 허용되지 않음). ALTER TABLE table_name DROP COLUMN column_name; 테이블에있는 열의 데이터 형식을 변경하려면 다음 구문을 사용합니다. SQL Server / MS 액세스 ALTER TABLE table_name ALTER COLUMN column_name datatype; 내 SQL / 오라클 (이전 버전 10G) : ALTER TABLE table_name MODIFY COLUMN column_name datatype; Oracle 10G 이상 ALTER TABLE table_name MODIFY column_name datatype; SQL Constraints SQL 제한 조건은 테이블의 데이터에 대한 특정한 룰을 지정하는 데 사용됩니다. CREATE TABLE.으로 테이블이 작성 될 때 또는 ALTER TABLE.으로 테이블이 작성된 후에 제한 조건을 지정할 수 있습니다. CREATE TABLE table_name ( column1 datatype constraint, column2 datatype constraint, column3 datatype constraint, .... ); SQL 제약 조건은 테이블의 데이터에 대한 규칙을 지정하는 데 사용됩니다. 제약 조건은 테이블에 들어갈 수있는 데이터 유형을 제한하는 데 사용됩니다. 이렇게하면 표의 데이터 정확성과 신뢰성이 보장됩니다. 제한 조건과 데이터 조치 사이에 위반이 있으면 조치가 중단됩니다. 제약 조건은 열 수준 또는 테이블 수준 일 수 있습니다. 컬럼 레벨 제한 조건은 컬럼에 적용되고 테이블 레벨 제한 조건은 전체 테이블에 적용됩니다. SQL에서 일반적으로 사용되는 다음 제약 조건이 있습니다. NOT NULL - 열이 NULL 값을 가질 수 없음을 보장합니다. UNIQUE - 열의 모든 값이 서로 다른지 확인합니다. PRIMARY KEY - NOT NULL과 UNIQUE의 조합. 테이블의 각 행을 고유하게 식별합니다. FOREIGN KEY - 다른 테이블의 행 / 레코드를 고유하게 식별합니다. CHECK - 열의 모든 값이 특정 조건을 충족하는지 확인합니다. DEFAULT - 값이 지정되지 않은 경우 열의 기본값을 설정합니다. INDEX - 데이터베이스에서 데이터를 매우 신속하게 생성 및 검색하는 데 사용됩니다. SQL NOT NULL 제약 조건 기본적으로 열은 NULL 값을 포함 할 수 있습니다. NOT NULL 제약 조건은 열이 NULL 값을 허용하지 않도록 강제합니다. 이렇게하면 필드에 항상 값이 포함될 수 있습니다. 즉, 새 레코드를 삽입하거나이 필드에 값을 추가하지 않고 레코드를 업데이트 할 수 없습니다. 다음 SQL은 “ID”, “LastName”및 “FirstName”열이 NULL 값을 허용하지 않도록합니다. CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255) NOT NULL, Age int ); SQL UNIQUE 제약 조건 UNIQUE 제약 조건은 열의 모든 값이 서로 다른지 확인합니다. UNIQUE 및 PRIMARY KEY 제약 조건은 열 또는 열 집합의 고유성을 보장합니다. PRIMARY KEY 제약 조건에는 자동으로 UNIQUE 제약 조건이 있습니다. 그러나 테이블 당 많은 UNIQUE 제약 조건을 가질 수 있지만 테이블 당 하나의 PRIMARY KEY 제약 조건 만 가질 수 있습니다. 다음 SQL은 “Person”테이블을 만들 때 “ID”열에 UNIQUE 제약 조건을 만듭니다. SQL Server / Oracle / MS 액세스 CREATE TABLE Persons ( ID int NOT NULL UNIQUE, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int ); MySQL CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, UNIQUE (ID) ); UNIQUE 제약 조건의 이름을 지정하고 여러 열에 UNIQUE 제약 조건을 정의하려면 다음 SQL 구문을 사용하십시오. CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, CONSTRAINT UC_Person UNIQUE (ID,LastName) ); 테이블이 이미 만들어 졌을 때 “ID”열에 UNIQUE 제약 조건을 만들려면 다음 SQL을 사용하십시오. ALTER TABLE Persons ADD UNIQUE (ID); UNIQUE 제약 조건의 이름을 지정하고 여러 열에 UNIQUE 제약 조건을 정의하려면 다음 SQL 구문을 사용하십시오. ALTER TABLE Persons ADD CONSTRAINT UC_Person UNIQUE (ID,LastName); UNIQUE 제약 조건을 삭제하려면 다음 SQL을 사용하십시오. MySQL ALTER TABLE Persons DROP INDEX UC_Person; SQL Server / Oracle / MS 액세스 ALTER TABLE Persons DROP CONSTRAINT UC_Person; SQL PRIMARY KEY제약 PRIMARY KEY 제약 조건은 데이터베이스 테이블의 각 레코드를 고유하게 식별합니다. (각 레코드를 식별해 주는 고유한 값으로 보면 된다.) 기본 키는 UNIQUE 값을 포함해야하며 NULL 값을 포함 할 수 없습니다. 테이블에는 기본 키가 하나만있을 수 있습니다. 기본 키는 하나 또는 여러 개의 필드로 구성 될 수 있습니다. 다음 SQL문은 “Person”테이블이 생성 될 때 “ID”열에 PRIMARY KEY를 만듭니다. MySQL CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, PRIMARY KEY (ID) ); SQL Server / Oracle / MS 액세스 CREATE TABLE Persons ( ID int NOT NULL PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int ); PRIMARY KEY 제약 조건의 이름 지정을 허용하고 여러 열에 대해 PRIMARY KEY 제약 조건을 정의하려면 다음 SQL 구문을 사용합니다. (참고 : 다음 예에서는 오직 하나의 PRIMARY KEY (PK_Person) 만 있습니다. 그러나 기본 키의 VALUE는 두 개의 COLUMNS (ID + 성)로 구성됩니다.) CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, CONSTRAINT PK_Person PRIMARY KEY (ID,LastName) ); 테이블이 이미 만들어 졌을 때 “ID”열에 PRIMARY KEY 제약 조건을 만들려면 다음 SQL을 사용하십시오. ALTER TABLE Persons ADD PRIMARY KEY (ID); PRIMARY KEY 제약 조건의 이름 지정을 허용하고 여러 열에 대해 PRIMARY KEY 제약 조건을 정의하려면 다음 SQL 구문을 사용합니다. ALTER TABLE Persons ADD CONSTRAINT PK_Person PRIMARY KEY (ID,LastName); ALTER TABLE 문을 사용하여 PRIMARY KEY를 추가하는 경우 PRIMARY KEY 열은 (테이블이 처음 작성되었을 때) NULL 값을 포함하지 않도록 이미 선언되어 있어야합니다. PRIMARY KEY 제약 조건을 삭제하려면 다음 SQL을 사용하십시오. MySQL ALTER TABLE Persons DROP PRIMARY KEY; SQL Server / Oracle / MS 액세스 ALTER TABLE Persons DROP CONSTRAINT PK_Person; SQL FOREIGN KEY제약 FOREIGN KEY는 두 테이블을 서로 연결하는 데 사용되는 키입니다. FOREIGN KEY는 다른 테이블의 PRIMARY KEY를 참조하는 테이블의 필드 (또는 필드 모음)입니다. FOREIGN KEY가 들어있는 테이블을 하위 테이블이라고하고 candidate key가 들어있는 테이블을 참조 된 테이블 또는 상위 테이블이라고합니다. Persons table PersonID | LastName | FirstName | Age —|—|—|— 1 | Hansen | Ola | 30 2 | Svendson | Tove | 23 3 | Pettersen | Kari | 20 Orders table OrderID | OrderNumber | PersonID —|—|— 1 | 77895 | 3 2 | 44678 | 3 3 | 22456 | 2 4 | 24562 | 1 “Orders”테이블의 “PersonID”열이 “Person”테이블의 “PersonID”열을 가리키는 것을 확인하십시오. “Person”테이블의 “PersonID”열은 “Person”테이블의 PRIMARY KEY입니다. “Orders”테이블의 “PersonID”열은 “Orders”테이블의 FOREIGN KEY입니다. FOREIGN KEY 제약 조건은 테이블 간의 연결을 파괴하는 작업을 방지하는 데 사용됩니다. FOREIGN KEY 제약 조건은 또한 가리키는 테이블에 포함 된 값 중 하나 여야하기 때문에 잘못된 데이터가 외부 키 열에 삽입되는 것을 방지합니다. 다음 SQL문은 “Orders”테이블을 만들 때 “PersonID”열에 FOREIGN KEY를 만듭니다. MySQL CREATE TABLE Orders ( OrderID int NOT NULL, OrderNumber int NOT NULL, PersonID int, PRIMARY KEY (OrderID), FOREIGN KEY (PersonID) REFERENCES Persons(PersonID) ); SQL Server / Oracle / MS 액세스 CREATE TABLE Orders ( OrderID int NOT NULL PRIMARY KEY, OrderNumber int NOT NULL, PersonID int FOREIGN KEY REFERENCES Persons(PersonID) ); FOREIGN KEY 제약 조건의 이름 지정 및 여러 열의 FOREIGN KEY 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용합니다. CREATE TABLE Orders ( OrderID int NOT NULL, OrderNumber int NOT NULL, PersonID int, PRIMARY KEY (OrderID), CONSTRAINT FK_PersonOrder FOREIGN KEY (PersonID) REFERENCES Persons(PersonID) ); “Orders”테이블이 이미 생성 된 경우 “PersonID”열에 FOREIGN KEY 제약 조건을 만들려면 다음 SQL을 사용하십시오. ALTER TABLE Orders ADD FOREIGN KEY (PersonID) REFERENCES Persons(PersonID); FOREIGN KEY 제약 조건의 이름 지정 및 여러 열의 FOREIGN KEY 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용합니다. ALTER TABLE Orders ADD CONSTRAINT FK_PersonOrder FOREIGN KEY (PersonID) REFERENCES Persons(PersonID); FOREIGN KEY 제약 조건을 삭제하려면 다음 SQL을 사용하십시오. MySQL ALTER TABLE Orders DROP FOREIGN KEY FK_PersonOrder; SQL Server / Oracle / MS 액세스 ALTER TABLE Orders DROP CONSTRAINT FK_PersonOrder; SQL CHECK Constraint CHECK 제약 조건은 열에 배치 할 수있는 값 범위를 제한하는 데 사용됩니다. 단일 열에 CHECK 제한 조건을 정의하면이 열에 대해 특정 값만 허용됩니다. 테이블에 CHECK 제한 조건을 정의하면 행의 다른 컬럼에있는 값을 기준으로 특정 컬럼의 값을 제한 할 수 있습니다. 다음 SQL은 “Person”테이블이 작성 될 때 “Age”컬럼에 CHECK 제한 조건을 작성합니다. CHECK 제약 조건은 18 세 미만의 사람을 가질 수 없도록 보장합니다. MySQL CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, CHECK (Age&amp;gt;=18) ); SQL Server / Oracle / MS 액세스 CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int CHECK (Age&amp;gt;=18) ); CHECK 제약 조건의 이름 지정 및 여러 열에 대한 CHECK 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용하십시오. CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, City varchar(255), CONSTRAINT CHK_Person CHECK (Age&amp;gt;=18 AND City='Sandnes') ); 테이블이 이미 생성 된 경우 “Age”열에 CHECK 제약 조건을 만들려면 다음 SQL을 사용하십시오. ALTER TABLE Persons ADD CHECK (Age&amp;gt;=18); CHECK 제약 조건의 이름 지정 및 여러 열에 대한 CHECK 제약 조건 정의를 허용하려면 다음 SQL 구문을 사용하십시오. ALTER TABLE Persons ADD CONSTRAINT CHK_PersonAge CHECK (Age&amp;gt;=18 AND City='Sandnes'); CHECK 제약 조건을 삭제하려면 다음 SQL을 사용하십시오. SQL Server / Oracle / MS 액세스 ALTER TABLE Persons DROP CONSTRAINT CHK_PersonAge; MySQL ALTER TABLE Persons DROP CHECK CHK_PersonAge; DEFAULT Constraint DEFAULT 제약 조건은 열의 기본값을 제공하는 데 사용됩니다. 다른 값을 지정하지 않으면 기본값이 모든 새 레코드에 추가됩니다. 다음 SQL은 “Person”테이블을 만들 때 “City”열의 DEFAULT 값을 설정합니다. CREATE TABLE Persons ( ID int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, City varchar(255) DEFAULT 'Sandnes' ); DEFAULT 제약 조건은 GETDATE ()와 같은 함수를 사용하여 시스템 값을 삽입하는 데에도 사용할 수 있습니다. CREATE TABLE Orders ( ID int NOT NULL, OrderNumber int NOT NULL, OrderDate date DEFAULT GETDATE() ); 테이블이 이미 만들어 졌을 때 “도시”열에 DEFAULT 제약 조건을 만들려면 다음 SQL을 사용하십시오 MySQL ALTER TABLE Persons ALTER City SET DEFAULT 'Sandnes'; SQL Server / MS Access: ALTER TABLE Persons ALTER COLUMN City SET DEFAULT 'Sandnes'; Oracle ALTER TABLE Persons MODIFY City DEFAULT 'Sandnes'; DEFAULT 제약 조건을 삭제하려면 다음 SQL을 사용합니다. MySQL ALTER TABLE Persons ALTER City DROP DEFAULT; Server / Oracle / MS 액세스 ALTER TABLE Persons ALTER COLUMN City DROP DEFAULT; CREATE INDEX문 DEX 문은 테이블에 인덱스를 만드는 데 사용됩니다. 인덱스는 데이터베이스에서 데이터를 매우 빨리 검색하는 데 사용됩니다. 사용자는 색인을 볼 수 없으며 검색 / 쿼리의 속도를 높이기 위해 사용됩니다. 인텍스와 함께 테이블을 갱신하는 것은 테이블만 갱신하는 것 보다 많은 시간을 잡아먹습니다. 따라서 자주 검색 할 열에 대해서만 인덱스를 작성하십시오. 테이블에 인덱스를 만듭니다. 중복 된 값이 허용됩니다. CREATE INDEX index_name ON table_name (column1, column2, ...); 테이블에 고유 인덱스를 작성합니다. 중복 값은 허용되지 않습니다. CREATE UNIQUE INDEX index_name ON table_name (column1, column2, ...); 참고 : 인덱스를 만드는 구문은 데이터베이스마다 다릅니다. 따라서 데이터베이스의 인덱스 작성 구문을 확인하십시오. DROP INDEX 문은 테이블의 인덱스를 삭제하는 데 사용됩니다. MS 액세스 DROP INDEX index_name ON table_name; SQL Server DROP INDEX table_name.index_name; DB2 / Oracle P INDEX index_name; MySQL ALTER TABLE table_name DROP INDEX index_name; INCREMENT 필드 AUTO INCREMENT 필드 : 자동 증가는 새 레코드가 테이블에 삽입 될 때 고유 번호가 자동으로 생성되도록합니다. 종종 이것은 새로운 레코드가 삽입 될 때마다 자동으로 생성되기를 원하는 기본 키 필드입니다. MySQL : 다음 SQL 문은 “Person”테이블의 자동 증가 기본 키 필드로 “ID”열을 정의합니다. MySQL은 AUTO_INCREMENT 키워드를 사용하여 자동 증가 기능을 수행합니다. 기본적으로 AUTO_INCREMENT의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다. CREATE TABLE Persons ( ID int NOT NULL AUTO_INCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int, PRIMARY KEY (ID) ); AUTO_INCREMENT 시퀀스를 다른 값으로 시작하려면 다음 SQL 문을 사용하십시오. ALTER TABLE Persons AUTO_INCREMENT=100; “Persons”테이블에 새 레코드를 삽입하려면 “ID”열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다). INSERT INTO Persons (FirstName,LastName) VALUES ('Lars','Monsen'); SQL Server구문 : 다음 SQL 문은 “Person”테이블의 자동 증가 기본 키 필드로 “ID”열을 정의합니다. MS SQL Server는 IDENTITY 키워드를 사용하여 자동 증가 기능을 수행합니다. 위의 예에서 IDENTITY의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다. CREATE TABLE Persons ( ID int IDENTITY(1,1) PRIMARY KEY, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int ); 팁 : “ID”열이 값 10에서 시작하여 5 씩 증가하도록 지정하려면 IDENTITY (10,5)로 변경하십시오. “Persons”테이블에 새 레코드를 삽입하려면 “ID”열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다). INSERT INTO Persons (FirstName,LastName) VALUES ('Lars','Monsen'); Access : 다음 SQL 문은 “Person”테이블의 자동 증가 기본 키 필드로 “ID”열을 정의합니다. MS Access는 AUTOINCREMENT 키워드를 사용하여 자동 증가 기능을 수행합니다. 기본적으로 AUTOINCREMENT의 시작 값은 1이며 새 레코드마다 1 씩 증가합니다. CREATE TABLE Persons ( ID Integer PRIMARY KEY AUTOINCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), Age int ); 팁 : “ID”열이 값 10에서 시작하여 5 씩 증가하도록 지정하려면 자동 증가를 AUTOINCREMENT (10,5)로 변경하십시오. “Persons”테이블에 새 레코드를 삽입하려면 “ID”열에 값을 지정할 필요가 없습니다 (고유 한 값이 자동으로 추가됩니다). INSERT INTO Persons (FirstName,LastName) VALUES ('Lars','Monsen'); 오라클 : 오라클에서는 코드가 좀 더 까다 롭습니다. 시퀀스 객체로 자동 증가 필드를 만들어야합니다 (이 객체는 숫자 시퀀스를 생성합니다). CREATE SEQUENCE seq_person MINVALUE 1 START WITH 1 INCREMENT BY 1 CACHE 10; 위의 코드는 seq_person이라는 시퀀스 객체를 생성합니다. seq_person은 1부터 시작하여 1 씩 증가합니다. 또한 성능을 위해 최대 10 개의 값을 캐시합니다. 캐시 옵션은 더 빠른 액세스를 위해 얼마나 많은 순서 값이 메모리에 저장 될지 지정합니다. “Persons”테이블에 새 레코드를 삽입하려면 nextval 함수를 사용해야합니다 (이 함수는 seq_person 시퀀스에서 다음 값을 검색합니다). INSERT INTO Persons (ID,FirstName,LastName) VALUES (seq_person.nextval,'Lars','Monsen'); SQL Date 날짜 작업을 할 때 가장 어려운 부분은 삽입하려는 날짜의 형식이 데이터베이스의 날짜 열 형식과 일치하는지 확인하는 것입니다. MySQL 에는 데이터베이스에 날짜 또는 날짜 / 시간 값을 저장하기위한 다음 데이터 유형이 있습니다. DATE - YYYY-MM-DD 형식 DATETIME - 형식 : YYYY-MM-DD HH : MI : SS TIMESTAMP - 형식 : YYYY-MM-DD HH : MI : SS YEAR - YYYY 또는 YY 형식 SQL Server 에는 데이터베이스에 날짜 또는 날짜 / 시간 값을 저장하기위한 다음 데이터 형식이 있습니다. DATE - YYYY-MM-DD 형식 DATETIME - 형식 : YYYY-MM-DD HH : MI : SS SMALLDATETIME - 형식 : YYYY-MM-DD HH : MI : SS TIMESTAMP - 형식 : 고유 번호 다음 “Orders” 테이블이 있다고 가정합니다. OrderId | ProductName | OrderDate —|—|— 1 | Geitost | 2008-11-11 2 | Camembert Pierrot | 2008-11-09 3 | Mozzarella di Giovanni | 2008-11-11 4 | Mascarpone Fabioli | 2008-10-29 위 표에서 OrderDate가 “2008-11-11”인 레코드를 선택하려고합니다. SELECT * FROM Orders WHERE OrderDate='2008-11-11' 이제 “주문”테이블이 다음과 같이 보입니다 ( “주문일”열의 시간 구성 요소에 주목하십시오). OrderId | ProductName | OrderDate —|—|— 1 | Geitost | 2008-11-11 13:23 2 | Camembert Pierrot | 2008-11-09 15:45 3 | Mozzarella di Giovanni | 2008-11-11 11:12 4 | Mascarpone Fabioli | 2008-10-29 14:56 위와 같은 SELECT 문을 사용하는 경우 SELECT * FROM Orders WHERE OrderDate='2008-11-11' 우리는 결과를 얻지 못할 것이다! 이는 쿼리가 시간 부분이없는 날짜 만 찾고 있기 때문입니다. 팁 : 검색어를 간단하고 쉽게 유지하려면 날짜에 시간 구성 요소를 허용하지 마십시오! SQL CREATE VIEW문 SQL에서 뷰는 SQL 문의 결과 세트를 기반으로하는 가상 테이블입니다. 뷰에는 실제 테이블과 마찬가지로 행과 열이 포함됩니다. 뷰의 필드는 데이터베이스에있는 하나 이상의 실제 테이블의 필드입니다. SQL 함수, WHERE 및 JOIN 문을 뷰에 추가하고 데이터가 하나의 단일 테이블에서 온 것처럼 데이터를 표시 할 수 있습니다. 기본 사용법 CREATE VIEW view_name AS SELECT column1, column2, ... FROM table_name WHERE condition; 참고 : 보기에는 항상 최신 데이터가 표시됩니다! 데이터베이스 엔진은 사용자가 뷰를 쿼리 할 때마다 뷰의 SQL 문을 사용하여 데이터를 다시 작성합니다. “현재 제품 목록”보기에는 “제품”테이블의 모든 활성 제품 (중단되지 않은 제품)이 나열됩니다. 뷰는 다음 SQL로 작성됩니다. CREATE VIEW [Current Product List] AS SELECT ProductID, ProductName FROM Products WHERE Discontinued = No; 그런 다음 다음과 같이 뷰를 쿼리 할 수 ​​있습니다. SELECT * FROM [Current Product List]; Northwind 샘플 데이터베이스의 또 다른보기는 “제품”테이블의 모든 제품을 평균 단가보다 높은 단가로 선택합니다. CREATE VIEW [Products Above Average Price] AS SELECT ProductName, UnitPrice FROM Products WHERE UnitPrice &amp;gt; (SELECT AVG(UnitPrice) FROM Products); 위의보기는 다음과 같이 쿼리 할 수 ​​있습니다. SELECT * FROM [Products Above Average Price]; Northwind 데이터베이스의 다른보기는 1997 년 각 범주의 총 ​​판매량을 계산합니다.이보기는 “1997 년 제품 판매”라는 다른보기에서 해당 데이터를 선택합니다. CREATE VIEW [Category Sales For 1997] AS SELECT DISTINCT CategoryName, Sum(ProductSales) AS CategorySales FROM [Product Sales for 1997] GROUP BY CategoryName; 위의보기는 다음과 같이 쿼리 할 수 ​​있습니다. SELECT * FROM [Category Sales For 1997]; 쿼리에 조건을 추가 할 수도 있습니다. “음료수”카테고리에 대해서만 총 판매를 봅시다. SELECT * FROM [Category Sales For 1997] WHERE CategoryName = 'Beverages'; SQL VIEW UPDATE 기본 사용법 CREATE OR REPLACE VIEW view_name AS SELECT column1, column2, ... FROM table_name WHERE condition; 다음 예시는 위의 “현재 제품 목록” VIEW에 “범주”열을 추가합니다. 다음 SQL로 뷰를 업데이트합니다. CREATE OR REPLACE VIEW [Current Product List] AS SELECT ProductID, ProductName, Category FROM Products WHERE Discontinued = No; VIEW 삭제 : 다음 SQL 명령으로 VIEW를 삭제할 수 있습니다. DROP VIEW view_name; SQL INJECTION (추가공부 필요) SQL INJECTION은 데이터베이스를 파괴 할 수있는 코드 삽입 기술입니다. SQL INJECTION은 가장 일반적인 웹 해킹 기술 중 하나입니다. SQL INJECTION은 웹 페이지 입력을 통해 SQL 문에 악의적 인 코드를 배치합니다. SQL 인젝션은 대개 사용자에게 username / userid와 같은 입력을 요청할 때 발생하며 이름 / ID 대신 사용자가 알지 못하게 데이터베이스에서 실행할 SQL 문을 제공 합니다. SQL Hosting 웹 사이트에서 데이터베이스의 데이터를 저장하고 검색 할 수있게하려면 웹 서버가 SQL 언어를 사용하는 데이터베이스 시스템에 액세스 할 수 있어야합니다. 웹 서버가 ISP (Internet Service Provider)에 의해 호스팅되는 경우 SQL 호스팅 계획을 찾아야합니다. 가장 일반적인 SQL 호스팅 데이터베이스는 MS SQL Server, Oracle, MySQL 및 MS Access입니다. Microsoft의 SQL Server는 트래픽이 많은 데이터베이스 중심 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어입니다. SQL Server는 강력하고 완벽한 SQL 데이터베이스 시스템입니다. 오라클은 트래픽이 많은 데이터베이스 중심 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어이기도합니다. MySQL은 웹 사이트에 널리 사용되는 데이터베이스 소프트웨어이기도합니다. MySQL은 값 비싼 Microsoft 및 Oracle 솔루션 대신 저렴한 방법입니다.</summary></entry><entry><title type="html">Ubuntu_설정관련</title><link href="http://localhost:4000/ubuntu_%EC%84%A4%EC%A0%95%EA%B4%80%EB%A0%A8/" rel="alternate" type="text/html" title="Ubuntu_설정관련" /><published>2017-09-30T00:00:00+09:00</published><updated>2017-09-30T00:00:00+09:00</updated><id>http://localhost:4000/ubuntu_%EC%84%A4%EC%A0%95%EA%B4%80%EB%A0%A8</id><content type="html" xml:base="http://localhost:4000/ubuntu_%EC%84%A4%EC%A0%95%EA%B4%80%EB%A0%A8/">&lt;h1 id=&quot;ubuntu-에서-한글입력기-설정-방법&quot;&gt;ubuntu 에서 한글입력기 설정 방법&lt;/h1&gt;

&lt;h3 id=&quot;한글-설치&quot;&gt;한글 설치&lt;/h3&gt;
&lt;p&gt;sudo apt-get install fcitx-hangul로 한글을 설치한다.
System Settings &amp;gt; Language Support를 실행해서 아직 완전히 설치되지 않다고 표시되는데 잠시 기다려서 모두 설치한다.
Keyboard input method system:을 ibus가 아닌 fcitx로 변경한다.
재부팅한다.&lt;/p&gt;

&lt;h3 id=&quot;한영-전환-설정&quot;&gt;한영 전환 설정&lt;/h3&gt;
&lt;p&gt;Shortcut 설정
AllSettings &amp;gt; Keyboard &amp;gt; Shortcuts Tab &amp;gt; Typing을 선택한다.
Switch to Next source, Switch to Previous sourc, Compose Key, Alternative Characters Key를 모두 Disabled로 선택한다. Disabled로 선택하기 위해서는 backspace를 누르면 된다.
Compose Key의 Disabled를 길게 눌러 Right Alt를 선택한다.
Switch to next source는 한영키를 눌러 Multikey를 선택한다. 반드시 Compose Key 설정이 먼저되어야 Multikey를 선택할 수 있다.
AllSetting 윈도우를 닫고 상단 메뉴바 오른쪽의 입력기 선택하는 것을 본다. 키보드 표시가 된 것이 fcitx이다. fcitx아이콘을 눌러서 Configure Current Input Method를 선택한다.
Keyboard-English(US)가 있다면 +를 눌러 Hangul을 추가한다. (Uncheck “Only Show Current Language”). Korean이 아닌 Hangul이여야 한다.
Global Config tab에서 Trigger Input Method는 한/영키를 눌러 Multikey로 설정(왼쪽 오른쪽 모두)하고 Extrakey for trigger input method는 Disabled로 설정한다. (Mac에서는 command key이므로 대신 shift+space를 선택한다.)
Global Config tab에서 Program &amp;gt; Share State Among Window &amp;gt; All을 선택한다.&lt;/p&gt;

&lt;h3 id=&quot;테스트&quot;&gt;테스트&lt;/h3&gt;
&lt;p&gt;log out을 한후 다시 log in을 한다.
한글/영어가 한영키로 전환되는지 확인한다.&lt;/p&gt;

&lt;p&gt;가져온 블로그: &lt;a href=&quot;http://hochulshin.com/ubuntu-1604-hangul/&quot;&gt;출처&lt;/a&gt;&lt;/p&gt;</content><author><name>-Yoda</name></author><summary type="html">ubuntu 에서 한글입력기 설정 방법</summary></entry><entry><title type="html">Ubuntu_shortcut</title><link href="http://localhost:4000/ubuntu_shortcut/" rel="alternate" type="text/html" title="Ubuntu_shortcut" /><published>2017-09-30T00:00:00+09:00</published><updated>2017-09-30T00:00:00+09:00</updated><id>http://localhost:4000/ubuntu_shortcut</id><content type="html" xml:base="http://localhost:4000/ubuntu_shortcut/">&lt;h1 id=&quot;일반&quot;&gt;일반&lt;/h1&gt;

&lt;h4 id=&quot;ctrl--alt-l&quot;&gt;ctrl + alt L&lt;/h4&gt;
&lt;p&gt;화면 잠금&lt;/p&gt;

&lt;h4 id=&quot;super윈도우키--d&quot;&gt;super(윈도우키) + D&lt;/h4&gt;
&lt;p&gt;모든 창 내리기&lt;/p&gt;

&lt;h4 id=&quot;super--w&quot;&gt;super + w&lt;/h4&gt;
&lt;p&gt;현재 작업공간에 열려있는 창 작게 보여주기(화살표로 선택가능)&lt;/p&gt;

&lt;h4 id=&quot;super--shift--w&quot;&gt;super + shift + w&lt;/h4&gt;
&lt;p&gt;모든 작업공간에 열려있는 창 적게 보기여주기(화살표로 선택가능)&lt;/p&gt;

&lt;h4 id=&quot;ctrl--w&quot;&gt;ctrl + w&lt;/h4&gt;
&lt;p&gt;현재의 작업공간이나, 모든 작업공간에 열려있는 창을 띄운다음에(&lt;code class=&quot;highlighter-rouge&quot;&gt;super + w&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;super + shift + w&lt;/code&gt;)
&lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl + w&lt;/code&gt;명령을 통해 선택된 창을 하나씩 종료시킬 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;alt--좌마우스-끌기&quot;&gt;Alt + 좌마우스 끌기&lt;/h4&gt;
&lt;p&gt;창 이동. 창의 어느 곳이든 잡고 이동 가능.&lt;/p&gt;

&lt;h4 id=&quot;alt--중마우스-끌기&quot;&gt;Alt + 중마우스 끌기&lt;/h4&gt;
&lt;p&gt;(우분투) 창 크기 조절.&lt;/p&gt;

&lt;h4 id=&quot;ctrl--q&quot;&gt;ctrl + q&lt;/h4&gt;
&lt;p&gt;현재 어플리케이션 종료&lt;/p&gt;

&lt;h4 id=&quot;alt--tab&quot;&gt;Alt + tab&lt;/h4&gt;
&lt;p&gt;창이동 (&lt;code class=&quot;highlighter-rouge&quot;&gt;Alt&lt;/code&gt;키를 계속 누른 상태에서 Quotation Mark(쿼데이션 마크, 키보드 1 왼쪽에 있음)를 누르면 선택된 창의 작동 모습을 확인할 수 있다.)&lt;/p&gt;

&lt;h1 id=&quot;터미널-관련&quot;&gt;터미널 관련&lt;/h1&gt;

&lt;h4 id=&quot;ctrl--c&quot;&gt;ctrl + c&lt;/h4&gt;
&lt;p&gt;현재 프로세서 끝내기&lt;/p&gt;

&lt;h4 id=&quot;ctrl--z&quot;&gt;ctrl + z&lt;/h4&gt;
&lt;p&gt;현재 프로세서를 백그라운드로 실행&lt;/p&gt;

&lt;h4 id=&quot;ctrl--a&quot;&gt;ctrl + a&lt;/h4&gt;
&lt;p&gt;첫줄로 커서 이동&lt;/p&gt;

&lt;h4 id=&quot;ctrl--e&quot;&gt;ctrl + e&lt;/h4&gt;
&lt;p&gt;마지막 줄로 커서 이동&lt;/p&gt;

&lt;h4 id=&quot;ctrl--l&quot;&gt;ctrl + l&lt;/h4&gt;
&lt;p&gt;터미널 청소&lt;/p&gt;

&lt;h4 id=&quot;shift--pageup--pagedown&quot;&gt;Shift + PageUp / PageDown&lt;/h4&gt;
&lt;p&gt;터미널 결과물을 스크롤 하기&lt;/p&gt;

&lt;h4 id=&quot;ctrl--r&quot;&gt;ctrl + r&lt;/h4&gt;
&lt;p&gt;사용한 명령어 키워드로 찾기&lt;/p&gt;

&lt;h4 id=&quot;ctrl--shift--w&quot;&gt;ctrl + shift + w&lt;/h4&gt;
&lt;p&gt;현재 터미널 탭 닫기&lt;/p&gt;

&lt;h4 id=&quot;ctrl--shift--q&quot;&gt;ctrl + shift + q&lt;/h4&gt;
&lt;p&gt;현재 터미널 창 닫기&lt;/p&gt;

&lt;h4 id=&quot;ctrl--pageup-pagedown&quot;&gt;ctrl + PageUp, PageDown&lt;/h4&gt;
&lt;p&gt;터미널 탭 이동&lt;/p&gt;

&lt;h4 id=&quot;ctrl--c-1&quot;&gt;ctrl + c&lt;/h4&gt;
&lt;p&gt;작성한 명령어 실행 안시키고 다음 명령어 입력줄 실행&lt;/p&gt;

&lt;h1 id=&quot;그-외-유용한-팁&quot;&gt;그 외 유용한 팁&lt;/h1&gt;

&lt;h4 id=&quot;파일탐색창에서-ctrl--l&quot;&gt;파일탐색창에서 ctrl + l&lt;/h4&gt;
&lt;p&gt;팔일 탐색창의 현재위치 경로를 얻을 수 있다.&lt;/p&gt;

&lt;p&gt;출처: http://slayer95.tistory.com/entry/Useful-Shortcut-Keys-In-Ubuntu-우분투-단축키 [I Love Ubuntu~♡]&lt;/p&gt;

&lt;p&gt;참조 사이트
(http://egloos.zum.com/nemonein/v/5265559)
(http://slayer95.tistory.com/entry/Useful-Shortcut-Keys-In-Ubuntu-%EC%9A%B0%EB%B6%84%ED%88%AC-%EB%8B%A8%EC%B6%95%ED%82%A4)&lt;/p&gt;</content><author><name>-Yoda</name></author><summary type="html">일반</summary></entry></feed>