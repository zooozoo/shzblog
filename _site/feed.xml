<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-01-19T16:23:50+09:00</updated><id>http://localhost:4000/</id><title type="html">Record|Organize|Make it mine</title><subtitle>My programming study blog and I hope it help someone who struggling with code</subtitle><author><name>-Yoda</name></author><entry><title type="html">UX/UI fontsize customzing at atom editor</title><link href="http://localhost:4000/posts/2018-01-17-atom2/" rel="alternate" type="text/html" title="UX/UI fontsize customzing at atom editor" /><published>2018-01-17T00:00:00+09:00</published><updated>2018-01-17T00:00:00+09:00</updated><id>http://localhost:4000/posts/atom2</id><content type="html" xml:base="http://localhost:4000/posts/2018-01-17-atom2/"></content><author><name>-Yoda</name></author><category term="posts" /><category term="atom" /><summary type="html"></summary></entry><entry><title type="html">UX/UI fontsize customzing at atom editor</title><link href="http://localhost:4000/posts/2018-01-17-atom1/" rel="alternate" type="text/html" title="UX/UI fontsize customzing at atom editor" /><published>2018-01-17T00:00:00+09:00</published><updated>2018-01-17T00:00:00+09:00</updated><id>http://localhost:4000/posts/atom1</id><content type="html" xml:base="http://localhost:4000/posts/2018-01-17-atom1/"></content><author><name>-Yoda</name></author><category term="posts" /><category term="atom" /><summary type="html"></summary></entry><entry><title type="html">UX/UI fontsize customzing at atom editor</title><link href="http://localhost:4000/posts/2018-01-17-atom0/" rel="alternate" type="text/html" title="UX/UI fontsize customzing at atom editor" /><published>2018-01-17T00:00:00+09:00</published><updated>2018-01-17T00:00:00+09:00</updated><id>http://localhost:4000/posts/atom0</id><content type="html" xml:base="http://localhost:4000/posts/2018-01-17-atom0/"></content><author><name>-Yoda</name></author><category term="posts" /><category term="atom" /><summary type="html"></summary></entry><entry><title type="html">UX/UI fontsize customzing at atom editor</title><link href="http://localhost:4000/posts/2018-01-17-atom/" rel="alternate" type="text/html" title="UX/UI fontsize customzing at atom editor" /><published>2018-01-17T00:00:00+09:00</published><updated>2018-01-17T00:00:00+09:00</updated><id>http://localhost:4000/posts/atom</id><content type="html" xml:base="http://localhost:4000/posts/2018-01-17-atom/">&lt;p&gt;블로그 작성을 위해서 아톰 editor를 사용하는데
왼쪽 프로젝트의 파일 목록이 나오는 부분과, 파일명을 보여주는 부분의 글씨가 너무 작아서
불편함을 느끼고 있었다. 운영체제의 디스플레이 세팅을 통해서 글씨를 키워볼까 했는데
다른 부분은 모두 만족하고 사용하고 있었기 때문에 건들이기 싫었고 atom의 글씨 크기만
바꾸고 싶었다.&lt;/p&gt;

&lt;p&gt;그래서 검색!&lt;/p&gt;

&lt;p&gt;그리고 찾았다!! 아래는 해당 링크
 &lt;a href=&quot;https://github.com/atom/atom/issues/2530&quot;&gt;https://github.com/atom/atom/issues/2530&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;좀 더 자세히 설명을 남기자면 메뉴에서 settings를 찾아 들어가면
왼쪽 메뉴 맨 밑에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Open Config Folder&lt;/code&gt;라는 버튼이 있다. 해당 버튼을 누르면 아톰설정을
입맛에 맞게 customizing 할 수 있는 폴더 구성이 나오는데 fontsize를 바꾸기 위해서는 가장
밑에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;styles.less&lt;/code&gt;파일을 열고 아래 코드를 붙여넣기 하면 된다.
(글씨 크기는 본인이 원하는 만큼 알아서 적용하자)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@font-size: 15px;
html, body, .tree-view, .tab-bar .tab {
  font-size: @font-size;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><category term="posts" /><category term="ide" /><category term="atom" /><summary type="html">블로그 작성을 위해서 아톰 editor를 사용하는데 왼쪽 프로젝트의 파일 목록이 나오는 부분과, 파일명을 보여주는 부분의 글씨가 너무 작아서 불편함을 느끼고 있었다. 운영체제의 디스플레이 세팅을 통해서 글씨를 키워볼까 했는데 다른 부분은 모두 만족하고 사용하고 있었기 때문에 건들이기 싫었고 atom의 글씨 크기만 바꾸고 싶었다.</summary></entry><entry><title type="html">1월15일~21일</title><link href="http://localhost:4000/til/2018-01-15-1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC/" rel="alternate" type="text/html" title="1월15일~21일" /><published>2018-01-15T00:00:00+09:00</published><updated>2018-01-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC</id><content type="html" xml:base="http://localhost:4000/til/2018-01-15-1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC/">&lt;h3 id=&quot;1월-15일-월요일&quot;&gt;1월 15일 월요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부 &lt;a href=&quot;http://localhost:4000/records/2018-01-15-Hello_Digital_World/&quot;&gt;(링크)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1월-17일-수요일&quot;&gt;1월 17일 수요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부 &lt;a href=&quot;http://localhost:4000/records/2018-01-15-Hello_Digital_World/&quot;&gt;(링크)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>-Yoda</name></author><category term="til" /><summary type="html">1월 15일 월요일</summary></entry><entry><title type="html">Hello_digital_world</title><link href="http://localhost:4000/records/2018-01-15-Hello_Digital_World/" rel="alternate" type="text/html" title="Hello_digital_world" /><published>2018-01-15T00:00:00+09:00</published><updated>2018-01-15T00:00:00+09:00</updated><id>http://localhost:4000/records/Hello_Digital_World</id><content type="html" xml:base="http://localhost:4000/records/2018-01-15-Hello_Digital_World/">&lt;h1 id=&quot;커니핸-교수의-hello-digital-world-공부&quot;&gt;커니핸 교수의 Hello Digital World 공부&lt;/h1&gt;

&lt;p&gt;제이펍 출판사에서 출판한 &lt;code class=&quot;highlighter-rouge&quot;&gt;커니핸 교수의 Hello Digital World&lt;/code&gt;를 공부하며 오래 기억하고 싶은 내용들을 기록한 게시물 입니다.&lt;/p&gt;

&lt;p&gt;저작권 관련 문제가 있을 경우 블로그에서 내리겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;소프트웨어의-계층&quot;&gt;소프트웨어의 계층&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;하드웨어
커널
운영체제
라이브러리집합(API를 통해 접근 가능)
애플리케이션
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;운영 체제와 애플리케이션 사이의 경계는 뚜렷하게 정의되어 있지 않다. 완벽하진 않아도 유용한 지침은 한 애플리케이션이 다른 애플리케이션을 간섭하지 않도록 보장하는 데 필요한 것은 무엇이든 운영체제의 일부라는 점이다. 메모리 관리, 즉 프로그램이 실행되는 동안 메모리 어디에 프로그램을 둘지 결정하는 일은 운영 체제의 일부다. 마찬가지로 디스크 어디에 정보를 저장할 것인지 결정하는 파일 시스템은 핵심적인 기능이다. 장치의 제어도 마찬가지다. 두 개의 애플리케이션이 프린터를 동시에 작동시킬 수 있어서는 안 되고, 중간 조정 없이 디스플레이에 값을 기록해서도 안된다. 중심에서 CPU를 제어하는 일은 운영 체제의 기능인데 다른 모든 속성을 보장하기 위해 필요한 일이기 때문이다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다시 이야기 하면 애플리케이션이 컴퓨터 자원을 사용하는데 있어서 다른 애플리케이션의 간섭을 받지 않고 독립적으로 우영될 수 있도록 도와주는 일은 운영 체제의 영역.&lt;/p&gt;

&lt;h3 id=&quot;자바스크립트-예제-중-변수에-대해서&quot;&gt;자바스크립트 예제 중 변수에 대해서&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;변수란 프로그램이 실행되는 동안 프로그램이 값을 저장할 수 있는 RAM상의 장소를 뜻한다. 프로그램이 무엇을 하는지에 따라 값이 변경될 수 있기 때문에 변수라고 한다. 변수를 선언하는 것은 모형 어셈블리 언어에서 했던 것처럼 메모리 위치에 이름을 지정하는 일의 고수준 언어 버전이다. 은유적으로, 선언문은 ‘등장인물들’로, 희곡에 나오는 인물의 목록이다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;광케이블에-대하여&quot;&gt;광케이블에 대하여&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;광케이블&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;광케이블&lt;/strong&gt;(光cable, optical cable)이란 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B4%91%EC%84%AC%EC%9C%A0&quot;&gt;광섬유&lt;/a&gt;를 이용한 하나의 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=%ED%86%B5%EC%8B%A0_%EB%A7%A4%EC%B2%B4&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;통신 매체&lt;/a&gt;이다. 광케이블은 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=%EA%B5%AC%EB%A6%AC%EC%84%A0&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;구리선&lt;/a&gt;을 사용하는 통신방식보다 자료 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1%EC%86%8D%EB%8F%84&quot;&gt;전송속도&lt;/a&gt;가 수십 배로 빠르나, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC&quot;&gt;네트워크&lt;/a&gt;를 새로 구축해야 한다는 단점이 있다.&lt;/p&gt;

  &lt;p&gt;(위키백과 발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;광섬유&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;광학섬유라고도 한다. 이 현상을 이용하여 빛을 전송할 때 광손실을 줄이기 위하여 투명도가 고도로 높은 재료가 필요하며, 고순도의 석영이나 광학적 성질이 우수한 고분자재료를 사용한다. 광섬유는 1970년에 미국의 코닝사가 저손실석영섬유를 개발한 것을 계기로 개량을 거듭하여 광통신의 실용화에 크게 이용되고 있다.&lt;/p&gt;

  &lt;p&gt;광통신은 광섬유의 한쪽 끝에서 전기신호를 따라 점멸하는 발광소자를 써서 빛을 점멸하면 광섬유의 다른 쪽 끝에서 수광소자를 써서 이 점멸하는 빛을 받을 수 있는 현상을 이용한 것이다. 수광소자로서 포토다이오드를 쓰면 점멸하는 빛의 신호를 전기신호로 바꿀 수 있고, 발광소자로는 1초 동안에 4억 회나 점멸할 수 있는 발광다이오드도 개발되어 있다. 이 발광소자를 쓰면 광섬유 하나로써 5,760회선의 전화통화가 가능해진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;광케이블은 광섬유를 이용한 것인데 전기 신호를 빛으로의 점멸로 바꾸고 광섬유로 보내서 한쪽 끝에서는 점멸하는 빛을 받아서 전기신호로 바꾸는 것&lt;/p&gt;

&lt;p&gt;이런 기술을 통해서 멀리 떨어진 사람들과 통신할 수 있다는 사실에 대해서 너무나 놀랍고, 이런기술을 만들어낸 기술자들에 대해서 경외심을 가지게 된다.&lt;/p&gt;

&lt;h3 id=&quot;이더넷&quot;&gt;이더넷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;컴퓨터끼리 연결하거나 프린터 같은 공유 자원에 연결하기 위해 1970년대 초 로버트 메트칼프와 데이빗 바그스가 발명한 네트워킹 기술.&lt;/p&gt;

  &lt;p&gt;(발췌요약)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;패킷&quot;&gt;패킷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이더넷에 대한 정보는 패킷으로 전송된다. 패킷(packet)은 정보를 전송하기 위해 담아 두었다가 수신되면 열어 볼 수 있도록 정확히 정의된 형식으로 정보를 담고 있는 일련의 비트 또는 바이트다. 패킷이 발신자 주소, 수신자 주소, 내용, 여러가지 기타 정보가 표준 형식으로 구성돼 있는 봉투(또는 아마도 엽서)라고 생각하면 상당히 적절한 비유라고 볼 수 있고, 페덱스 같은 택배 회사에서 이용하는 표준화된 포장용 상자도 괜찮은 비유다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;프로토콜&quot;&gt;프로토콜&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;광섬유, 이더넷, 무선 등 서로 다른 물성을 가지고 서로 멀리 떨어져 있을지 모를 네트워크를 어떻게 연결할까? 네트워크와 컴퓨터를 식별하고 조회할 수 있도록 이름과 주소가 필요한데, 전화번호부에서 이름으로 전화번호를 찾는 것과 비슷한 방식을 사용한다. 또한 직접 연결되지 않은 네트워크 사이의 경로를 찾을 수 있어야 한다. 정보가 이동함에 따라 그 형식이 어떻게 바뀌는지, 그리고 오류, 지연, 과부하에 대처하는 것 같은 다수의 다른 덜 명백한 문제에 대해 합의를 봐야한다. 그러한 합의가 없으면 통신하기가 어렵거나 심지어 불가능 할 수 있다.&lt;/p&gt;

  &lt;p&gt;누가 먼저 말하고 어떤 응답이 이어질 수 있는지, 오류를 어떻게 처리할 것인지 등 데이터 형식에 대한 합의는 모든 네트워크에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;프로토콜&lt;/code&gt;을 이용하여 처리되는데, 인터넷에서는 특히 더 그렇다. &lt;code class=&quot;highlighter-rouge&quot;&gt;프로토콜&lt;/code&gt;은 일반적인 담화에서와 어느 정도 같은 의미를 지닌다. 즉, 상대방과 소통하기 위한 일련의 규칙이다. 하지만 네트워크 프로토콜은 사회적 관습이 아닌 기술적 고려 사항을 기반으로 하며, 가장 엄격한 사회 구조의 규칙보다도 훨씬 더 엄밀하게 정의된다.&lt;/p&gt;

  &lt;p&gt;규칙이 완전히 명백하지는 않을 수도 있지만, 인터넷은 그러한 규칙을 강하게 필요로 한다. 정보를 형식화하는 방법, 컴퓨터 간에 정보를 교환하는 방법, 컴퓨터를 식별하고 인증하는 방법, 무언가가 실패할 때 수행할 작업에 대한 프로토콜 및 표준에 모두 동의해야 한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;인터넷-개요&quot;&gt;인터넷 개요&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;오늘날 인터넷은 느슨하게 연결된 수백만 개의 독립적인 네트워크로 구성된다. 가까이 있는 컴퓨터들은 근거리 통신망(종종 무선 이더넷)으로 연결된다. 다음으로 네트워크는 하나의 네트워크에서 다음 네트워크로 정보 패킷을 라우팅하는 특수한 컴퓨터인 &lt;code class=&quot;highlighter-rouge&quot;&gt;게이트웨이&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;라우터&lt;/code&gt;를 통해 다른 네트워크에 연결된다. 게이트웨이는 라우팅 정보를 교환하여 적어도 국지적인 방식으로라도 무엇이 연결되어 있고 그래서 접근 가능한지 알게 된다.&lt;/p&gt;

  &lt;p&gt;각 네트워크는 가정, 사무실, 기숙사에 있는 컴퓨터와 전화 같은 많은 호스트 시스템을 연결할 수도 있다. 가정 내의 개별 컴퓨터는 라우터에 연결하기 위해 무선을 사용할 가능성이 있고, 라우터는 케이블이나 DSL로 인터넷 서비스 제공업체(Internet Service Provider), 즉 ISP에 연결된다. 반변 사무실에 있는 컴퓨터는 유선 이더넷 연결을 사용할 수도 있다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip-패킷&quot;&gt;IP 패킷&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전 장에서 언급했듯이 정보는 패킷이라고 하는 덩어리로 네트워크를 통해 이동한다. 패킷은 지정된 형식의 바이트 시퀀스로, 다른 장치는 다른 패킷 형식을 사용한다. 패킷의 일부에는 패킷이 어디서 오고 어디로 향하는지를 알려주는 주소정보가 들어있다. 패킷의 나머지 부분에는 길이 같은 패킷 자체에 대한 정보가 들어있고, 마지막으로는 전달하는 정보인 &lt;code class=&quot;highlighter-rouge&quot;&gt;페이로드(payload)&lt;/code&gt;가 들어있다.&lt;/p&gt;

  &lt;p&gt;인터넷에서 데이터는 IP 패킷(IP packet, IP는 ‘인터넷 프로토콜’을 의미)으로 전달된다. IP 패킷은 모두 같은 형식으로 되어 있다. 특정 물리적 네트워크에서 IP 패킷은 하나 이상의 물리적 패킷으로 전송될 수 있다. 예를 들어, 가능한 한 가장 큰 이더넷 패킷(약 1500바이트)이 가능한 한 가장 큰 IP패킷(약 65000바이트)보다 훨씬 작기 때문에 큰 IP패킷은 여러개의 작은 이더넷 패킷으로 분할된다.&lt;/p&gt;

  &lt;p&gt;각 IP 패킷은 여러 개의 게이트웨이를 통과한다. 각 게이트웨이는 최종 수신지에 더 가까운 게이트웨이로 패킷을 보낸다. 패킷이 여기저기로 이동함에 따라, 여남은 개의 다른 회사나 기관이 소유하고 운영하며 다른 국가에 있을 확률이 꽤 높은 20개의 게이트웨이를 통과할 수도 있다. 트래픽은 최단 경로를 따를 필요가 없다. 편의성과 비용으로 인해 더 긴 경로를 통해 패킷을 라우팅할 가능성이 있다. 발신지와 수신지가 미국 이외 지역으로 되어 있는 많은 패킷이 미국을 통과하는 케이블을 사용하는데, 이 점을 이용하여 NSA가 전 세계의 트래픽을 기록한 것이다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip-주소의-할당&quot;&gt;IP 주소의 할당&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;중앙 기관은 연속적인 IP 주소 블록을 네트워크 관리자에게 할당하고, 네트워크 관리자는 네트워크상의 호스트 컴퓨터들에 개별 주소를 할당한다. 따라서 각 호스트 컴퓨터에는 자신이 있는 네트워크에 따라 로컬로 할당된 고유한 주소가 있다. 이 주소는 데스크톱 컴퓨터에서는 영구적일 수 있지만, 모바일 장치의 경우 동적이며 적어도 장치가 인터넷에 다시 연결될 때마다 바뀐다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip와-tcp&quot;&gt;IP와 TCP&lt;/h3&gt;

&lt;p&gt;IP는 Internet Protocol을 뜻한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;인터넷 프로토콜&lt;/strong&gt;(&lt;strong&gt;IP&lt;/strong&gt;, &lt;strong&gt;I&lt;/strong&gt;nternet &lt;strong&gt;P&lt;/strong&gt;rotocol, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4&quot;&gt;문화어&lt;/a&gt;: 호상망규약)은 송신 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%98%B8%EC%8A%A4%ED%8A%B8&quot;&gt;호스트&lt;/a&gt;와 수신 호스트가 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7_%EA%B5%90%ED%99%98_%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC&quot;&gt;패킷 교환 네트워크&lt;/a&gt;(패킷 스위칭 네트워크, Packet Switching Network)에서 정보를 주고받는 데 사용하는 정보 위주의 규약(프로토콜, Protocol)이며, OSI 네트워크 계층에서 호스트의 주소지정과 패킷 분할 및 조립 기능을 담당한다. 줄여서 &lt;strong&gt;아이피&lt;/strong&gt;(IP)라고도 한다.&lt;/p&gt;

  &lt;p&gt;IP의 정보는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%8C%A8%ED%82%B7&quot;&gt;패킷&lt;/a&gt; 혹은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8&quot;&gt;데이터그램&lt;/a&gt;이라고 하는 덩어리로 나뉘어 전송된다. IP에서는 이전에 통신한 적 없는 호스트에 패킷을 보낼 때 경로 설정이 필요없다.&lt;/p&gt;

  &lt;p&gt;IP는 비신뢰성(unreliability)과 비연결성(connectionlessness)이 특징이다. 비신뢰성은 흐름에 관여하지 않기 때문에 보낸 정보가 제대로 갔는지 보장하지 않는다는 뜻이다. 예를 들어 전송과정에서 패킷이 손상될 수도 있고, 같은 호스트에서 전송한 패킷의 순서가 뒤죽박죽이 될 수도 있고, 같은 패킷이 두 번 전송될 수도 있으며, 아예 패킷이 사라질 수도 있다. 패킷 전송과 정확한 순서를 보장하려면 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;TCP&lt;/a&gt; 프로토콜과 같은 IP의 상위 프로토콜을 이용해야 한다.&lt;/p&gt;

  &lt;p&gt;현재 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7&quot;&gt;인터넷&lt;/a&gt;에서 사용하는 표준 프로토콜은 인터넷 프로토콜의 4번째 판인 &lt;a href=&quot;https://ko.wikipedia.org/wiki/IPv4&quot;&gt;IPv4&lt;/a&gt;이다. 그러나 IPv4는 주소공간 고갈 문제를 겪고 있어 조만간 6번째 판인 &lt;a href=&quot;https://ko.wikipedia.org/wiki/IPv6&quot;&gt;IPv6&lt;/a&gt;가 대중화될 것으로 보인다. &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%86%8C%ED%94%84%ED%8A%B8&quot;&gt;마이크로소프트&lt;/a&gt; &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9C%88%EB%8F%84_7&quot;&gt;윈도 7&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/OS_X&quot;&gt;OS X&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4&quot;&gt;리눅스&lt;/a&gt; 등 현재 널리 쓰이고 있는 대부분의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9A%B4%EC%98%81_%EC%B2%B4%EC%A0%9C&quot;&gt;운영 체제&lt;/a&gt;는 IPv6 프로토콜을 지원한다.&lt;/p&gt;

  &lt;p&gt;(위키백과 발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;인터넷 프로토콜 스위트&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;인터넷 프로토콜 스위트&lt;/strong&gt;(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%81%EC%96%B4&quot;&gt;영어&lt;/a&gt;: Internet Protocol Suite)는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7&quot;&gt;인터넷&lt;/a&gt;에서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%BB%B4%ED%93%A8%ED%84%B0&quot;&gt;컴퓨터&lt;/a&gt;들이 서로 정보를 주고받는 데 쓰이는 통신규약(&lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;프로토콜&lt;/a&gt;)의 모음이다. 인터넷 프로토콜 스위트 중 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;TCP&lt;/a&gt;와 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;IP&lt;/a&gt;가 가장 많이 쓰이기 때문에 &lt;strong&gt;TCP/IP 프로토콜&lt;/strong&gt; 스위트라고도 불린다.&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8&quot;&gt;(위키백과 발췌)&lt;/a&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/OSI_%EB%AA%A8%ED%98%95&quot;&gt;OSI 모형 참조, 위키백과 발췌&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TCP&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;IP 위에 있는 TCP(Transmission Control Protocol: 전송 제어 프로토콜)라는 프로토콜은 IP를 사용하여 발신지에서 수신지까지 임의 길이의 바이트 시퀀스를 전송하는 안정적인 메커니즘을 제공한다. TCP 위에서는 고수준의 프로토콜들이 웹 브라우징, 메일, 파일 공유 등 우리가 ‘인터넷’ 이라고 생각하는 서비스를 제공하기 위해 TCP를 사용한다. 다른 프로토콜도 많이 있다. 예를 들어, 동적으로 IP 주소를 변경하는 것은 DHCP(동적 호스트 구성 프로토콜)라는 프로토콜에 의해 처리된다. 이 프로토콜들이 모두 합쳐져서 인터넷을 정의한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;전송 제어 프로토콜&lt;/strong&gt;(&lt;strong&gt;T&lt;/strong&gt;ransmission &lt;strong&gt;C&lt;/strong&gt;ontrol &lt;strong&gt;P&lt;/strong&gt;rotocol, &lt;strong&gt;TCP&lt;/strong&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%AC%B8%ED%99%94%EC%96%B4&quot;&gt;문화어&lt;/a&gt;: 전송조종규약)은 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C_%EC%8A%A4%EC%9C%84%ED%8A%B8&quot;&gt;인터넷 프로토콜 스위트&lt;/a&gt;(IP)의 핵심 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%ED%86%B5%EC%8B%A0_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;프로토콜&lt;/a&gt; 중 하나로, IP와 함께 &lt;em&gt;TCP/IP&lt;/em&gt;라는 명칭으로도 널리 불린다. TCP는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B7%BC%EA%B1%B0%EB%A6%AC_%ED%86%B5%EC%8B%A0%EB%A7%9D&quot;&gt;근거리 통신망&lt;/a&gt;이나 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%8A%B8%EB%9D%BC%EB%84%B7&quot;&gt;인트라넷&lt;/a&gt;, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%EB%84%B7&quot;&gt;인터넷&lt;/a&gt;에 연결된 컴퓨터에서 실행되는 프로그램 간에 일련의 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%98%A5%ED%85%9F_(%EC%BB%B4%ED%93%A8%ED%8C%85)&quot;&gt;옥텟&lt;/a&gt;을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다. TCP는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EA%B3%84%EC%B8%B5&quot;&gt;전송 계층&lt;/a&gt;에 위치한다. 네트워크의 정보 전달을 통제하는 프로토콜이자 인터넷을 이루는 핵심 프로토콜의 하나로서 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EA%B5%AD%EC%A0%9C_%EC%9D%B8%ED%84%B0%EB%84%B7_%ED%91%9C%EC%A4%80%ED%99%94_%EA%B8%B0%EA%B5%AC&quot;&gt;국제 인터넷 표준화 기구&lt;/a&gt;(IETF)의 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=RFC_793&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;RFC 793&lt;/a&gt;에 기술되어 있다.&lt;/p&gt;

  &lt;p&gt;TCP는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80&quot;&gt;웹 브라우저&lt;/a&gt;들이 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%94%EB%93%9C_%EC%99%80%EC%9D%B4%EB%93%9C_%EC%9B%B9&quot;&gt;월드 와이드 웹&lt;/a&gt;에서 서버에 연결할 때 사용되며, &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%A9%94%EC%9D%BC&quot;&gt;이메일&lt;/a&gt; 전송이나 파일 전송에도 사용된다.&lt;/p&gt;

  &lt;p&gt;TCP의 안정성을 필요로 하지 않는 애플리케이션의 경우 일반적으로 TCP 대신 &lt;a href=&quot;https://ko.wikipedia.org/w/index.php?title=%EB%B9%84%EC%A0%91%EC%86%8D%ED%98%95_%ED%86%B5%EC%8B%A0&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;비접속형&lt;/a&gt; &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%82%AC%EC%9A%A9%EC%9E%90_%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B7%B8%EB%9E%A8_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C&quot;&gt;사용자 데이터그램 프로토콜&lt;/a&gt;(User Datagram Protocol)을 사용한다. 이것은 전달 확인 및 순차 보장 기능이 없는 대신 오버헤드가 작고 지연시간이 짧다는 장점이 있다.&lt;/p&gt;

  &lt;p&gt;(위키백과 발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TCP/IP 프로토콜&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;인터넷에는 많은 프로토콜이 있으며 그중 두 가지는 정말 필수적이다. IP는 인터넷 프로토콜(Internet Protocol)이다. IP는 개별 패킷의 형식을 지정하고 패킷을 전송하는 방법을 정의한다. TCP, 즉 전송 제어 프로토콜(Transmission Control Protocol)은 IP 패킷을 데이터 스트림으로 결합하고 서비스에 연결하느 방법을 정의 한다. 이 둘을 합쳐서 TCP/IP라고 한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;IP 레벨 위에서는 TCP가 안정적인 통신을 제공하므로 사용자(실제로는 프로그래머)가 정보의 스트림에 불과한 패킷에 관해 생각할 필요가 없다. 우리가 ‘인터넷’이라고 생각하는 서비스의 대부분은 TCP를 사용한다.&lt;/p&gt;

  &lt;p&gt;이 프로토콜들 위에는 웹, 메일, 파일 전송 등의 서비스를 제공하는 애플리케이션 레벨 프로토콜들이 있고, 주로 TCP에 기반을 두고 구현된다. 따라서 여러 개의 프로토콜 계층이 있고, 각각은 아래에 있는 프로토콜 서비스에 의존하고 위에 있는 프로토콜에 서비스를 제공한다. 이것은 6장에서 설명한 소프트웨어의 계층화에 대한 매우 좋은 예다.&lt;/p&gt;

  &lt;p&gt;UDP, 즉 사용자 데이터그램 프로토콜(User Datagram Protocol)은 TCP와 같은 레벨의 또 다른 프로토콜이다. UDP는 TCP보다 훨씬 간단하고 양방향 스트림을 필요로 하지 않는 데이터 교환에 사용되며, 몇 가지 추가 기능을 갖출 효율적인 패킷을 전달만 가능하다. DNS가 UDP를 사용하고, 비디오 스트리밍, VoIP, 일부 온라인 게임도 UDP를 사용한다.&lt;/p&gt;

  &lt;p&gt;(발췌)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     [애플리케이션]
    [    TCP    ]
  [       IP       ]
[       물리 계층       ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;상위-레벨-프로토콜&quot;&gt;상위 레벨 프로토콜&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;TCP는 두 대의 컴퓨터 간에 데이터를 주고받는 신뢰할 수 있는 양방향 스트림을 제공한다. 인터넷 서비스와 애플리케이션은 TCP를 전송 메커니즘으로 사용하지만, 필요한 기능에 특유한 자신만의 프로토콜을 가지고 있다. 예를 들어, HTTP, 즉 하이퍼텍스트 전송 프로토콜(HyperText Transfer Protocol)은 웹 브라우저와 서버에서 사용되는 특히 간단한 프로토콜이다. 링크를 클릭하면 브라우저가 서버(가령 amazon.com)의 포트 80에 TCP/IP연결을 열고 특정 페이지를 요청하는 짧은 메시지를 보낸다. 그림 9.6에서 브라우저는 왼쪽 상단의 클라이언트 애플리케이션이다. 메시지는 프로토콜 체인을 따라 내려가서 인터넷을 건너고(보통 후러씬 더 많은 단계를 거친다), 반대쪽 끝에서 상응하는 서버 애플리케이션까지 올라간다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(클라이언트)                                                        (서버)
앱                                                                 앱
TCP             (게이트웨이)       (게이트웨이)  (게이트웨이)            TCP
IP                 IP                IP     ... IP                 IP
	-&amp;gt; 물리 계층 -&amp;gt;     -&amp;gt; 물리 계층 -&amp;gt;     -&amp;gt;         -&amp;gt; 물리 계층  -&amp;gt;
	  (예:전화)          (예:광섬유)                     (예:이더넷)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">커니핸 교수의 Hello Digital World 공부</summary></entry><entry><title type="html">Docker관련</title><link href="http://localhost:4000/records/2017-11-16-docker%EA%B4%80%EB%A0%A8/" rel="alternate" type="text/html" title="Docker관련" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/records/docker%EA%B4%80%EB%A0%A8</id><content type="html" xml:base="http://localhost:4000/records/2017-11-16-docker%EA%B4%80%EB%A0%A8/">&lt;h1 id=&quot;docker-세팅&quot;&gt;Docker 세팅&lt;/h1&gt;

&lt;p&gt;도커를 처음 설치하고 나서 다음 명령어로 우분투 이미지를 다운받고 해당 운영체제를 실행할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm it ubuntu:16:04 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜진 도커환경 안에서는 처음부터 root권한이 주어지기 때문에 sudo입력 없이도 여러가지 설치 명령을 실행시킬 수 있다.&lt;/p&gt;

&lt;p&gt;Dockerfile.base 이미지 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t base -f Dockerfile.base .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile.base를 기준으로 우리가 쓸 도커(container) 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t eb .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만든 이미지 확인 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker(Container) 실행시키는 명령어(예: eb)&lt;/p&gt;

&lt;p&gt;(마지막의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/zsh&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;옵션으로 프로그램을 실행시키기 위해 입력해주는 것, &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;터미널 형식으로 연다는 뜻, &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt;옵션은 컨테이너가 꺼졌을 때 삭제한다는 의미)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker를 외부랑 연결시키기 위해서 옵션을 추가한 멸영어&lt;/p&gt;

&lt;p&gt;(우리가 8012로 접근하면 docker는 80으로 받는다. 우리가 8013으로 접근하면 docker는  8000으로 받는다. 80번 포트와 8000포트를 둘다 테스트해보고 싶을 때 이런식으로 쓴다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it -p 8012:80 -p 8013:8000 eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜져있는 도커에 접속할 수 있는 명령어 (4317은 docker id)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와같은 명령어를 아래와 같이 접속도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행되고 있는 이미지 파일(container) 정보 확인하는 명령어&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">Docker 세팅</summary></entry><entry><title type="html">Ecs</title><link href="http://localhost:4000/records/2017-11-16-ECS/" rel="alternate" type="text/html" title="Ecs" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/records/ECS</id><content type="html" xml:base="http://localhost:4000/records/2017-11-16-ECS/">&lt;p&gt;도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기&lt;/p&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기</summary></entry><entry><title type="html">Postgresql</title><link href="http://localhost:4000/records/2017-10-15-postgresql/" rel="alternate" type="text/html" title="Postgresql" /><published>2017-10-15T00:00:00+09:00</published><updated>2017-10-15T00:00:00+09:00</updated><id>http://localhost:4000/records/postgresql</id><content type="html" xml:base="http://localhost:4000/records/2017-10-15-postgresql/">&lt;h1 id=&quot;명령어-기록-ubuntu-1604&quot;&gt;명령어 기록 (ubuntu-1604)&lt;/h1&gt;

&lt;h3 id=&quot;데이터베이스-생성&quot;&gt;데이터베이스 생성&lt;/h3&gt;
&lt;p&gt;커맨드창 에서 ‘zoozoo’라는 계정 이름으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;testname&lt;/code&gt;이라는 데이터베이스를 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;createdb testname --owner=zoozoo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE testname OWNER zoozoo;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 이름이 대문자인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;(쌍따옴표)로 데이터베이스 이름을 감싸서 명령을 실행시켜야 실행이 된다.&lt;/p&gt;

&lt;h3 id=&quot;기본생성된-사용자-이름으로-postgresql연결&quot;&gt;기본생성된 사용자 이름으로 postgresql연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 postgres 데이터베이스에 연결한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;postgres-사용자로-다른-데이터베이스-연결&quot;&gt;postgres 사용자로 다른 데이터베이스 연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 testdb 데이터베이스에 연결한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql testdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-삭제터미널-창에서&quot;&gt;데이터베이스 삭제(터미널 창에서)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres dropdb &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 삭제&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP DATABASE &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-목록확인-데이터베이스-명령어&quot;&gt;데이터베이스 목록확인 (데이터베이스 명령어)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\ㅣ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;특정-데이터베이스에-접속&quot;&gt;특정 데이터베이스에 접속&lt;/h3&gt;
&lt;p&gt;ex) database명 instagram&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;psql instagram
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;위의-특정-데이터베이스에-접속-후-관련-테이블-확인&quot;&gt;위의 특정 데이터베이스에 접속 후 관련 테이블 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dt\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;테이블의-전체-내용-확인&quot;&gt;테이블의 전체 내용 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from 테이블명
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용자-비밀번호-변경하기&quot;&gt;사용자 비밀번호 변경하기&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo -u postgres psql template1&lt;/code&gt; 명령을 통해 데이터베이스 접속&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ALTER USER postgres with encrypted password 'your_password';&lt;/code&gt; 명령을 통해 패스워드 변경 아래는 예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER USER James with encrypted password 'asldkhf';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl restart postgresql.service&lt;/code&gt;명령을 통해 postgresql 재시작&lt;/li&gt;
&lt;/ol&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">명령어 기록 (ubuntu-1604)</summary></entry><entry><title type="html">Dajngo_queryset_method</title><link href="http://localhost:4000/records/2017-10-14-dajngo_querySet_method/" rel="alternate" type="text/html" title="Dajngo_queryset_method" /><published>2017-10-14T00:00:00+09:00</published><updated>2017-10-14T00:00:00+09:00</updated><id>http://localhost:4000/records/dajngo_querySet_method</id><content type="html" xml:base="http://localhost:4000/records/2017-10-14-dajngo_querySet_method/">&lt;h1 id=&quot;queryset-api&quot;&gt;QuerySet API&lt;/h1&gt;

&lt;h2 id=&quot;methods-that-return-new-querysets&quot;&gt;Methods that return new QuerySets&lt;/h2&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개 변수와 일치하는 객체가 포함 된 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;복잡한 쿼리문을 사용해야 할 경우 Q objects를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;exclude&quot;&gt;exclude()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개변수와 일치하는 객체가 포함되지 않은 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;h3 id=&quot;annotate&quot;&gt;annotate()&lt;/h3&gt;

&lt;p&gt;제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다.제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다. 표현식은 단순 값, 모델의 필드에 대한 참조 (또는 모든 관련 모델), 또는 개체의 개체와 관련하여 계산 된 집계 식 (평균, 합계 등)이 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;annotate ()에 대한 각 인수는 반환되는 QuerySet의 각 객체에 추가되는 주석입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.annotate(Count('entry'))
# The name of the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].name
'Blogasaurus'
# The number of entries on the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].entry__count
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 블로그 모델은 entry__count 속성을 단독으로 정의하지 않지만 키워드 인수를 사용하여 집계 함수를 지정하면 주석의 이름을 제어 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;order_by&quot;&gt;order_by()&lt;/h3&gt;

&lt;p&gt;기본적으로 QuerySet에 의해 반환 된 결과는 Model’s Meta의 정렬 옵션에 의해 주어진 순서 튜플에 의해 정렬됩니다. order_by 메소드를 사용하여 QuerySet 단위로이 값을 겹쳐 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과는 pub_date가 내림차순으로 정렬 된 다음 headline이 오름차순으로 정렬됩니다. “-pub_date”앞에있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 기호는 내림차순을 나타냅니다. 기본적으로 오름차순으로 정렬됩니다.&lt;/p&gt;

&lt;p&gt;렌덤으로 정렬하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;를 사용합니다. (아래 예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('?')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델의 필드로 정렬하려면 모델 관계를 쿼리 할 때와 같은 구문을 사용하십시오. 즉, 필드 이름과 이중 밑줄 (__), 새 모델의 필드 이름 등이 포함되며, 원하는만큼의 모델을 추가 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델과 관계가있는 필드로 정렬하려고하면 Django는 관련 모델의 기본 순서를 사용하거나 Meta.ordering이 지정되지 않은 경우 관련 모델의 기본 키순으로 정렬합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 블로그 모델에는 기본 주문이 지정되어 있지 않으므로&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시는 아래의 예시와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__id')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 Blog 테이블에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ordering = ['name']&lt;/code&gt; 이 지정되어 있다면 위의 첫번째 쿼리는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reverse&quot;&gt;reverse()&lt;/h3&gt;

&lt;p&gt;reverse() 메서드를 사용하여 쿼리셋 결과물을 반대방향으로 정렬할 수 있습니다. reverse()를 한번더 호출하면 기존의 순서대로 다시 정렬할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 쿼리셋으로 끝에서 5번째까지의 항목을 불러올 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_queryset.reverse()[:5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django에서는 파이썬에서 사용할 수 잇는 [-1:] 과 같은 역 슬라이스를 사용하지 않습니다.   SQL에서 효율적으로 수행 할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한 reverse ()는 일반적으로 정의 된 순서가있는 QuerySet에서만 호출되어야합니다. 주어진 QuerySet에 대해 그러한 정렬이 정의되어 있지 않으면 reverse ()를 호출하면 아무런 효과가 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;distinct&quot;&gt;distinct()&lt;/h3&gt;

&lt;p&gt;SQL 쿼리에서 SELECT DISTINCT를 사용하는 새 QuerySet을 반환합니다. 이렇게하면 조회 결과에서 중복 행이 제거됩니다.&lt;/p&gt;

&lt;p&gt;기본적으로 QuerySet은 중복 행을 제거하지 않습니다. 실제로 Blog.objects.all ()과 같은 간단한 쿼리는 결과 행이 중복 될 가능성이 있기 때문에 거의 문제가되지 않습니다. 그러나 쿼리가 여러 테이블에 걸쳐있는 경우 QuerySet을 평가할 때 중복 결과를 얻을 수 있습니다. 이러한 상황에서 distinct ()를 사용하여 중복된 항목을 제거할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;values&quot;&gt;values()&lt;/h3&gt;

&lt;p&gt;iterable한 모델객체가 아닌 dictionary로 반환하는 쿼리셋입니다.&lt;/p&gt;

&lt;p&gt;반환된 dictionary는 모델 오브젝트의 속성이름을 키로, 가지고 데이터는 value로 가집니다.&lt;/p&gt;

&lt;p&gt;다음의 예시는 일반적인 쿼리셋과 values()쿼리셋의 차이를 보여줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This list contains a Blog object.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles')
&amp;lt;QuerySet [&amp;lt;Blog: Beatles Blog&amp;gt;]&amp;gt;

# This list contains a dictionary.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles').values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메소드는 모델이 가지고 있는 필드명을 인자로 가질 수 있습니다. 인자를 지정하지 않으면 모든 필드가 반환됩니다. (아래예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('id', 'name')
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메서드는 키워드인자로 annotate()를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values(lower_name=Lower('name'))
&amp;lt;QuerySet [{'lower_name': 'beatles blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;values_listfields-flatfalse&quot;&gt;values_list(*fields, flat=False)&lt;/h3&gt;

&lt;p&gt;values_list()는 dictionary를 반환하는 대신 튜플로 만들어진 리스트를 반환한다는 점을 제외하면 values ()와 유사합니다. 각 튜플에는 해당 필드의 값이나 values_list () 호출로 전달 된 표현식이 들어 있으므로 첫 번째 항목이 첫 번째 입력란이됩니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', 'headline')
&amp;lt;QuerySet [(1, 'First entry'), ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', Lower('headline'))
&amp;lt;QuerySet [(1, 'first entry'), ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 매게변수로 단일 필드 만 전달하면 flat 매개 변수를 전달할 수도 있습니다. flat=True이면 단일 튜플 아닌 단일 값으로 이루어진 리스트 반환합니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id').order_by('id')
&amp;lt;QuerySet[(1,), (2,), (3,), ...]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', flat=True).order_by('id')
&amp;lt;QuerySet [1, 2, 3, ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나 이상의 필드인자를 할당했는데 flat매게변수를 사용한다면 에러가 납니다.&lt;/p&gt;

&lt;p&gt;values_list ()에 값을 전달하지 않으면 모델의 모든 필드가 선언 된 순서대로 반환됩니다.&lt;/p&gt;

&lt;p&gt;values()와 values_list() 메서드는 모델 인스턴스를 생성하지 않고도 필드의 집합을 산출해 내는데에 최적화 되어 설계되었습니다. 관계가 형성되어있는 모델을 다룰 때에는 해당되지 않습니다. 한행에 하나의 객체가 할당되는 가정이 유지되지 않기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;datesfield-kind-orderasc&quot;&gt;dates(field, kind, order=’ASC’)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 모든 사용 가능한 날짜를 나타내는 datetime.date 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateField 여야 하며 종류는 “year”, “month” or “day”지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;datetimesfield_name--kind-orderasc-tzinfonone&quot;&gt;datetimes(field_name,  kind, order=’ASC’, tzinfo=None)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 사용 가능한 모든 날짜를 나타내는 datetime.datetime 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateTimeField 여야 하며 종류는 “year”, “month”,  “day”, “hour:, “minute”, “second”로지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;h3 id=&quot;none&quot;&gt;none()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;none ()을 호출하면 객체를 반환하지 않는 쿼리 세트가 만들어지며 결과에 액세스 할 때 쿼리가 실행되지 않습니다. qs.none () 쿼리 세트는 EmptyQuerySet의 인스턴스입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;all&quot;&gt;all()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;현재의 QuerySet (또는 QuerySet 서브 클래스)의 복사본을 반환합니다. 이는 모델 매니저 또는 QuerySet을 전달하고 결과에 대해 추가 필터링을 수행하려는 상황에서 유용 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unionother_qs-allfalse&quot;&gt;union(*other_qs, all=False)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 UNION 연산자를 사용하여 두 개 이상의 QuerySet 결과를 결합합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.union(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 all = True 인수를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;intersectionother_qs&quot;&gt;intersection(*other_qs)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 INTERSECT 연산자를 사용하여 두 개 이상의 QuerySets의 공통 요소를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.intersection(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select_relatedfields&quot;&gt;select_related(*fields)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;외래 키 관계가 형성되어 있는 QuerySet를 리턴 해, 조회를 실행할 때에 추가의 관련 오브젝트 데이터를 선택합니다. 이것은 하나의 복잡한 쿼리로 이어지는 성능 향상이지만 나중에 외래 키 관계를 사용하면 데이터베이스 쿼리가 필요하지 않음을 의미합니다. 다음 예제는 일반 조회와 select_related () 조회 간의 차이점을 보여줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 표준 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ex) select_related&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.select_related('blog').get(id=5)

# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한번에 관계가 이루어진 데이터베이스까지 조회해 와서 다음 쿼리시에 데이터베이스를 거치지 않고서도 원하는 정보를 산출해 낼 수 있다는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;select_related()쿼리는 다른 쿼리 객체와도 함께 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.utils import timezone

# Find all the blogs with entries scheduled to be published in the future.
blogs = set()

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;filter()와 select_related()의 체이닝 순서는 중요하지 않습니다. 어떤 것이 앞에 있더라도 결과는 동일합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select_related ()를 많은 관련 객체로 호출하거나 모든 관계를 모르는 경우가 있습니다. 이러한 경우에는 인수없이 select_related ()를 호출 할 수 있습니다. 이것은 발견 할 수있는 null이 아닌 모든 외래 키를 반환합니다. null 입력 가능 외래 키가 지정되어야합니다. 대부분의 경우에는 기본 쿼리를보다 복잡하게 만들고 실제로 필요한 것보다 많은 데이터를 반환하기 때문에 권장되지 않습니다.&lt;/p&gt;

&lt;p&gt;QuerySet에서 select_related의 이전 호출에 의해 추가 된 관련 필드 목록을 지우려면 매개 변수로 None을 전달할 수 있습니다.&lt;/p&gt;</content><author><name>-Yoda</name></author><category term="records" /><summary type="html">QuerySet API</summary></entry></feed>