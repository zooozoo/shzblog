<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-01-23T17:40:39+09:00</updated><id>http://localhost:4000/</id><title type="html">Record|Organize|Make it mine</title><subtitle>My programming study blog and I hope it help someone who struggling with code</subtitle><author><name>Seok Hun Zoo</name></author><entry><title type="html">전문가를 위한 파이썬</title><link href="http://localhost:4000/records/2018-01-23-Fluent_Python/" rel="alternate" type="text/html" title="전문가를 위한 파이썬" /><published>2018-01-23T00:00:00+09:00</published><updated>2018-01-23T00:00:00+09:00</updated><id>http://localhost:4000/records/Fluent_Python</id><content type="html" xml:base="http://localhost:4000/records/2018-01-23-Fluent_Python/"></content><author><name>Seok Hun Zoo</name></author><category term="records" /><summary type="html"></summary></entry><entry><title type="html">1월22일~28일</title><link href="http://localhost:4000/til/2018-01-22-1%EC%9B%9422%EC%9D%BC~28%EC%9D%BC/" rel="alternate" type="text/html" title="1월22일~28일" /><published>2018-01-22T00:00:00+09:00</published><updated>2018-01-22T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%9B%9422%EC%9D%BC~28%EC%9D%BC</id><content type="html" xml:base="http://localhost:4000/til/2018-01-22-1%EC%9B%9422%EC%9D%BC~28%EC%9D%BC/">&lt;h3 id=&quot;1월-22일-월요일&quot;&gt;1월 22일 월요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Try-Django-Tutorial youtube 강의 9커밋까지 완료&lt;/li&gt;
  &lt;li&gt;하루3분 네트워크 독서&lt;/li&gt;
  &lt;li&gt;블로그 정리
    &lt;ul&gt;
      &lt;li&gt;about page 내용 작성 및 records 내용 정리
-&amp;gt; 이전부터 쭉 작성해 왔던 것들인데 미완성 된 부분도 있고 구성에 일관성이 없어서 한번 다시 쭉 정리해야할 필요성을 느낌&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1월-23일-화요일&quot;&gt;1월 23일 화요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Try-Django-Tutorial youtube 강의 17커밋까지 완료&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;class based view&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;template include, extends&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;model&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Model 에서 DateTimeField 관련
모델에 DateTimeField를 적용 시켰는데 admin page에 보이질 않는다. 동영상 강의 에서는 분명히 보이는데 내가 안보이는 거라서 검색을 해봤고 stackoverflow에 다음과 같은 솔루션을 얻었다.&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;If you really want to see date in the admin panel, you can add readonly_fields in admin.py:

class RatingAdmin(admin.ModelAdmin):
    readonly_fields = ('date',)

admin.site.register(Rating,RatingAdmin)
Any field you specify will be added last after the editable fields. To control the order you can use the  fields options.

Additional information is available from the Django docs.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/6386172/datetimefield-doesnt-show-in-admin-system&quot;&gt;답변링크&lt;/a&gt;&lt;/p&gt;

        &lt;p&gt;그리고 그대로 적용해 보았고, 수정할 수 없는 상태로 잘 나온다. 
장고 문서에 아래와 같이 나와있어서&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;As currently implemented, setting auto_now or auto_now_add to True will cause the field to have editable=False and blank=True set.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;모델 속성을 다음과 같이 바꾸고&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;timestamp = models.DateTimeField(auto_now_add=True, editable=True, blank=True)
updated = models.DateTimeField(auto_now=True, editable=True, blank=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;

        &lt;p&gt;다시 admin에 나오나 확인해 봤는데 안나온다. 
auto_now_add, 와 auto_now 속성값이 editable과 blank를 True 설정되게 강제하는 것 같다. 
혹시 몰라서 모든 속성값을 지우고 admin에 나오나 해봤는데 나온다.&lt;/p&gt;

        &lt;p&gt;결국 auto_now_add, 와 auto_now 속성을 적용하고 admin에서 확인하기 위해서는 stackoverflow에 나온데로 admin 모듈에서 class로 설정해주는 방법이 현재로썬 최선인 것 같다.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;query set&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;장고 문서 복습 : &lt;code class=&quot;highlighter-rouge&quot;&gt;Making queries&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Templates(overview)&lt;/code&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Seok Hun Zoo</name></author><category term="til" /><summary type="html">1월 22일 월요일</summary></entry><entry><title type="html">UX/UI fontsize customzing at atom editor</title><link href="http://localhost:4000/posts/2018-01-17-atom/" rel="alternate" type="text/html" title="UX/UI fontsize customzing at atom editor" /><published>2018-01-17T00:00:00+09:00</published><updated>2018-01-17T00:00:00+09:00</updated><id>http://localhost:4000/posts/atom</id><content type="html" xml:base="http://localhost:4000/posts/2018-01-17-atom/">&lt;h3 id=&quot;아톰-에디터에서-uxui-글씨크기-바꾸기&quot;&gt;아톰 에디터에서 UX/UI 글씨크기 바꾸기&lt;/h3&gt;

&lt;p&gt;블로그 작성을 위해서 아톰 editor를 사용하는데
왼쪽 프로젝트의 파일 목록이 나오는 부분과, 파일명을 보여주는 부분의 글씨가 너무 작아서
불편함을 느끼고 있었다. 운영체제의 디스플레이 세팅을 통해서 글씨를 키워볼까 했는데
다른 부분은 모두 만족하고 사용하고 있었기 때문에 건들이기 싫었고 atom의 글씨 크기만
바꾸고 싶었다.&lt;/p&gt;

&lt;p&gt;그래서 검색!&lt;/p&gt;

&lt;p&gt;그리고 찾았다!! 아래는 해당 링크
 &lt;a href=&quot;https://github.com/atom/atom/issues/2530&quot;&gt;https://github.com/atom/atom/issues/2530&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;좀 더 자세히 설명을 남기자면 메뉴에서 settings를 찾아 들어가면
왼쪽 메뉴 맨 밑에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Open Config Folder&lt;/code&gt;라는 버튼이 있다. 해당 버튼을 누르면 아톰설정을
입맛에 맞게 customizing 할 수 있는 폴더 구성이 나오는데 fontsize를 바꾸기 위해서는 가장
밑에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;styles.less&lt;/code&gt;파일을 열고 아래 코드를 붙여넣기 하면 된다.
(글씨 크기는 본인이 원하는 만큼 알아서 적용하자)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@font-size: 15px;
html, body, .tree-view, .tab-bar .tab {
  font-size: @font-size;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Seok Hun Zoo</name></author><category term="posts" /><category term="ide" /><category term="atom" /><summary type="html">아톰 에디터에서 UX/UI 글씨크기 바꾸기</summary></entry><entry><title type="html">1월15일~21일</title><link href="http://localhost:4000/til/2018-01-15-1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC/" rel="alternate" type="text/html" title="1월15일~21일" /><published>2018-01-15T00:00:00+09:00</published><updated>2018-01-15T00:00:00+09:00</updated><id>http://localhost:4000/til/1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC</id><content type="html" xml:base="http://localhost:4000/til/2018-01-15-1%EC%9B%9415%EC%9D%BC~21%EC%9D%BC/">&lt;h3 id=&quot;1월-15일-월요일&quot;&gt;1월 15일 월요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1월-17일-수요일&quot;&gt;1월 17일 수요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1월-19일-금요일&quot;&gt;1월 19일 금요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;블로그 만들기
    &lt;ul&gt;
      &lt;li&gt;posts sidebar navigations에 자동으로 태그 목록 보여주도록 설정&lt;/li&gt;
      &lt;li&gt;개별 post 들어 갔을 때 sidebar가 제대로 표시되지 않았는데 header에 sidebar변수가 인식되지 않는 현상 발견
-&amp;gt; 형식에 맞는 새로운 sidebar html 파일을 만들어서 template에 적용&lt;/li&gt;
      &lt;li&gt;jekyll-archive가 git-page에서 적용되지 않는 현상 해결&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;1월-20일-토요일&quot;&gt;1월 20일 토요일&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커니핸 교수의 hello digital world 공부&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Seok Hun Zoo</name></author><category term="til" /><summary type="html">1월 15일 월요일</summary></entry><entry><title type="html">TIL 시작</title><link href="http://localhost:4000/til/2018-01-14-TIL/" rel="alternate" type="text/html" title="TIL 시작" /><published>2018-01-14T00:00:00+09:00</published><updated>2018-01-14T00:00:00+09:00</updated><id>http://localhost:4000/til/TIL</id><content type="html" xml:base="http://localhost:4000/til/2018-01-14-TIL/">&lt;p&gt;초보몽키라는 이름의 블로그를 운영하고 계신 이현주님의 블로그를 보면 Today I Learned 라는 카테고리로 포스팅을 해놓았습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://wayhome25.github.io/&quot;&gt;&amp;gt; 블로그 바로가기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;그것을 보는 순간!&lt;/p&gt;

&lt;p&gt;‘오~!!!!! 괜찮은 방법이다.’ 싶었습니다.&lt;/p&gt;

&lt;p&gt;그래서 저도 하루하루 제가 했던 일들에 대하여, 혹은 공부한 것 들에 대하여 기록하려고 합니다.&lt;/p&gt;

&lt;p&gt;사실 이렇게 누군가에게 알리고 싶지도 않고, 매일매일 공부하려는 다짐에 자신감도 조금 부족하지만&lt;/p&gt;

&lt;p&gt;이렇게 포스팅 하는 것 자체가 동기부여가 될 것 같아 시작하기로 다짐했습니다.&lt;/p&gt;

&lt;p&gt;처음 시작하다보니 무슨내용을 어떻게 얼마나 상세하게 적어나가야 할지… 잘 떠오르지 않았지만&lt;/p&gt;

&lt;p&gt;나중에 적는 방식이 바뀐다 하더라도 일단은 적어나가려고 합니다.&lt;/p&gt;

&lt;p&gt;이전에 학원에서 같이 하게된 프로젝트에서도 매일매일 이슈사항과 내가 한 일들 그리고 해야 할 것들을 적어 나갔는데&lt;/p&gt;

&lt;p&gt;그렇게 하던 방법대로 해 나가면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;오늘도 잠깐 다른 개발자들의 블로그를 보면서 경외심과 ‘대단하다’라는 생각과 ‘나도 더 열심히 해야지!’ 라는 마음이&lt;/p&gt;

&lt;p&gt;겹쳐집니다.&lt;/p&gt;

&lt;p&gt;누군가에겐 영감을 주고 스스로에겐 동기부여를 만드는 TIL 게시판이 되었으면 좋겠습니다.&lt;/p&gt;

&lt;p&gt;-TIL을 시작하며-&lt;/p&gt;</content><author><name>Seok Hun Zoo</name></author><category term="til" /><summary type="html">초보몽키라는 이름의 블로그를 운영하고 계신 이현주님의 블로그를 보면 Today I Learned 라는 카테고리로 포스팅을 해놓았습니다.</summary></entry><entry><title type="html">Docker관련</title><link href="http://localhost:4000/records/2017-11-16-docker%EA%B4%80%EB%A0%A8/" rel="alternate" type="text/html" title="Docker관련" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/records/docker%EA%B4%80%EB%A0%A8</id><content type="html" xml:base="http://localhost:4000/records/2017-11-16-docker%EA%B4%80%EB%A0%A8/">&lt;h1 id=&quot;docker-세팅&quot;&gt;Docker 세팅&lt;/h1&gt;

&lt;p&gt;도커를 처음 설치하고 나서 다음 명령어로 우분투 이미지를 다운받고 해당 운영체제를 실행할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --rm it ubuntu:16:04 /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜진 도커환경 안에서는 처음부터 root권한이 주어지기 때문에 sudo입력 없이도 여러가지 설치 명령을 실행시킬 수 있다.&lt;/p&gt;

&lt;p&gt;Dockerfile.base 이미지 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t base -f Dockerfile.base .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Dockerfile.base를 기준으로 우리가 쓸 도커(container) 만드는 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker build -t eb .
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만든 이미지 확인 명령어&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker images
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker(Container) 실행시키는 명령어(예: eb)&lt;/p&gt;

&lt;p&gt;(마지막의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/zsh&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;옵션으로 프로그램을 실행시키기 위해 입력해주는 것, &lt;code class=&quot;highlighter-rouge&quot;&gt;-it&lt;/code&gt;터미널 형식으로 연다는 뜻, &lt;code class=&quot;highlighter-rouge&quot;&gt;--rm&lt;/code&gt;옵션은 컨테이너가 꺼졌을 때 삭제한다는 의미)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;docker를 외부랑 연결시키기 위해서 옵션을 추가한 멸영어&lt;/p&gt;

&lt;p&gt;(우리가 8012로 접근하면 docker는 80으로 받는다. 우리가 8013으로 접근하면 docker는  8000으로 받는다. 80번 포트와 8000포트를 둘다 테스트해보고 싶을 때 이런식으로 쓴다)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo docker run --rm -it -p 8012:80 -p 8013:8000 eb /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;켜져있는 도커에 접속할 수 있는 명령어 (4317은 docker id)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 /bin/zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와같은 명령어를 아래와 같이 접속도 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker exec -it 4317 zsh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;실행되고 있는 이미지 파일(container) 정보 확인하는 명령어&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Seok Hun Zoo</name></author><category term="records" /><summary type="html">Docker 세팅</summary></entry><entry><title type="html">Ecs</title><link href="http://localhost:4000/records/2017-11-16-ECS/" rel="alternate" type="text/html" title="Ecs" /><published>2017-11-16T00:00:00+09:00</published><updated>2017-11-16T00:00:00+09:00</updated><id>http://localhost:4000/records/ECS</id><content type="html" xml:base="http://localhost:4000/records/2017-11-16-ECS/">&lt;p&gt;도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기&lt;/p&gt;</content><author><name>Seok Hun Zoo</name></author><category term="records" /><summary type="html">도커만 올려서 바로 배포할 수 있는 ecs라는 서비스가 있는데 나중에 사용방법 확인해서 elastic beanstalk과 비교해서 어떤게 더 편하게 배포할 수 있는지 확인해 보기</summary></entry><entry><title type="html">Postgresql</title><link href="http://localhost:4000/records/2017-10-15-postgresql/" rel="alternate" type="text/html" title="Postgresql" /><published>2017-10-15T00:00:00+09:00</published><updated>2017-10-15T00:00:00+09:00</updated><id>http://localhost:4000/records/postgresql</id><content type="html" xml:base="http://localhost:4000/records/2017-10-15-postgresql/">&lt;h1 id=&quot;명령어-기록-ubuntu-1604&quot;&gt;명령어 기록 (ubuntu-1604)&lt;/h1&gt;

&lt;h3 id=&quot;데이터베이스-생성&quot;&gt;데이터베이스 생성&lt;/h3&gt;
&lt;p&gt;커맨드창 에서 ‘zoozoo’라는 계정 이름으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;testname&lt;/code&gt;이라는 데이터베이스를 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;createdb testname --owner=zoozoo
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 생성&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE DATABASE testname OWNER zoozoo;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 이름이 대문자인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&quot;&lt;/code&gt;(쌍따옴표)로 데이터베이스 이름을 감싸서 명령을 실행시켜야 실행이 된다.&lt;/p&gt;

&lt;h3 id=&quot;기본생성된-사용자-이름으로-postgresql연결&quot;&gt;기본생성된 사용자 이름으로 postgresql연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 postgres 데이터베이스에 연결한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;postgres-사용자로-다른-데이터베이스-연결&quot;&gt;postgres 사용자로 다른 데이터베이스 연결&lt;/h3&gt;

&lt;p&gt;postgres 사용자로 psql을 실행하고 testdb 데이터베이스에 연결한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres psql testdb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-삭제터미널-창에서&quot;&gt;데이터베이스 삭제(터미널 창에서)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo -u postgres dropdb &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스 접속 후 위와 같은 데이터베이스 삭제&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP DATABASE &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;데이터베이스-목록확인-데이터베이스-명령어&quot;&gt;데이터베이스 목록확인 (데이터베이스 명령어)&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\ㅣ
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;특정-데이터베이스에-접속&quot;&gt;특정 데이터베이스에 접속&lt;/h3&gt;
&lt;p&gt;ex) database명 instagram&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;psql instagram
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;위의-특정-데이터베이스에-접속-후-관련-테이블-확인&quot;&gt;위의 특정 데이터베이스에 접속 후 관련 테이블 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dt\
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;테이블의-전체-내용-확인&quot;&gt;테이블의 전체 내용 확인&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from 테이블명
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;사용자-비밀번호-변경하기&quot;&gt;사용자 비밀번호 변경하기&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo -u postgres psql template1&lt;/code&gt; 명령을 통해 데이터베이스 접속&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ALTER USER postgres with encrypted password 'your_password';&lt;/code&gt; 명령을 통해 패스워드 변경 아래는 예시
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ALTER USER James with encrypted password 'asldkhf';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo systemctl restart postgresql.service&lt;/code&gt;명령을 통해 postgresql 재시작&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Seok Hun Zoo</name></author><category term="records" /><summary type="html">명령어 기록 (ubuntu-1604)</summary></entry><entry><title type="html">Dajngo_queryset_method</title><link href="http://localhost:4000/records/2017-10-14-dajngo_querySet_method/" rel="alternate" type="text/html" title="Dajngo_queryset_method" /><published>2017-10-14T00:00:00+09:00</published><updated>2017-10-14T00:00:00+09:00</updated><id>http://localhost:4000/records/dajngo_querySet_method</id><content type="html" xml:base="http://localhost:4000/records/2017-10-14-dajngo_querySet_method/">&lt;h1 id=&quot;queryset-api&quot;&gt;QuerySet API&lt;/h1&gt;

&lt;h2 id=&quot;methods-that-return-new-querysets&quot;&gt;Methods that return new QuerySets&lt;/h2&gt;

&lt;h3 id=&quot;filter&quot;&gt;filter()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개 변수와 일치하는 객체가 포함 된 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;복잡한 쿼리문을 사용해야 할 경우 Q objects를 사용할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;exclude&quot;&gt;exclude()&lt;/h3&gt;

&lt;p&gt;지정된 검색 매개변수와 일치하는 객체가 포함되지 않은 새 QuerySet을 반환합니다.&lt;/p&gt;

&lt;h3 id=&quot;annotate&quot;&gt;annotate()&lt;/h3&gt;

&lt;p&gt;제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다.제공된 쿼리 식 목록으로 QuerySet의 각 개체에 주석을 첨부합니다. 표현식은 단순 값, 모델의 필드에 대한 참조 (또는 모든 관련 모델), 또는 개체의 개체와 관련하여 계산 된 집계 식 (평균, 합계 등)이 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;annotate ()에 대한 각 인수는 반환되는 QuerySet의 각 객체에 추가되는 주석입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models import Count
&amp;gt;&amp;gt;&amp;gt; q = Blog.objects.annotate(Count('entry'))
# The name of the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].name
'Blogasaurus'
# The number of entries on the first blog
&amp;gt;&amp;gt;&amp;gt; q[0].entry__count
42
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시에서 블로그 모델은 entry__count 속성을 단독으로 정의하지 않지만 키워드 인수를 사용하여 집계 함수를 지정하면 주석의 이름을 제어 할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;order_by&quot;&gt;order_by()&lt;/h3&gt;

&lt;p&gt;기본적으로 QuerySet에 의해 반환 된 결과는 Model’s Meta의 정렬 옵션에 의해 주어진 순서 튜플에 의해 정렬됩니다. order_by 메소드를 사용하여 QuerySet 단위로이 값을 겹쳐 쓸 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 결과는 pub_date가 내림차순으로 정렬 된 다음 headline이 오름차순으로 정렬됩니다. “-pub_date”앞에있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt; 기호는 내림차순을 나타냅니다. 기본적으로 오름차순으로 정렬됩니다.&lt;/p&gt;

&lt;p&gt;렌덤으로 정렬하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;를 사용합니다. (아래 예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('?')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델의 필드로 정렬하려면 모델 관계를 쿼리 할 때와 같은 구문을 사용하십시오. 즉, 필드 이름과 이중 밑줄 (__), 새 모델의 필드 이름 등이 포함되며, 원하는만큼의 모델을 추가 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name', 'headline')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;다른 모델과 관계가있는 필드로 정렬하려고하면 Django는 관련 모델의 기본 순서를 사용하거나 Meta.ordering이 지정되지 않은 경우 관련 모델의 기본 키순으로 정렬합니다.&lt;/p&gt;

&lt;p&gt;예를 들어 블로그 모델에는 기본 주문이 지정되어 있지 않으므로&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위의 예시는 아래의 예시와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__id')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 Blog 테이블에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ordering = ['name']&lt;/code&gt; 이 지정되어 있다면 위의 첫번째 쿼리는 아래와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.order_by('blog__name')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;reverse&quot;&gt;reverse()&lt;/h3&gt;

&lt;p&gt;reverse() 메서드를 사용하여 쿼리셋 결과물을 반대방향으로 정렬할 수 있습니다. reverse()를 한번더 호출하면 기존의 순서대로 다시 정렬할 수 있습니다.&lt;/p&gt;

&lt;p&gt;다음 쿼리셋으로 끝에서 5번째까지의 항목을 불러올 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;my_queryset.reverse()[:5]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django에서는 파이썬에서 사용할 수 잇는 [-1:] 과 같은 역 슬라이스를 사용하지 않습니다.   SQL에서 효율적으로 수행 할 수 없기 때문입니다.&lt;/p&gt;

&lt;p&gt;또한 reverse ()는 일반적으로 정의 된 순서가있는 QuerySet에서만 호출되어야합니다. 주어진 QuerySet에 대해 그러한 정렬이 정의되어 있지 않으면 reverse ()를 호출하면 아무런 효과가 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;distinct&quot;&gt;distinct()&lt;/h3&gt;

&lt;p&gt;SQL 쿼리에서 SELECT DISTINCT를 사용하는 새 QuerySet을 반환합니다. 이렇게하면 조회 결과에서 중복 행이 제거됩니다.&lt;/p&gt;

&lt;p&gt;기본적으로 QuerySet은 중복 행을 제거하지 않습니다. 실제로 Blog.objects.all ()과 같은 간단한 쿼리는 결과 행이 중복 될 가능성이 있기 때문에 거의 문제가되지 않습니다. 그러나 쿼리가 여러 테이블에 걸쳐있는 경우 QuerySet을 평가할 때 중복 결과를 얻을 수 있습니다. 이러한 상황에서 distinct ()를 사용하여 중복된 항목을 제거할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;values&quot;&gt;values()&lt;/h3&gt;

&lt;p&gt;iterable한 모델객체가 아닌 dictionary로 반환하는 쿼리셋입니다.&lt;/p&gt;

&lt;p&gt;반환된 dictionary는 모델 오브젝트의 속성이름을 키로, 가지고 데이터는 value로 가집니다.&lt;/p&gt;

&lt;p&gt;다음의 예시는 일반적인 쿼리셋과 values()쿼리셋의 차이를 보여줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# This list contains a Blog object.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles')
&amp;lt;QuerySet [&amp;lt;Blog: Beatles Blog&amp;gt;]&amp;gt;

# This list contains a dictionary.
&amp;gt;&amp;gt;&amp;gt; Blog.objects.filter(name__startswith='Beatles').values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메소드는 모델이 가지고 있는 필드명을 인자로 가질 수 있습니다. 인자를 지정하지 않으면 모든 필드가 반환됩니다. (아래예시)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Blog.objects.values()
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values('id', 'name')
&amp;lt;QuerySet [{'id': 1, 'name': 'Beatles Blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;values()메서드는 키워드인자로 annotate()를 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Blog.objects.values(lower_name=Lower('name'))
&amp;lt;QuerySet [{'lower_name': 'beatles blog'}]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;values_listfields-flatfalse&quot;&gt;values_list(*fields, flat=False)&lt;/h3&gt;

&lt;p&gt;values_list()는 dictionary를 반환하는 대신 튜플로 만들어진 리스트를 반환한다는 점을 제외하면 values ()와 유사합니다. 각 튜플에는 해당 필드의 값이나 values_list () 호출로 전달 된 표현식이 들어 있으므로 첫 번째 항목이 첫 번째 입력란이됩니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', 'headline')
&amp;lt;QuerySet [(1, 'First entry'), ...]&amp;gt;
&amp;gt;&amp;gt;&amp;gt; from django.db.models.functions import Lower
&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', Lower('headline'))
&amp;lt;QuerySet [(1, 'first entry'), ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;만약 매게변수로 단일 필드 만 전달하면 flat 매개 변수를 전달할 수도 있습니다. flat=True이면 단일 튜플 아닌 단일 값으로 이루어진 리스트 반환합니다.&lt;/p&gt;

&lt;p&gt;ex)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id').order_by('id')
&amp;lt;QuerySet[(1,), (2,), (3,), ...]&amp;gt;

&amp;gt;&amp;gt;&amp;gt; Entry.objects.values_list('id', flat=True).order_by('id')
&amp;lt;QuerySet [1, 2, 3, ...]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하나 이상의 필드인자를 할당했는데 flat매게변수를 사용한다면 에러가 납니다.&lt;/p&gt;

&lt;p&gt;values_list ()에 값을 전달하지 않으면 모델의 모든 필드가 선언 된 순서대로 반환됩니다.&lt;/p&gt;

&lt;p&gt;values()와 values_list() 메서드는 모델 인스턴스를 생성하지 않고도 필드의 집합을 산출해 내는데에 최적화 되어 설계되었습니다. 관계가 형성되어있는 모델을 다룰 때에는 해당되지 않습니다. 한행에 하나의 객체가 할당되는 가정이 유지되지 않기 때문입니다.&lt;/p&gt;

&lt;h3 id=&quot;datesfield-kind-orderasc&quot;&gt;dates(field, kind, order=’ASC’)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 모든 사용 가능한 날짜를 나타내는 datetime.date 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateField 여야 하며 종류는 “year”, “month” or “day”지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'year')
[datetime.date(2005, 1, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'month')
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day')
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
&amp;gt;&amp;gt;&amp;gt; Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;datetimesfield_name--kind-orderasc-tzinfonone&quot;&gt;datetimes(field_name,  kind, order=’ASC’, tzinfo=None)&lt;/h3&gt;

&lt;p&gt;QuerySet의 내용 내에서 특정 종류의 사용 가능한 모든 날짜를 나타내는 datetime.datetime 객체의 목록으로 평가되는 QuerySet을 반환합니다.&lt;/p&gt;

&lt;p&gt;선택한 필드는 DateTimeField 여야 하며 종류는 “year”, “month”,  “day”, “hour:, “minute”, “second”로지정되어 있어야 합니다. 산출된 결과는 해당 타입에 따라서 나눠집니다.&lt;/p&gt;

&lt;h3 id=&quot;none&quot;&gt;none()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;none ()을 호출하면 객체를 반환하지 않는 쿼리 세트가 만들어지며 결과에 액세스 할 때 쿼리가 실행되지 않습니다. qs.none () 쿼리 세트는 EmptyQuerySet의 인스턴스입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;all&quot;&gt;all()&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;현재의 QuerySet (또는 QuerySet 서브 클래스)의 복사본을 반환합니다. 이는 모델 매니저 또는 QuerySet을 전달하고 결과에 대해 추가 필터링을 수행하려는 상황에서 유용 할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;unionother_qs-allfalse&quot;&gt;union(*other_qs, all=False)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 UNION 연산자를 사용하여 두 개 이상의 QuerySet 결과를 결합합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.union(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;UNION 연산자는 기본적으로 고유 값만 선택합니다. 중복 값을 허용하려면 all = True 인수를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;intersectionother_qs&quot;&gt;intersection(*other_qs)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;SQL의 INTERSECT 연산자를 사용하여 두 개 이상의 QuerySets의 공통 요소를 반환합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; qs1.intersection(qs2, qs3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;select_relatedfields&quot;&gt;select_related(*fields)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;외래 키 관계가 형성되어 있는 QuerySet를 리턴 해, 조회를 실행할 때에 추가의 관련 오브젝트 데이터를 선택합니다. 이것은 하나의 복잡한 쿼리로 이어지는 성능 향상이지만 나중에 외래 키 관계를 사용하면 데이터베이스 쿼리가 필요하지 않음을 의미합니다. 다음 예제는 일반 조회와 select_related () 조회 간의 차이점을 보여줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ex) 표준 예제&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.get(id=5)

# Hits the database again to get the related Blog object.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ex) select_related&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Hits the database.
e = Entry.objects.select_related('blog').get(id=5)

# Doesn't hit the database, because e.blog has been prepopulated
# in the previous query.
b = e.blog
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;한번에 관계가 이루어진 데이터베이스까지 조회해 와서 다음 쿼리시에 데이터베이스를 거치지 않고서도 원하는 정보를 산출해 낼 수 있다는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;select_related()쿼리는 다른 쿼리 객체와도 함께 사용할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.utils import timezone

# Find all the blogs with entries scheduled to be published in the future.
blogs = set()

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;filter()와 select_related()의 체이닝 순서는 중요하지 않습니다. 어떤 것이 앞에 있더라도 결과는 동일합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;select_related ()를 많은 관련 객체로 호출하거나 모든 관계를 모르는 경우가 있습니다. 이러한 경우에는 인수없이 select_related ()를 호출 할 수 있습니다. 이것은 발견 할 수있는 null이 아닌 모든 외래 키를 반환합니다. null 입력 가능 외래 키가 지정되어야합니다. 대부분의 경우에는 기본 쿼리를보다 복잡하게 만들고 실제로 필요한 것보다 많은 데이터를 반환하기 때문에 권장되지 않습니다.&lt;/p&gt;

&lt;p&gt;QuerySet에서 select_related의 이전 호출에 의해 추가 된 관련 필드 목록을 지우려면 매개 변수로 None을 전달할 수 있습니다.&lt;/p&gt;</content><author><name>Seok Hun Zoo</name></author><category term="records" /><summary type="html">QuerySet API</summary></entry><entry><title type="html">Django_model_fieldtype</title><link href="http://localhost:4000/records/2017-10-13-django_model_fieldtype-/" rel="alternate" type="text/html" title="Django_model_fieldtype" /><published>2017-10-13T00:00:00+09:00</published><updated>2017-10-13T00:00:00+09:00</updated><id>http://localhost:4000/records/django_model_fieldtype-</id><content type="html" xml:base="http://localhost:4000/records/2017-10-13-django_model_fieldtype-/">&lt;h1 id=&quot;model-field-reference&quot;&gt;Model field reference&lt;/h1&gt;

&lt;h2 id=&quot;field-types&quot;&gt;Field types&lt;/h2&gt;

&lt;h3 id=&quot;autofieldoptions&quot;&gt;AutoField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;추가하는 인스턴스마다 자동으로 사용가능한 ID값을 할당하는 IntegerField. 기본적으로 primary key field가 자동으로 추가해 주기 때문에 필요한 경우에 사용하면 됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigautofieldoptions&quot;&gt;BigAutoField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;사용 할 수 있는 숫자가 1부터 9223372036854775807까지 보장되는 AutoField와 유사한 필드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bigintegerfieldoptions&quot;&gt;BigIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;9223372036854775807까지의 숫자를 맞출 수 있다는 것을 제외하고는 IntegerField와 매우 흡사 한 64 비트 정수입니다.이 필드의 기본 양식 위젯은 TextInput입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;binaryfieldoptions&quot;&gt;BinaryField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이진 데이터를 저장하는 필드입니다. 바이트 할당 만 지원합니다. 이 입력란에는 기능이 제한되어 있습니다. 예를 들어, BinaryField 값에 대한 쿼리 집합을 필터링 할 수 없습니다. 또한 BinaryField를 ModelForm에 포함시키는 것도 불가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;booleanfieldoptions&quot;&gt;BooleanField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ture/False 값을 가지는 필드입니다.&lt;/li&gt;
  &lt;li&gt;필드에 대한 기본 위젯은 CheckboxInput입니다.&lt;/li&gt;
  &lt;li&gt;null값을 받아야만 한다면 NullBooleanField를 대신 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;default값이 정의되어 있지 않으면 BooleanField의 기본값은 None입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;charfieldmax_lengthnone-options&quot;&gt;Charfield(max_length=None, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;string field로 길거나 짧은 문자열 보두 지원합니다.&lt;/li&gt;
  &lt;li&gt;대량의 텍스트를 사용해야 한다면 Textfield를 사용하면 됩니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯은 TextInput입니다.&lt;/li&gt;
  &lt;li&gt;CharField는 필수인자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;max_length&lt;/code&gt;를 반드시 입력해줘야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;DateField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;python에서 datetime.date 인스턴스로 표현되는 날짜입니다. 추가로 몇 가지 선택적 인수가 있습니다.&lt;/li&gt;
  &lt;li&gt;DateField.auto_now : 데이터가 save될 때 마다 현재시각을 자동으로 부여합니다.&lt;/li&gt;
  &lt;li&gt;DateField.auto_now_add : 데이터를 처음 만들 때 마다 자동으로 현재시각을 부여합니다.&lt;/li&gt;
  &lt;li&gt;기본적으로 현재시각을 부여하지만 기본값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;default=date.today&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;default=timezone.now&lt;/code&gt;와 같은 옵션을 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯은 TextInput입니다. admin페이지에는 기본적으로 Today를 설정할 수 있는 단축키가 만들어 집니다.&lt;/li&gt;
  &lt;li&gt;auto_now_add, auto_now 및 default 옵션은 상호 배타적입니다. 이러한 옵션을 함께 사용하면 오류가 발생합니다.&lt;/li&gt;
  &lt;li&gt;auto_now 또는 auto_now_add를 True로 설정하면 해당 필드는 editable = False 및 blank = True로 설정됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;datetimefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;DateTimeField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 datetime.datetime 인스턴스로 표현되는 날짜와 시간입니다.&lt;/li&gt;
  &lt;li&gt;DateField와 동일한 인수를 사용합니다.&lt;/li&gt;
  &lt;li&gt;기본 위젯으로 한개의 TextInput을 가지며, admin페이지 JavaScript 바로 가기가있는 두 개의 별도 TextInput 위젯을 사용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;decimalfieldmax_digitsnone-decimal_placesnone-options&quot;&gt;DecimalField(max_digits=None, decimal_places=None, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;고정 소수점 이하의 십진수로 파이썬에서 Decimal 인스턴스로 나타냅니다. 필수 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;max_digits(최대 자릿수)&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;decimal_places(소숫점)&lt;/code&gt;가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;durationfieldoptions&quot;&gt;Durationfield(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;특정 기간을 담을 수 있는 필드입니다. (python의 timedelta)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;emailfieldmax_length254-options&quot;&gt;EmailField(max_length=254, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;email주소 유효성을 확인할 수 있는 CharField입니다. EmailCalidator를 이용하여 유효성을 검사합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;filefieldupolad_tonone-max_length100-options&quot;&gt;FileField(upolad_to=None, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;해당 필드에 primary_key는 사용할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;이 속성은 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며 두 가지 방법으로 설정할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;upload_to : 이 속성은 업로드 디렉토리와 파일 이름을 설정하는 방법을 제공하며 두 가지 방법으로 설정할 수 있습니다. 두 경우 모두 값은 Storage.save () 메서드에 전달됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyModel(models.Model):
    # file will be uploaded to MEDIA_ROOT/uploads
    upload = models.FileField(upload_to='uploads/')
    # or...
    # file will be saved to MEDIA_ROOT/uploads/2015/01/30
    upload = models.FileField(upload_to='uploads/%Y/%m/%d/')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;기본 FileSystemStorage를 사용하는 경우 문자열 값이 MEDIA_ROOT 경로에 추가되어 업로드 된 파일이 저장 될 로컬 파일 시스템의 위치가 형성됩니다.&lt;/li&gt;
  &lt;li&gt;upload_to는 함수와 같이 호출 할 수 있습니다. 이것은 파일 이름을 포함하여 업로드 경로를 얻기 위해 호출됩니다. 호출 할 때에는 FileField가 선언된 model의 instance와 filename인자가 필요합니다.&lt;/li&gt;
  &lt;li&gt;storage  : 파일의 저장 및 검색을 처리하는 저장 할 수 있는 속성입니다.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Filefield와 ImageField를 사용함에 있어서 몇가지 순서가 있습니다.&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;설정 파일에서 Django가 업로드 된 파일을 저장할 디렉토리의 전체 경로로 MEDIA_ROOT을 정의해야합니다. MEDIA_URL을 해당 디렉토리의 기본 공개 URL로 정의하십시오.&lt;/li&gt;
      &lt;li&gt;모델에 FileField 또는 ImageField를 추가하고 upload_to 옵션을 정의하여 업로드 된 파일이 저장될 MEDIA_ROOT의 하위 디렉토리를 지정합니다.&lt;/li&gt;
      &lt;li&gt;데이터베이스에 저장되는 것은 파일 경로입니다. 장고가 제공하는 url속성도 사용할 수 있습니다. 예를 들어 mug_shot 이라는 ImageField를 만들었다고 가정하면 ``과 같은 형식으로 파일의 경로를 가져올 수 있습니다.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;업로드된 파일의 URL을 url속성을 사용하여 사용할 수 있습니다.&lt;/p&gt;

    &lt;p&gt;#### FieldFile&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;모델에서 FileField에 액세스하면 FieldFile 인스턴스가 기본 파일에 액세스하기위한 프록시로 제공됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* FieldFile.name - 연결된 FileField의 저장소 루트로부터의 상대 경로를 포함하는 파일의 이름입니다.
* FieldFile.size - 기본 Storage.size () 메서드의 결과입니다.
* FieldFile.url - 기본 Storage 클래스의 url () 메서드를 호출하여 파일의 상대 URL에 액세스하는 읽기 전용 속성입니다.
* FieldFile.open(mode='rb') - 지정된 모드에서이 인스턴스와 관련된 파일을 열거 나 다시 엽니 다. 표준 파이썬 open () 메소드와는 달리, 파일 디스크립터를 리턴하지 않습니다.
* FieldFile.close -  표준 파이썬 file.close () 메소드와 유사하게 동작하고이 인스턴스와 관련된 파일을 닫습니다.
* FieldFile.save(name, content, save=True) - 이 메서드는 파일 이름과 파일 내용을 가져 와서 필드의 저장소 클래스에 전달한 다음 저장된 파일을 모델 필드와 연결합니다. 모델의 FileField 인스턴스에 파일 데이터를 수동으로 연결하려면 save () 메서드를 사용하여 해당 파일 데이터를 유지합니다.
* FieldFile.delete(save=True) - 이 인스턴스와 관련된 파일을 삭제하고 필드의 모든 특성을 지 웁니다. 이 메소드는 delete ()가 호출 될 때 열려있을 경우 파일을 닫습니다.모델을 삭제하면 관련 파일이 삭제되지 않습니다. 고아 파일을 정리해야하는 경우 직접 처리해야합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;filepathfieldpathnone-matchnone-recursivefalse-max_length100-options&quot;&gt;FilePathField(path=None, match=None, recursive=False, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;CharField는 파일 시스템의 특정 디렉토리에있는 제한된 파일 이름을 선택합니다. 3개의 인자를 받으며 그중 첫번째는 필수인자 입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* FilePathField.path - 필수인자로 해당 필드가 선택해야하는 파일의 절대경로를 입력해줍니다.
* FilePathField.match - 정규표현식을 통해 해당 필드가 파일네임을 필터링 할 수 있게 합니다.
* FilePathField.recursive - path의 모든 하위 디렉토리가 포함되어야하는지 여부를 지정합니다.
* FilePathField.allow_files - 지정된 위치의 파일을 포함할지 여부를 지정합니다.
* FilePathField.allow_folders - 지정된 위치의 폴더를 포함할지 여부를 지정합니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;floatfieldoptions&quot;&gt;FloatField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;float 인스턴스로 파이썬에서 표현 된 부동 소수점 숫자입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;imagefieldupload_tonone-height_fieldnone-width_fieldnone-max_length100-options&quot;&gt;ImageField(upload_to=None, height_field=None, width_field=None, max_length=100, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;FileField의 모든 특성 및 메서드를 상속하지만 업로드 된 개체가 유효한 이미지인지 확인합니다.&lt;/li&gt;
  &lt;li&gt;FileField에서 사용할 수있는 특수 특성 외에도 ImageField에는 height 및 width 특성이 있습니다. 이러한 속성에 대한 쿼리를 용이하게하기 위해 ImageField에는 두 개의 추가 선택적 인수가 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;* ImageField.height_field - 모델 인스턴스가 저장 될 때마다 자동으로 지정된 높이를 갖게하는모델 필드의 이름입니다.
* ImageField.width_field - 모델 인스턴스가 저장 될 때마다 자동으로 지정된 너비를 갖게하는모델 필드의 이름입니다.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Imagefield를 사용하기 위해서는 Pillow 라이브러리를 설치해야만 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;integerfieldoptions&quot;&gt;IntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;정수를 받을 수 있는 필드입니다. 정수. -2147483648에서 2147483647까지의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다. 이 필드의 기본 양식 위젯은 localize가 False 일 때 NumberInput이고 그렇지 않으면 TextInput입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;genericipaddressfieldprotocolboth-unpack_ipv4false-options&quot;&gt;GenericIPAddressField(protocol=’both’, unpack_ipv4=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;문자열 형식의 IPv4 또는 IPv6 주소를 받을 수 있는 필드입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nullbooleanfieldoptions&quot;&gt;NullBooleanField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;BooleanField와 비슷하지만 NULL을 옵션 중 하나로 허용합니다. BooleanField 대신 null = True를 사용할 수도 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;positiveintegerfieldoptions&quot;&gt;PositiveIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IntegerField와 같으나 양수 또는 0이어야합니다. 0에서 2147483647 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다. 이전 버전과의 호환성을 위해 0 값이 허용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;positivesmallintegerfieldoptions&quot;&gt;PositiveSmallIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;PositiveIntegerField와 같지만 특정 (데이터베이스에 따라 다릅니다.) 지점에서만 값을 허용합니다. 0에서 32767 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;slugfieldmax_length50-options&quot;&gt;SlugField(max_length=50, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Slug는 신문 용어입니다. Slug는 글자, 숫자, 밑줄 또는 하이픈 만 포함하는 짧은 레이블입니다. 일반적으로 URL에 사용됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;smallintegerfieldoptions&quot;&gt;SmallIntegerField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;IntegerField와 같지만 특정 (데이터베이스에 따라) 지점에서만 값을 허용합니다. -32768에서 32767 사이의 값은 장고가 지원하는 모든 데이터베이스에서 안전합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;textfieldoptions&quot;&gt;TextField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;큰 텍스트 필드. 이 필드의 기본 양식 위젯은 Textarea입니다. max_length 속성을 지정하면 자동 생성 양식 필드의 Textarea 위젯에 반영됩니다. 그러나 모델 또는 데이터베이스 수준에서는 적용되지 않습니다. CharField를 사용하십시오.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;timefieldauto_nowfalse-auto_now_addfalse-options&quot;&gt;TimeField(auto_now=False, auto_now_add=False, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Python에서 datetime.time 인스턴스로 표현되는 시간입니다. DateField와 동일한 자동 채우기 옵션을 적용합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;urlfieldmax_length200-options&quot;&gt;URLField(max_length=200, **options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;url을 위한 CharField입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uuidfieldoptions&quot;&gt;UUIDField(**options)&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;보편적으로 유일한 식별자를 저장하기위한 필드입니다. 파이썬의 UUID 클래스를 사용합니다. PostgreSQL에서 사용될 때 이것은 uuid 데이터 유형에 저장되고, 그렇지 않으면 char (32)에 저장됩니다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Seok Hun Zoo</name></author><category term="records" /><summary type="html">Model field reference</summary></entry></feed>