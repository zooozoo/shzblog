---
title: 독하게시작하는 c프로그래 강의 노트
excerpt: >-
 컴퓨터 구조를 이해하기 위해 c언어라는 산을 한번 넘어보고 싶었습니다. 그 산을 넘는 첫 번째 과정입니다.
 언어 그 자체보다 컴퓨터구조를 공부하는데에 도움이 되는 방향으로 공부합니다.
---
# 제1장 c프로그래밍 입문

### 오류해결 사례

#### `f7`키를 통해서 빌드할 때 아래와 같은 에러 발생

> c:\apiexam\firsts\firsts\firsts.cpp(46): fatal error C1010: 미리 컴파일된 헤더를 찾는 동안 예기치 않은 파일의 끝이 나타났습니다. '#include "StdAfx.h"'을(를) 소스에 추가하시겠습니까?

* 검색을 통해 문제 해결
  * [링크](https://social.msdn.microsoft.com/Forums/ko-KR/cc067d9f-3c6e-4ca6-a5ce-68114a428da3/visual-c-487164630044032-50504461214576845796?forum=visualcplusko)
  * 해결방법
    1. 프로젝트의 솔루션 탐색기 창에서 마우스 오른쪽 단추로 프로젝트 이름을 클릭한 다음 속성을 클릭합니다.  
    2. 왼쪽 창에서 C/C++ 폴더를 클릭합니다.   
    3. 미리 컴파일된 헤더 노드를 클릭합니다.  
    4. 오른쪽 창에서 미리 컴파일된 헤더 만들기/사용을 클릭한 다음 미리 컴파일된 헤더 사용 안 함을 클릭합니다.  

#### dll파일의 기호(pdb파일)을 찾지 못해 발생하는 오류
* 참고 블로그 [링크](http://singleton.tistory.com/370)
* 해결방법
  - 메뉴방의 디버그 -> 옵션 -> 기호 -> Microsft 기호 서버 체크

### 강의 중 기록사항

강의중 나온 단축키 설명

* `f7`  : 빌드
* `f5` : 디버그모드로 실행
* `ctrl` + `f5` : 디버깅 하지 않고 실행 (내용을 확이할 수 있도록 실행 결과가 창에 떠있음)
* `f9` : 포지션브레이크보인트 설정
* `alt + 6` : 메모리 확인도
* `f10` : 프로시저단위 실행

# 제3장 표준 입/출력 도구 첫 번째

* ux의 시대에도 cli와 같은 근본적인 입출력은 잘 알아야 한다. 결국 정보란 문자열이기 때문에
* getchar()
  * 어디서 어떻게 가져오는지 알아보자
* 컴퓨터의 구조에 대해서 생각해 보자
  * 컴퓨터
    * 하드웨어
    * 소프트 웨어
      * 시스템 소프트웨어 (ex: os)
      * 응용 소프트웨어
  * 컴퓨터의 계층(국가를 예시로 영토, 정부, 가구로 설명함)
    1. 하드웨어
    2. 커널 os
       * 디바이스를 제어하는 `디바이스 드라이버` 커널 소프트웨어
    3. 유저 user/ 프로세스
       * 프로세스는 각각의 영역을 보장 받는다.
       * 그러나 프로세스가 할당받은 영역을 제어할 수 있는 소프트웨어가 있는데 `디버거`라고 한다.
       * 다른프로세스의 메모리를 변조하는 공격을 메모리 해킹이라고 하는데 이것을 `디버거`로 한다. 또한 소프트웨어의 문제를 해결하는 것 또한 `디버거`
       * 유저모드에서 커널모드로의 진입은 불가
       * 커널과 연결할 수 있는 추상화된 인터페이스 -> 파일(File)
       * 파일은 파일마다 고유한 입출력 버퍼를 가지고 있다. (즉 메모리를 가지고 있다.)
         1. write
            * ex) putchar('A')를 할 경우 'A'라는 버퍼를 체우게 되는데 이것을 버퍼링이라고 한다.
         2. read
            * ex) getchar()함수는 버퍼로 부터 한 글자를 퍼올리는역할을 한다.
       * 파일을 알맞은 규칙에 맞게 작성해서 커널로 전달하면 커널이 다시 하드웨어를 작동시킨다. 이때에 규칙이 `Protocol`(protocol은 정보전달 규약)
       * 파일 입출력의 다양한 규칙을 맞추기 어려우니 하나의 함수 형태로 만들어 놓은게 getchar(), putchar() 함수다.
       * 만약 프로토콜이 TCP일 경우, 프로토콜 서비스를 추상화한 파일의 경우 특별하게 `socket`이라고 한다.
       * 소켓은 정보를 수신할 때 언제 수신할지 모르기 때문에 비동기 방식을 체택한다.
  * c언어는 컴퓨터의 모든부분을 커버할 수 있다.
* 입출력 (I/O)을 수행하는 주체 -> 커널
* putchar() - 입출력을 요구하는 함수
* 입출력은 user모드 어플리케이션에서 요구하고 -> 커널이 입출력을 담당한다.
* 소캣프로그래밍을 잘하고 싶다면 시스템 프로그래밍 + file I/O + Protocol  이렇게 하면 된다.
* putchar, getchar는 버퍼드I/O를 한다.
* getchar()함수의 작동 과정
  * 하드웨어에서(ex, 키보드) 'hello'를 입력받으면 장치드라이버와 인터페이스를 통해 파일을 추상화 한 후 해당 파일로 부터 꺼내서 read를 하게 된다. 파일마다 I/O 버퍼가 존재한다. 버퍼에 'hello가 쌓이게 됨' -> 이런 상황에서 getchar함수를 실행하면 'h'를 끄집어 내서 'char'형식으로 반환한다.  그런데 getchar함수의 원형은 int를 반환하게 되어있음 (char + int는 int가 된다.)
* 버퍼와, 버퍼링
  * 버퍼
    * 메모리
    * 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리 영역
    * 사전적 정의는 '완충기'
  * 버퍼링
    * 정보 전달 과정에서 정보를 소비하는 쪽에서 정보 전달에 문제가 생긴 상황을 모르게 하는 것
    * 버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 말한다. 다른 말로는 '큐'라고도 표현한다.
* 논버퍼드 I/O
  * 정보가 전달 될 때 복사되서 전달하는게 아니라 한번에 어떤 장치와 cpu가 직접 정보를 전달하게 되면 더 빠른 정보 전달이 가능하다.
  * DMA - Direct Memory Access
* 버퍼드 I/O를 하는 함수
  * 하드웨어 -> 콘솔 -> 파일을 통해 버퍼에 정보가 쌓인다.
  * getchar() - 버퍼에서 한글자씩 빼오는거
  *  scanf() - 형식문자 규칙에 맞게 빼오는거 / 보안결함이 있기 때문에 scanf_s()를 사용하세요, 단 리눅스에는 없습니다. 윈도우에만 있습니다.
  *  gets() - 버퍼에서 한줄씩 빼오는거 / 보안결함이 있기 때문에 gets_s()를 사용하세요
* 논버퍼드 I/O
  * _ getch()
  * 버퍼에서 정보를 읽어오는 것이 아니라, 하드웨어 에서의 인터럽트를 즉시wait하고 있음
* fflush()
  * 버퍼를 비우는 함수
  * 원래는 output만 되는데 윈도우는 input도 됨

# 3장 두 번째

* 주 내용은 전 시간에 배운 내용들을 디버깅 메모리 툴로 메모리를 직접 확인하는 것들을 했다.
* `scan_f()`함수를 사용할 때 버퍼에 남아있는 enter를 제거 하기 위해서 윈도우에서는 `fflush(stdin);`을 사용한다. 리눅스에서는 다른 함수를 사용한다.
* 문자열은 상수화된 문자의 배열이라고 보면 된다.

# 4강 연산자 기본 - 첫 번째
pdf 167페이지

* c언어 프로그램의 구조
  1. 항 - item
  2. 구문 - `~~;`, statement
    * 구문의 흐름을 context라고 한다.
    * 흐름을 갈아타는게 context swiching
  3. 블록스코프 - `{}`
  4. 함수
  5. 함수가 binding(연결)되어서 프로그램이 된다.
* ex) 3 + 4 + 5 = 12
  - 3 + 4 = 7 -> 먼저 연산되는데 결과로 나오는 7은 연산의 임시결과
  - 최종결과 12가 나온 후에 임시결과 7은 삭제된다.
  - 7이 필요하다면 변수에 담아서 저장해야 한다.
* `=` 단순대입 연산자
  - copy & overwrite 를 꼭 기억하자
* ex) `a=10;`
  - a
    - 변수, l-value
    - l-value는 left-value라는 의미와 함께 location-value라는 의미
    - 메모리의 위치를 지정하는 '위치지정자'
* ex) `int a, b=3;` 일 때 `a=b;` a에 b(3)를 대입해보자
  - 3이라는 값이 copy되어서 a로 넘어간다.
  - a는 기존값과 상관없지만 3으로 overwrite된다.
* 이형자료간의 연산, 형승격(type promotion)
  - a + 1 의 결과가 무엇으로 표현 될 것 인가의 문제
  - 결국 char + int 가 되는데 결과는 '표현범위'가 큰 형식이 결과로 나온다.
  - char은 1바이트, int는 4바이트, 따라서 결과의 표현은 int가 된다.
  - ex) 123.45 + 1 의 결과
    - double(실수) + int
    - double이 표현범위가 넓으므로 결과는 double이 된다.
* 곱하기와 나누기
  - 곱하기는 별 어려움이 없는데 나누기는 까다로운 점이 있다.
  - ex) `5/2`
    - int/int 이기 때문에 결과가 int로 나와야 연산되는데 결과가 실수
    - 따라서 소수점 이하가 절사된다.
    - 결과는 2.5가 아니라 2가 된다
  - ex) `5/2.0`
    - int/double 이기 때문에 결과가 double로 나와야함
    - 결과는 double형식의 2.5가 된다.
* 형식을 맞춘다는게 c언어에서는 중요합니다.
* 나머지 연산자
  - 나누기 연산자와 내부적인 것은 같다.
  - ex) `7%2`
    - 결과는 1이 된다.
  - 만약 몫과 나머지를 구하려면 `/연산, %연산`을 활용해 2번 연산을 해야합니다
* 컴퓨터는 어떻게 나눌까?
  - ex) `7/2`
    1. 7-2
    2. 5-2
    3. 3-1
    4. 1
    * 위의 3번까지의 연산이 총3번 -> 몫3
    * 나머지 1
    * 따라서 0으로 나누는 것은 무한루프를 돌기 때문에 0으로 나누는 것은 오류를 낸다

# 제4강 두 번째

* 값교환 ex) `int a=3, b=4, tmp;`
  - `tmp = a;` tmp에 a의 값을 저장해 놓고
  - `a = b;` a에 b의 값을 할당
  - `b = tmp;` b의 tmp의 값을 할당, tmp는 a의 값을 가지고 있으니까
* 복합대입 - 산술연산자나 비트연산자를 합쳐서 하나의 연산자로 만든 것
  - ex)
    - c```
    int a = 0;
    a = a + 1;
    ```
    이름이 a인 변수의 값을 불러와서 그 변수에 1을 더하는 것, 그리고 그 결과를 a에 대입
    줄여서 다음과 같이 표현할 수 있다. `a += 1;`
  - 주의사항
    - 누적을 하기 위해서는 `int a = 0;`과 같이 반드시 변수를 0으로 초기화 시켜줘야 한다.
* 형변환 연산자
  - 강제 형변환
  - 정보가 왜곡되는 현상이 벌어진다.
  - 메모리는 1바이트 단위로 있고 각 바이트별로 주소가 붙어있게 된다. 그런데 4바이트를 int로 지정하게 된다면 이것을 형변환 하게 된다면 메모리주송 대한 변환 없이 해석 방법이 바뀌게 된다. 이러한 것을 강제 형변환 이라고 하며 정보가 왜곡될 우려가 있다.(오동작의 가능성이 있다)
* 단항 증감 연산자
  - c```
  int a = 0;
  a = a + 1;
  a += 1;
  ``
  위의 예시는 다음과 같다
  `++a;`(전위식) 혹은 `a++`(후위식)
  - 누산되는 증감폭이 1이기 때문에 계수로 보면 된다.
  - 반복문에서 몇번이나 연산됬는지 계수 세는 경우 주로 사용됨
* 비트연산자
  - 각각의바이트를 비트단위로 논리연산을 통해 결과를 내놓는 것
  - shift 연산의 경우 `<< >>`각각의 방향으로 비트를 옮겨서 연산하는 것
  - 대효적인 활용예는 '마스크연산'
